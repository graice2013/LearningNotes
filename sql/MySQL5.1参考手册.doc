#
# MySQL5.1参考手册.doc
#
第3章：教程
目录
3.1. 连接与断开服务器 
3.2. 输入查询 
3.3. 创建并使用数据库 
3.3.1. 创建并选择数据库 
3.3.2. 创建表 
3.3.3. 将数据装入表中 
3.3.4. 从表检索信息
3.4. 获得数据库和表的信息 
3.5. 在批处理模式下使用mysql 
3.6. 常用查询的例子 
3.6.1. 列的最大值 
3.6.2. 拥有某个列的最大值的行 
3.6.3. 列的最大值：按组 
3.6.4. 拥有某个字段的组间最大值的行 
3.6.5. 使用用户变量 
3.6.6. 使用外键 
3.6.7. 根据两个键搜索 
3.6.8. 根据天计算访问量 
3.6.9. 使用AUTO_INCREMENT
3.7. 孪生项目的查询 
3.7.1. 查找所有未分发的孪生项 
3.7.2. 显示孪生对状态的表
3.8. 与Apache一起使用MySQL
本章通过演示如何使用mysql客户程序创造和使用一个简单的数据库，提供一个MySQL的入门教程。mysql（有时称为“终端监视器”或只是“监视”）是一个交互式程序，允许你连接一个MySQL服务器，运行查询并察看结果。mysql可以用于批模式：你预先把查询放在一个文件中，然后告诉mysql执行文件的内容。本章将介绍使用mysql的两个方法。
要想查看由mysql提供的选择项目表，可以用--help选项来调用：
shell> mysql --help
本章假定mysql已经被安装在你的机器上，并且有一个MySQL服务器可以连接。否则，请联络MySQL管理员。（如果你是管理员，则需要查阅本手册的其它章节，例如第5章：数据库管理。）
本章描述建立和使用一个数据库的全过程。如果你仅仅对访问一个已经存在的数据库感兴趣，可以跳过描述怎样创建数据库及它所包含的表的章节。
由于本章是一个教程，省略了许多细节。关于这里所涉及的主题的详细信息，请查阅本手册的相关章节。
3.1. 连接与断开服务器
为了连接服务器，当调用mysql时，通常需要提供一个MySQL用户名并且很可能需要一个 密码。如果服务器运行在登录服务器之外的其它机器上，还需要指定主机名。联系管理员以找出进行连接所使用的参数 (即，连接的主机、用户名和使用的密码)。知道正确的参数后，可以按照以下方式进行连接：
shell> mysql -h host -u user -p
Enter password: ********
host和user分别代表MySQL服务器运行的主机名和MySQL账户用户名。设置时替换为正确的值。******** 代表你的密码；当mysql显示Enter password:提示时输入它。
如果有效，你应该看见mysql>提示符后的一些介绍信息：
shell> mysql -h host -u user -p
Enter password: ********
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 25338 to server version: 5.1.2-alpha-standard
 
Type 'help;' or '\h' for help. Type '\c' to clear the buffer.
 
mysql>
mysql> 提示符告诉你mysql准备为你输入命令。
一些MySQL安装允许用户以匿名（未命名）用户连接到本地主机上运行的服务器。如果你的机器是这种情况，你应该能不带任何选项地调用mysql与该服务器连接：
shell> mysql
成功地连接后，可以在mysql>提示下输入QUIT (或\q)随时退出：
mysql> QUIT
Bye
在Unix中，也可以按control-D键断开服务器。
在下列章节的大多数例子都假设你连接到了服务器。由mysql>提示指明。
3.2. 输入查询
确保你连接上了服务器，如在先前的章节讨论的。连接上服务器并布代表选择了任何数据库，但这样就可以了。知道关于如何查询的基本知识，比马上跳至创建表、给他们装载数据并且从他们检索数据更重要。本节描述输入命令的基本原则，使用几个查询，你能尝试了解mysql是如何工作的。
这是一个简单的命令，要求服务器告诉它的版本号和当前日期。在mysql>提示输入如下命令并按回车键：
mysql> SELECT VERSION(), CURRENT_DATE;
+-----------------+--------------+
| VERSION()       | CURRENT_DATE |
+-----------------+--------------+
| 5.1.2-alpha-log | 2005-10-11   |
+-----------------+--------------+
1 row in set (0.01 sec)
mysql>
这询问说明mysql的几个方面:
·         一个命令通常由SQL语句组成，随后跟着一个分号。（有一些例外不需要分号。早先提到的QUIT是一个例子。后面我们将看到其它的例子。）
·         当发出一个命令时，mysql将它发送给服务器并显示执行结果，然后显示另一个mysql>显示它准备好接受其它命令。
·         mysql用表格(行和列)方式显示查询输出。第一行包含列的标签，随后的行是查询结果。通常，列标签是你取自数据库表的列的名字。如果你正在检索一个表达式而非表列的值(如刚才的例子)，mysql用表达式本身标记列。
·         mysql显示返回了多少行，以及查询花了多长时间，它给你提供服务器性能的一个大致概念。因为他们表示时钟时间(不是 CPU 或机器时间)，并且因为他们受到诸如服务器负载和网络延时的影响，因此这些值是不精确的。（为了简洁，在本章其它例子中不再显示“集合中的行”。）
能够以大小写输入关键词。下列查询是等价的：
mysql> SELECT VERSION(), CURRENT_DATE;
mysql> select version(), current_date;
mysql> SeLeCt vErSiOn(), current_DATE;
这是另外一个查询，它说明你能将mysql用作一个简单的计算器：
mysql> SELECT SIN(PI()/4), (4+1)*5;
+------------------+---------+
| SIN(PI()/4)      | (4+1)*5 |
+------------------+---------+
	| 0.70710678118655 |      25 |
+------------------+---------+
1 row in set (0.02 sec)
至此显示的命令是相当短的单行语句。你可以在一行上输入多条语句，只需要以一个分号间隔开各语句：
mysql> SELECT VERSION(); SELECT NOW();
+-----------------+
| VERSION()       |
+-----------------+
| 5.1.2-alpha-log |
+-----------------+
1 row in set (0.00 sec)
 
+---------------------+
| NOW()               |
+---------------------+
| 2005-10-11 15:15:00 |
+---------------------+
1 row in set (0.00 sec)
不必全在一个行内给出一个命令，较长命令可以输入到多个行中。mysql通过寻找终止分号而不是输入行的结束来决定语句在哪儿结束。（换句话说，mysql接受自由格式的输入：它收集输入行但直到看见分号才执行。）
这里是一个简单的多行语句的例子：
mysql> SELECT
    -> USER()
    -> ,
    -> CURRENT_DATE;
+---------------+--------------+
| USER()        | CURRENT_DATE |
+---------------+--------------+
| jon@localhost | 2005-10-11   |
+---------------+--------------+
在这个例子中，在输入多行查询的第一行后，要注意提示符如何从mysql>变为->，这正是mysql如何指出它没见到完整的语句并且正在等待剩余的部分。提示符是你的朋友，因为它提供有价值的反馈，如果使用该反馈，将总是知道mysql正在等待什么。
如果你决定不想执行正在输入过程中的一个命令，输入\c取消它：
mysql> SELECT
    -> USER()
    -> \c
mysql>
这里也要注意提示符，在你输入\c以后，它切换回到mysql>，提供反馈以表明mysql准备接受一个新命令。
下表显示出可以看见的各个提示符并简述它们所表示的mysql的状态：
提示符
含义
mysql>
准备好接受新命令。
->
等待多行命令的下一行。
'>
等待下一行，等待以单引号(“'”)开始的字符串的结束。
">
等待下一行，等待以双引号(“"”)开始的字符串的结束。
`>
等待下一行，等待以反斜点(‘`’)开始的识别符的结束。
/*>
等待下一行，等待以/*开始的注释的结束。
当你打算在一个单行上发出一个命令时，通常会“偶然”出现多行语句，但是没有终止分号。在这种情况中，mysql等待进一步输入：
mysql> SELECT USER()
    ->
如果出现这种情况(你认为输完了语句，但是只有一个->提示符响应)，很可能mysql正在等待分号。如果你没有注意到提示符的提示，在意识到你需要做什么之前，你可能会呆坐一会儿。输入一个分号完成语句，mysql将执行：
mysql> SELECT USER()
    -> ;
+---------------+
| USER()        |
+---------------+
| jon@localhost |
+---------------+
在字符串收集期间将出现 '> 和 "> 提示符（提示MySQL正等待字符串的结束）。在MySQL中，可以写由‘'’或‘"’字符括起来的字符串 (例如，'hello'或"goodbye")，并且mysql允许输入跨越多行的字符串。当看到一个 '> 或 "> 提示符时，这意味着已经输入了包含以‘'’或‘"’括号字符开始的字符串的一行，但是还没有输入终止字符串的匹配引号。这显示你粗心地省掉了一个引号字符。例如：
mysql> SELECT * FROM my_table WHERE name = 'Smith AND age < 30;
    '>
如果你输入SELECT语句，然后按Enter（回车）键并等待结果，什么都没有出现。不要惊讶，“为什么该查询这么长呢？”，注意">提示符提供的线索。它告诉你mysql期望见到一个未终止字符串的余下部分。（你看见语句中的错误吗？字符串"Smith丢掉了第二个引号。）
走到这一步，你该做什么？最简单的是取消命令。然而，在这种情况下，你不能只是输入\c，因为mysql作为它正在收集的字符串的一部分来解释它！相反，应输入关闭的引号字符(这样mysql知道你完成了字符串)，然后输入\c：
mysql> SELECT * FROM my_table WHERE name = 'Smith AND age < 30;
    '> '\c
mysql>
提示符回到mysql>，显示mysql准备好接受一个新命令了。
`> 提示符类似于 '> 和"> 提示符，但表示你已经开始但没有结束以`> 开始的识别符。
知道'>和">提示符的含义很重要，因为如果你错误地输入一个未终止的字符串，任何后面输入的行将要被mysql忽略--包括包含QUIT的行！这可能令人相当困惑，特别是如果取消当前命令前还不知道你需要提供终止引号。
3.3. 创建并使用数据库
3.3.1. 创建并选择数据库 
3.3.2. 创建表 
3.3.3. 将数据装入表中 
3.3.4. 从表检索信息
知道怎样输入命令，便可以访问数据库了。
假定在你的家(你的“动物园”)中有很多宠物，并且你想跟踪关于它们各种类型的信息。你可以通过创建表来保存你的数据并根据所需要的信息装载他们，然后你可以从表中检索数据来回答关于动物不同种类的问题。本节显示如何做到所有这些事情：
·         创建数据库
·         创建数据库表
·         装载数据到数据库表
·         以各种方法从表中检索数据
·         使用多个表
动物园数据库很简单(特意的)，但是不难把它想象成可能用到类似数据库的真实世界情况。例如，农夫可以使用这样的一个数据库来追踪家畜，或者兽医可以用它跟踪病畜记录。从MySQL网址上可以获得后面章节中将用到的含有部分查询和样例数据的动物园分发。有tar压缩格式 (http://downloads.mysql.com/docs/menagerie-db.tar.gz)和Zip压缩格式 (http://downloads.mysql.com/docs/menagerie-db.zip)。
使用SHOW语句找出服务器上当前存在什么数据库：
mysql> SHOW DATABASES;
+----------+
| Database |
+----------+
| mysql    |
| test     |
| tmp      |
+----------+
可能你的机器上的数据库列表是不同的，但是很可能有mysql和test数据库。mysql是必需的，因为它描述用户访问权限，test数据库经常作为用户试身手的工作区。
请注意如果没有SHOW DATABASES权限，则不能看见所有数据库。参见13.5.1.3节，“GRANT和REVOKE语法”。
如果test数据库存在，尝试访问它：
mysql> USE test
Database changed
注意，USE，类似QUIT，不需要一个分号。（如果你喜欢，你可以用一个分号终止这样的语句；这无碍）USE语句在使用上也有另外一个特殊的地方：它必须在一个单行上给出。
你可列在后面的例子中使用test数据库(如果你能访问它)，但是你在该数据库创建的任何东西可以被访问它的其它人删除，因此，你应该询问MySQL管理员许可你使用自己的一个数据库。假定你想要调用你的menagerie，管理员需要执行这样一条命令：
mysql> GRANT ALL ON menagerie.* TO 'your_mysql_name'@'your_client_host';
这里your_mysql_name是分配给你的MySQL用户名，your_client_host是所连接的服务器所在的主机。
3.3.1. 创建并选择数据库
如果管理员在设置权限时为你创建了数据库，你可以开始使用它。否则，你需要自己创建数据库：
mysql> CREATE DATABASE menagerie;
在Unix下，数据库名称是区分大小写的(不像SQL关键字)，因此你必须总是以menagerie访问数据库，而不能用Menagerie、MENAGERIE或其它一些变量。对表名也是这样的。（在Windows下，该限制不适用，尽管你必须在一个给定的查询中使用同样的大小写来引用数据库和表。但是，由于多种原因，作为最好的惯例，一定要使用与数据库创建时的同样的大小写。）
创建数据库并不表示选定并使用它，你必须明确地操作。为了使menagerie成为当前的数据库，使用这个命令：
mysql> USE menagerie
Database changed
数据库只需要创建一次，但是必须在每次启动mysql会话时在使用前先选择它。你可以根据上面的例子执行一个USE语句来实现。还可以在调用mysql时，通过命令行选择数据库，只需要在提供连接参数之后指定数据库名称。例如：
shell> mysql -h host -u user -p menagerie
Enter password: ********
注意，刚才显示的命令行中的menagerie不是你的 密码。如果你想要在命令行上在-p选项后提供 密码，则不能插入空格(例如，如-pmypassword，不是-p mypassword)。但是，不建议在命令行输入密码，因为这样会暴露 密码，能被在机器上登录的其它用户窥探到。
3.3.2. 创建表
创建数据库是很容易的部分，但是在这时它是空的，正如SHOW TABLES将告诉你的：
mysql> SHOW TABLES;
Empty set (0.00 sec)
较难的部分是决定你的数据库结构应该是什么：你需要什么数据库表，各数据库表中有什么样的列。
你将需要一个包含你每个宠物的记录的表。它可称为pet表，并且它应该包含，最少，每个动物的名字。因为名字本身不是很有趣，表应该包含另外的信息。例如，如果在你豢养宠物的家庭有超过一个人，你可能想要列出每个动物的主人。你可能也想要记录例如种类和性别的一些基本的描述信息。
年龄呢？那可能有趣，但是存储到一个数据库中不是一件好事情。年龄随着时间流逝而变化，这意味着你将要不断地更新你的记录。相反, 存储一个固定值例如生日比较好，那么，无论何时你需要年龄，可以以当前日期和出生日期之间的差来计算它。MySQL提供了日期运算函数，因此这并不困难。存储出生日期而非年龄还有其它优点：
·         你可以使用数据库完成这样的任务，例如生成即将到来的宠物生日的提示。（如果你认为这类查询有点蠢，注意，这与从商务数据库来识别出不久要发给生日祝贺的客户是同一个问题，因为计算机帮助私人联络。）
·         你可以相对于日期而不止是当前日期来计算年龄。例如，如果你在数据库存储死亡日期，你能很容易地计算出一只宠物死时有多大。
你可能想到pet表中其它有用的其它类型信息，但是到目前为止这些已经足够了：名字、主人、种类，性别、出生和死亡日期。
使用一个CREATE TABLE语句指定你的数据库表的布局：
mysql> CREATE TABLE pet (name VARCHAR(20), owner VARCHAR(20),
    -> species VARCHAR(20), sex CHAR(1), birth DATE, death DATE);
VARCHAR适合于name、owner和species列，因为列值是变长的。这些列的长度不必都相同，而且不必是20。你可以挑选从1到65535的任何长度，从中选择一个最合理的值。（如果选择得不合适，后来证明你需要一个更长的字段，MySQL提供一个ALTER TABLE语句。）
可以用多种类型的值来表示动物记录中的性别，例如，"m"和"f"，或"male"和"female"。使用单字符"m"和"f"是最简单的方法。
很显然，birth和death列应选用DATE数据类。
创建了数据库表后，SHOW TABLES应该产生一些输出：
mysql> SHOW TABLES;
+---------------------+
| Tables in menagerie |
+---------------------+
| pet                 |
+---------------------+
为了验证你的表是按你期望的方式创建，使用一个DESCRIBE语句：
mysql> DESCRIBE pet;
+---------+-------------+------+-----+---------+-------+
| Field   | Type        | Null | Key | Default | Extra |
+---------+-------------+------+-----+---------+-------+
| name    | varchar(20) | YES  |     | NULL    |       |
| owner   | varchar(20) | YES  |     | NULL    |       |
| species | varchar(20) | YES  |     | NULL    |       |
| sex     | char(1)     | YES  |     | NULL    |       |
| birth   | date        | YES  |     | NULL    |       |
| death   | date        | YES  |     | NULL    |       |
+---------+-------------+------+-----+---------+-------+
你可以随时使用DESCRIBE，例如，如果你忘记表中的列的名称或类型时。
3.3.3. 将数据装入表中
创建表后，需要填入内容。通过LOAD DATA和INSERT语句可以完成该任务。
假定你的宠物纪录描述如下。（假定在MySQL中期望的日期格式是YYYY-MM-DD；这可能与你习惯的不同。）
name
owner
species
sex
birth
death
Fluffy
Harold
cat
f
1993-02-04
 
Claws
Gwen
cat
m
1994-03-17
 
Buffy
Harold
dog
f
1989-05-13
 
Fang
Benny
dog
m
1990-08-27
 
Bowser
Diane
dog
m
1979-08-31
1995-07-29
Chirpy
Gwen
bird
f
1998-09-11
 
Whistler
Gwen
bird
 
1997-12-09
 
Slim
Benny
snake
m
1996-04-29
 
因为你是从一个空表开始的，填充它的一个简易方法是创建一个文本文件，每个动物各一行，然后用一个语句将文件的内容装载到表中。
你可以创建一个文本文件“pet.txt”，每行包含一个记录，用定位符(tab)把值分开，并且以CREATE TABLE语句中列出的列次序给出。对于丢失的值(例如未知的性别，或仍然活着的动物的死亡日期)，你可以使用NULL值。为了在你的文本文件中表示这些内容，使用\N（反斜线，字母N）。例如，Whistler鸟的记录应为(这里值之间的空白是一个定位符)：
name
owner
species
sex
birth
death
Whistler
Gwen
bird
\N
1997-12-09
\N
要想将文本文件“pet.txt”装载到pet表中，使用这个命令：
mysql> LOAD DATA LOCAL INFILE '/path/pet.txt' INTO TABLE pet;
请注意如果用Windows中的编辑器（使用\r\n做为行的结束符）创建文件，应使用：
mysql> LOAD DATA LOCAL INFILE '/path/pet.txt' INTO TABLE pet
    -> LINES TERMINATED BY '\r\n';
（在运行OS X的Apple机上，应使用行结束符'\r'。）
如果你愿意，你能明确地在LOAD DATA语句中指出列值的分隔符和行尾标记，但是默认标记是定位符和换行符。这对读入文件“pet.txt”的语句已经足够。
如果该语句失败，可能是你安装的MySQL不与使用默认值的本地文件兼容。关于如何更改请参见5.6.4节，“LOAD DATA LOCAL安全问题”。
如果想要一次增加一个新记录，可以使用INSERT语句。最简单的形式是，提供每一列的值，其顺序与CREATE TABLE语句中列的顺序相同。假定Diane把一只新仓鼠命名为Puffball，你可以使用下面的INSERT语句添加一条新记录：
mysql> INSERT INTO pet
    -> VALUES ('Puffball','Diane','hamster','f','1999-03-30',NULL);
注意，这里字符串和日期值均为引号扩起来的字符串。另外，可以直接用INSERT语句插入NULL代表不存在的值。不能使用LOAD DATA中所示的的\N。
从这个例子，你应该能看到涉及很多的键入用多个INSERT语句而非单个LOAD DATA语句装载你的初始记录。
3.3.4. 从表检索信息
3.3.4.1. 选择所有数据 
3.3.4.2. 选择特殊行 
3.3.4.3. 选择特殊列 
3.3.4.4. 分类行 
3.3.4.5. 日期计算 
3.3.4.6. NULL值操作 
3.3.4.7. 模式匹配 
3.3.4.8. 计数行 
3.3.4.9. 使用1个以上的表
 
SELECT语句用来从数据表中检索信息。语句的一般格式是：
SELECT what_to_select
FROM which_table
WHERE conditions_to_satisfy;
what_to_select指出你想要看到的内容，可以是列的一个表，或*表示“所有的列”。which_table指出你想要从其检索数据的表。WHERE子句是可选项，如果选择该项，conditions_to_satisfy指定行必须满足的检索条件。
3.3.4.1. 选择所有数据
SELECT最简单的形式是从一个表中检索所有记录：
mysql> SELECT * FROM pet;
+----------+--------+---------+------+------------+------------+
| name     | owner  | species | sex  | birth      | death      |
+----------+--------+---------+------+------------+------------+
| Fluffy   | Harold | cat     | f    | 1993-02-04 | NULL       |
| Claws    | Gwen   | cat     | m    | 1994-03-17 | NULL       |
| Buffy    | Harold | dog     | f    | 1989-05-13 | NULL       |
| Fang     | Benny  | dog     | m    | 1990-08-27 | NULL       |
| Bowser   | Diane  | dog     | m    | 1979-08-31 | 1995-07-29 |
| Chirpy   | Gwen   | bird    | f    | 1998-09-11 | NULL       |
| Whistler | Gwen   | bird    | NULL | 1997-12-09 | NULL       |
| Slim     | Benny  | snake   | m    | 1996-04-29 | NULL       |
| Puffball | Diane  | hamster | f    | 1999-03-30 | NULL       |
+----------+--------+---------+------+------------+------------+
如果你想要浏览整个表，可以使用这种形式的SELECT，例如，刚刚装载了初始数据集以后。也有可能你想到Bowser的生日看起来不很对。查阅你原来的家谱，你发现正确的出生年是1989，而不是1979。
至少有两种修正方法：
·         编辑文件“pet.txt”改正错误，然后使用DELETE和LOAD DATA清空并重新装载表:
·                mysql> DELETE FROM pet;
·                mysql> LOAD DATA LOCAL INFILE 'pet.txt' INTO TABLE pet;
然而, 如果这样操做，必须重新输入Puffball记录。
·         用一个UPDATE语句仅修正错误记录：
·                mysql> UPDATE pet SET birth = '1989-08-31' WHERE name = 'Bowser';
UPDATE只更改有问题的记录，不需要重新装载数据库表。
3.3.4.2. 选择特殊行
如上所示，检索整个表是容易的。只需要从SELECT语句中删掉WHERE子句。但是一般你不想看到整个表，特别地当表变得很大时。相反，你通常对回答一个具体的问题更感兴趣，在这种情况下在你想要的信息上进行一些限制。让我们看一些他们回答的有关你宠物的问题的选择查询。 
可以从表中只选择特定的行。例如，如果你想要验证你对Bowser的生日所做的更改，按下述方法选择Bowser的记录：
mysql> SELECT * FROM pet WHERE name = 'Bowser';
+--------+-------+---------+------+------------+------------+
| name   | owner | species | sex  | birth      | death      |
+--------+-------+---------+------+------------+------------+
| Bowser | Diane | dog     | m    | 1989-08-31 | 1995-07-29 |
+--------+-------+---------+------+------------+------------+
输出证实正确的年份记录为1989，而不是1979。
字符串比较时通常对大小些不敏感，因此你可以将名字指定为"bowser"、"BOWSER"等，查询结果相同。
你可以在任何列上指定条件，不只仅仅是name。例如，如果你想要知道哪个动物在1998以后出生的，测试birth列：
mysql> SELECT * FROM pet WHERE birth > '1998-1-1';
+----------+-------+---------+------+------------+-------+
| name     | owner | species | sex  | birth      | death |
+----------+-------+---------+------+------------+-------+
| Chirpy   | Gwen  | bird    | f    | 1998-09-11 | NULL  |
| Puffball | Diane | hamster | f    | 1999-03-30 | NULL  |
+----------+-------+---------+------+------------+-------+
可以组合条件，例如，找出雌性的狗：
mysql> SELECT * FROM pet WHERE species = 'dog' AND sex = 'f';
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| Buffy | Harold | dog     | f    | 1989-05-13 | NULL  |
+-------+--------+---------+------+------------+-------+
上面的查询使用AND逻辑操作符，也有一个OR操作符：
mysql> SELECT * FROM pet WHERE species = 'snake' OR species = 'bird';
+----------+-------+---------+------+------------+-------+
| name     | owner | species | sex  | birth      | death |
+----------+-------+---------+------+------------+-------+
| Chirpy   | Gwen  | bird    | f    | 1998-09-11 | NULL  |
| Whistler | Gwen  | bird    | NULL | 1997-12-09 | NULL  |
| Slim     | Benny | snake   | m    | 1996-04-29 | NULL  |
+----------+-------+---------+------+------------+-------+
AND和OR可以混用，但AND比OR具有更高的优先级。如果你使用两个操作符，使用圆括号指明如何对条件进行分组是一个好主意：
mysql> SELECT * FROM pet WHERE (species = 'cat' AND sex = 'm')
    -> OR (species = 'dog' AND sex = 'f');
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| Claws | Gwen   | cat     | m    | 1994-03-17 | NULL  |
| Buffy | Harold | dog     | f    | 1989-05-13 | NULL  |
+-------+--------+---------+------+------------+-------+
3.3.4.3. 选择特殊列
如果你不想看到表中的所有行，就命名你感兴趣的列，用逗号分开。例如，如果你想要知道你的动物什么时候出生的，选择name和birth列：
mysql> SELECT name, birth FROM pet;
+----------+------------+
| name     | birth      |
+----------+------------+
| Fluffy   | 1993-02-04 |
| Claws    | 1994-03-17 |
| Buffy    | 1989-05-13 |
| Fang     | 1990-08-27 |
| Bowser   | 1989-08-31 |
| Chirpy   | 1998-09-11 |
| Whistler | 1997-12-09 |
| Slim     | 1996-04-29 |
| Puffball | 1999-03-30 |
+----------+------------+
找出谁拥有宠物，使用这个查询：
mysql> SELECT owner FROM pet;
+--------+
| owner  |
+--------+
| Harold |
| Gwen   |
| Harold |
| Benny  |
| Diane  |
| Gwen   |
| Gwen   |
| Benny  |
| Diane  |
+--------+
请注意该查询只是简单地检索每个记录的owner列，并且他们中的一些出现多次。为了使输出减到最少，增加关键字DISTINCT检索出每个唯一的输出记录：
mysql> SELECT DISTINCT owner FROM pet;
+--------+
| owner  |
+--------+
| Benny  |
| Diane  |
| Gwen   |
| Harold |
+--------+
可以使用一个WHERE子句结合行选择与列选择。例如，要想查询狗和猫的出生日期，使用这个查询：
mysql> SELECT name, species, birth FROM pet
    -> WHERE species = 'dog' OR species = 'cat';
+--------+---------+------------+
| name   | species | birth      |
+--------+---------+------------+
| Fluffy | cat     | 1993-02-04 |
| Claws  | cat     | 1994-03-17 |
| Buffy  | dog     | 1989-05-13 |
| Fang   | dog     | 1990-08-27 |
| Bowser | dog     | 1989-08-31 |
+--------+---------+------------+
3.3.4.4. 分类行
你可能已经注意到前面的例子中结果行没有以特定的顺序显示。然而，当行按某种方式排序时，检查查询输出通常更容易。为了排序结果，使用ORDER BY子句。 
这里是动物生日，按日期排序：
mysql> SELECT name, birth FROM pet ORDER BY birth;
+----------+------------+
| name     | birth      |
+----------+------------+
| Buffy    | 1989-05-13 |
| Bowser   | 1989-08-31 |
| Fang     | 1990-08-27 |
| Fluffy   | 1993-02-04 |
| Claws    | 1994-03-17 |
| Slim     | 1996-04-29 |
| Whistler | 1997-12-09 |
| Chirpy   | 1998-09-11 |
| Puffball | 1999-03-30 |
+----------+------------+
在字符类型列上，与所有其他比较操作类似，分类功能正常情况下是以区分大小写的方式执行的。这意味着，对于等同但大小写不同的列，并未定义其顺序。对于某一列，可以使用BINARY强制执行区分大小写的分类功能，如：ORDER BY BINARY col_name. 
默认排序是升序，最小的值在第一。要想以降序排序，在你正在排序的列名上增加DESC（降序 ）关键字：
mysql> SELECT name, birth FROM pet ORDER BY birth DESC;
+----------+------------+
| name     | birth      |
+----------+------------+
| Puffball | 1999-03-30 |
| Chirpy   | 1998-09-11 |
| Whistler | 1997-12-09 |
| Slim     | 1996-04-29 |
| Claws    | 1994-03-17 |
| Fluffy   | 1993-02-04 |
| Fang     | 1990-08-27 |
| Bowser   | 1989-08-31 |
| Buffy    | 1989-05-13 |
+----------+------------+
可以对多个列进行排序，并且可以按不同的方向对不同的列进行排序。例如，按升序对动物的种类进行排序，然后按降序根据生日对各动物种类进行排序（最年轻的动物在最前面），使用下列查询：
mysql> SELECT name, species, birth FROM pet
    -> ORDER BY species, birth DESC;
+----------+---------+------------+
| name     | species | birth      |
+----------+---------+------------+
| Chirpy   | bird    | 1998-09-11 |
| Whistler | bird    | 1997-12-09 |
| Claws    | cat     | 1994-03-17 |
| Fluffy   | cat     | 1993-02-04 |
| Fang     | dog     | 1990-08-27 |
| Bowser   | dog     | 1989-08-31 |
| Buffy    | dog     | 1989-05-13 |
| Puffball | hamster | 1999-03-30 |
| Slim     | snake   | 1996-04-29 |
+----------+---------+------------+
注意DESC关键字仅适用于在它前面的列名(birth)；不影响species列的排序顺序。
3.3.4.5. 日期计算
MySQL提供了几个函数，可以用来计算日期，例如，计算年龄或提取日期部分。
要想确定每个宠物有多大，可以计算当前日期的年和出生日期之间的差。如果当前日期的日历年比出生日期早，则减去一年。以下查询显示了每个宠物的出生日期、当前日期和年龄数值的年数字。
mysql> SELECT name, birth, CURDATE(),
    -> (YEAR(CURDATE())-YEAR(birth))
    -> - (RIGHT(CURDATE(),5)<RIGHT(birth,5))
    -> AS age
    -> FROM pet;
+----------+------------+------------+------+
| name     | birth      | CURDATE()  | age  |
+----------+------------+------------+------+
| Fluffy   | 1993-02-04 | 2003-08-19 |   10 |
| Claws    | 1994-03-17 | 2003-08-19 |    9 |
| Buffy    | 1989-05-13 | 2003-08-19 |   14 |
| Fang     | 1990-08-27 | 2003-08-19 |   12 |
| Bowser   | 1989-08-31 | 2003-08-19 |   13 |
| Chirpy   | 1998-09-11 | 2003-08-19 |    4 |
| Whistler | 1997-12-09 | 2003-08-19 |    5 |
| Slim     | 1996-04-29 | 2003-08-19 |    7 |
| Puffball | 1999-03-30 | 2003-08-19 |    4 |
+----------+------------+------------+------+
此处，YEAR()提取日期的年部分，RIGHT()提取日期的MM-DD (日历年)部分的最右面5个字符。比较MM-DD值的表达式部分的值一般为1或0，如果CURDATE()的年比birth的年早，则年份应减去1。整个表达式有些难懂，使用alias (age)来使输出的列标记更有意义。
尽管查询可行，如果以某个顺序排列行，则能更容易地浏览结果。添加ORDER BY name子句按照名字对输出进行排序则能够实现。
mysql> SELECT name, birth, CURDATE(),
    -> (YEAR(CURDATE())-YEAR(birth))
    -> - (RIGHT(CURDATE(),5)<RIGHT(birth,5))
    -> AS age
    -> FROM pet ORDER BY name;
+----------+------------+------------+------+
| name     | birth      | CURDATE()  | age  |
+----------+------------+------------+------+
| Bowser   | 1989-08-31 | 2003-08-19 |   13 |
| Buffy    | 1989-05-13 | 2003-08-19 |   14 |
| Chirpy   | 1998-09-11 | 2003-08-19 |    4 |
| Claws    | 1994-03-17 | 2003-08-19 |    9 |
| Fang     | 1990-08-27 | 2003-08-19 |   12 |
| Fluffy   | 1993-02-04 | 2003-08-19 |   10 |
| Puffball | 1999-03-30 | 2003-08-19 |    4 |
| Slim     | 1996-04-29 | 2003-08-19 |    7 |
| Whistler | 1997-12-09 | 2003-08-19 |    5 |
+----------+------------+------------+------+
为了按age而非name排序输出，只要再使用一个ORDER BY子句：
mysql> SELECT name, birth, CURDATE(),
    -> (YEAR(CURDATE())-YEAR(birth))
    -> - (RIGHT(CURDATE(),5)<RIGHT(birth,5))
    -> AS age
    -> FROM pet ORDER BY age;
+----------+------------+------------+------+
| name     | birth      | CURDATE()  | age  |
+----------+------------+------------+------+
| Chirpy   | 1998-09-11 | 2003-08-19 |    4 |
| Puffball | 1999-03-30 | 2003-08-19 |    4 |
| Whistler | 1997-12-09 | 2003-08-19 |    5 |
| Slim     | 1996-04-29 | 2003-08-19 |    7 |
| Claws    | 1994-03-17 | 2003-08-19 |    9 |
| Fluffy   | 1993-02-04 | 2003-08-19 |   10 |
| Fang     | 1990-08-27 | 2003-08-19 |   12 |
| Bowser   | 1989-08-31 | 2003-08-19 |   13 |
| Buffy    | 1989-05-13 | 2003-08-19 |   14 |
+----------+------------+------------+------+
可以使用一个类似的查询来确定已经死亡动物的死亡年龄。你通过检查death值是否是NULL来确定是哪些动物，然后，对于那些非NULL值的动物，需要计算出death和birth值之间的差：
mysql> SELECT name, birth, death,
    -> (YEAR(death)-YEAR(birth)) - (RIGHT(death,5)<RIGHT(birth,5))
    -> AS age
    -> FROM pet WHERE death IS NOT NULL ORDER BY age;
+--------+------------+------------+------+
| name   | birth      | death      | age  |
+--------+------------+------------+------+
| Bowser | 1989-08-31 | 1995-07-29 |    5 |
+--------+------------+------------+------+
查询使用death IS NOT NULL而非death != NULL，因为NULL是特殊的值，不能使用普通比较符来比较，以后会给出解释。参见3.3.4.6节，“NULL值操作”。
如果你想要知道哪个动物下个月过生日，怎么办？对于这类计算，年和天是无关的，你只需要提取birth列的月份部分。MySQL提供几个日期部分的提取函数，例如YEAR( )、MONTH( )和DAYOFMONTH( )。在这里MONTH()是适合的函数。为了看它怎样工作，运行一个简单的查询，显示birth和MONTH(birth)的值：
mysql> SELECT name, birth, MONTH(birth) FROM pet;
+----------+------------+--------------+
| name     | birth      | MONTH(birth) |
+----------+------------+--------------+
| Fluffy   | 1993-02-04 |            2 |
| Claws    | 1994-03-17 |            3 |
| Buffy    | 1989-05-13 |            5 |
| Fang     | 1990-08-27 |            8 |
| Bowser   | 1989-08-31 |            8 |
| Chirpy   | 1998-09-11 |            9 |
| Whistler | 1997-12-09 |           12 |
| Slim     | 1996-04-29 |            4 |
| Puffball | 1999-03-30 |            3 |
+----------+------------+--------------+
找出下个月生日的动物也是容易的。假定当前月是4月，那么月值是4，你可以找在5月出生的动物 (5月)，方法是：
mysql> SELECT name, birth FROM pet WHERE MONTH(birth) = 5;
+-------+------------+
| name  | birth      |
+-------+------------+
| Buffy | 1989-05-13 |
+-------+------------+
如果当前月份是12月，就有点复杂了。你不能只把1加到月份数(12)上并寻找在13月出生的动物，因为没有这样的月份。相反，你应寻找在1月出生的动物(1月) 。
你甚至可以编写查询，不管当前月份是什么它都能工作。采用这种方法不必在查询中使用一个特定的月份，DATE_ADD( )允许在一个给定的日期上加上时间间隔。如果在NOW( )值上加上一个月，然后用MONTH()提取月份，结果产生生日所在月份：
mysql> SELECT name, birth FROM pet
    -> WHERE MONTH(birth) = MONTH(DATE_ADD(CURDATE(),INTERVAL 1 MONTH));
完成该任务的另一个方法是加1以得出当前月份的下一个月(在使用取模函数(MOD)后，如果月份当前值是12，则“回滚”到值0)：
mysql> SELECT name, birth FROM pet
    -> WHERE MONTH(birth) = MOD(MONTH(CURDATE()), 12) + 1;
注意，MONTH返回在1和12之间的一个数字，且MOD(something,12)返回在0和11之间的一个数字，因此必须在MOD( )以后加1，否则我们将从11月( 11 )跳到1月(1)。
3.3.4.6. NULL值操作
NULL值可能令人感到奇怪直到你习惯它。概念上，NULL意味着“没有值”或“未知值”，且它被看作与众不同的值。为了测试NULL，你不能使用算术比较 操作符例如=、<或!=。为了说明它，试试下列查询：
mysql> SELECT 1 = NULL, 1 <> NULL, 1 < NULL, 1 > NULL;
+----------+-----------+----------+----------+
| 1 = NULL | 1 <> NULL | 1 < NULL | 1 > NULL |
+----------+-----------+----------+----------+
|     NULL |      NULL |     NULL |     NULL |
+----------+-----------+----------+----------+
很显然你不能通过这些比较得到有意义的结果。相反使用IS NULL和IS NOT NULL操作符：
mysql> SELECT 1 IS NULL, 1 IS NOT NULL;
+-----------+---------------+
| 1 IS NULL | 1 IS NOT NULL |
+-----------+---------------+
|         0 |             1 |
+-----------+---------------+
请注意在MySQL中，0或 NULL意味着假而其它值意味着真。布尔运算的默认真值是1。
对NULL的特殊处理即是在前面的章节中，为了决定哪个动物不再是活着的，使用death IS NOT NULL而不使用death != NULL的原因。
在GROUP BY中，两个NULL值视为相同。
执行ORDER BY时，如果运行 ORDER BY ... ASC，则NULL值出现在最前面，若运行ORDER BY ... DESC，则NULL值出现在最后面。
NULL操作的常见错误是不能在定义为NOT NULL的列内插入0或空字符串，但事实并非如此。在NULL表示"没有数值"的地方有数值。使用IS [NOT] NULL则可以很容易地进行测试，如下所示：
mysql> SELECT 0 IS NULL, 0 IS NOT NULL, '' IS NULL, '' IS NOT NULL;
+-----------+---------------+------------+----------------+
| 0 IS NULL | 0 IS NOT NULL | '' IS NULL | '' IS NOT NULL |
+-----------+---------------+------------+----------------+
|         0 |             1 |          0 |              1 |
+-----------+---------------+------------+----------------+
因此完全可以在定义为NOT NULL的列内插入0或空字符串，实际是NOT NULL。参见A.5.3节，“与NULL值有关的问题”。
3.3.4.7. 模式匹配
MySQL提供标准的SQL模式匹配，以及一种基于象Unix实用程序如vi、grep和sed的扩展正则表达式模式匹配的格式。
SQL模式匹配允许你使用“_”匹配任何单个字符，而“%”匹配任意数目字符(包括零字符)。在 MySQL中，SQL的模式默认是忽略大小写的。下面给出一些例子。注意使用SQL模式时，不能使用=或!=；而应使用LIKE或NOT LIKE比较操作符。
要想找出以“b”开头的名字：
mysql> SELECT * FROM pet WHERE name LIKE 'b%';
+--------+--------+---------+------+------------+------------+
| name   | owner  | species | sex  | birth      | death      |
+--------+--------+---------+------+------------+------------+
| Buffy  | Harold | dog     | f    | 1989-05-13 | NULL       |
| Bowser | Diane  | dog     | m    | 1989-08-31 | 1995-07-29 |
+--------+--------+---------+------+------------+------------+
要想找出以“fy”结尾的名字：
mysql> SELECT * FROM pet WHERE name LIKE '%fy';
+--------+--------+---------+------+------------+-------+
| name   | owner  | species | sex  | birth      | death |
+--------+--------+---------+------+------------+-------+
| Fluffy | Harold | cat     | f    | 1993-02-04 | NULL  |
| Buffy  | Harold | dog     | f    | 1989-05-13 | NULL  |
+--------+--------+---------+------+------------+-------+
要想找出包含“w”的名字：
mysql> SELECT * FROM pet WHERE name LIKE '%w%';
+----------+-------+---------+------+------------+------------+
| name     | owner | species | sex  | birth      | death      |
+----------+-------+---------+------+------------+------------+
| Claws    | Gwen  | cat     | m    | 1994-03-17 | NULL       |
| Bowser   | Diane | dog     | m    | 1989-08-31 | 1995-07-29 |
| Whistler | Gwen  | bird    | NULL | 1997-12-09 | NULL       |
+----------+-------+---------+------+------------+------------+
要想找出正好包含5个字符的名字，使用“_”模式字符：
mysql> SELECT * FROM pet WHERE name LIKE '_____';
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| Claws | Gwen   | cat     | m    | 1994-03-17 | NULL  |
| Buffy | Harold | dog     | f    | 1989-05-13 | NULL  |
+-------+--------+---------+------+------------+-------+
由MySQL提供的模式匹配的其它类型是使用扩展正则表达式。当你对这类模式进行匹配测试时，使用REGEXP和NOT REGEXP操作符(或RLIKE和NOT RLIKE，它们是同义词)。 
扩展正则表达式的一些字符是： 
·         ‘.’匹配任何单个的字符。
·         字符类“[...]”匹配在方括号内的任何字符。例如，“[abc]”匹配“a”、“b”或“c”。为了命名字符的范围，使用一个“-”。“[a-z]”匹配任何字母，而“[0-9]”匹配任何数字。
·         “ * ”匹配零个或多个在它前面的字符。例如，“x*”匹配任何数量的“x”字符，“[0-9]*”匹配任何数量的数字，而“.*”匹配任何数量的任何字符。
如果REGEXP模式与被测试值的任何地方匹配，模式就匹配(这不同于LIKE模式匹配，只有与整个值匹配，模式才匹配)。 
为了定位一个模式以便它必须匹配被测试值的开始或结尾，在模式开始处使用“^”或在模式的结尾用“$”。 
为了说明扩展正则表达式如何工作，下面使用REGEXP重写上面所示的LIKE查询：
为了找出以“b”开头的名字，使用“^”匹配名字的开始：
mysql> SELECT * FROM pet WHERE name REGEXP '^b';
+--------+--------+---------+------+------------+------------+
| name   | owner  | species | sex  | birth      | death      |
+--------+--------+---------+------+------------+------------+
| Buffy  | Harold | dog     | f    | 1989-05-13 | NULL       |
| Bowser | Diane  | dog     | m    | 1989-08-31 | 1995-07-29 |
+--------+--------+---------+------+------------+------------+
如果你想强制使REGEXP比较区分大小写，使用BINARY关键字使其中一个字符串变为二进制字符串。该查询只匹配名称首字母的小写‘b’。
mysql> SELECT * FROM pet WHERE name REGEXP BINARY '^b';
为了找出以“fy”结尾的名字，使用“$”匹配名字的结尾：
mysql> SELECT * FROM pet WHERE name REGEXP 'fy$';
+--------+--------+---------+------+------------+-------+
| name   | owner  | species | sex  | birth      | death |
+--------+--------+---------+------+------------+-------+
| Fluffy | Harold | cat     | f    | 1993-02-04 | NULL  |
| Buffy  | Harold | dog     | f    | 1989-05-13 | NULL  |
+--------+--------+---------+------+------------+-------+
为了找出包含一个“w”的名字，使用以下查询：
mysql> SELECT * FROM pet WHERE name REGEXP 'w';
+----------+-------+---------+------+------------+------------+
| name     | owner | species | sex  | birth      | death      |
+----------+-------+---------+------+------------+------------+
| Claws    | Gwen  | cat     | m    | 1994-03-17 | NULL       |
| Bowser   | Diane | dog     | m    | 1989-08-31 | 1995-07-29 |
| Whistler | Gwen  | bird    | NULL | 1997-12-09 | NULL       |
+----------+-------+---------+------+------------+------------+
既然如果一个正则表达式出现在值的任何地方，其模式匹配了，就不必在先前的查询中在模式的两侧放置一个通配符以使得它匹配整个值，就像你使用了一个SQL模式那样。
为了找出包含正好5个字符的名字，使用“^”和“$”匹配名字的开始和结尾，和5个“.”实例在两者之间：
mysql> SELECT * FROM pet WHERE name REGEXP '^.....$';
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| Claws | Gwen   | cat     | m    | 1994-03-17 | NULL  |
| Buffy | Harold | dog     | f    | 1989-05-13 | NULL  |
+-------+--------+---------+------+------------+-------+
你也可以使用“{n}”“重复n次”操作符重写前面的查询：
mysql> SELECT * FROM pet WHERE name REGEXP '^.{5}$';
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| Claws | Gwen   | cat     | m    | 1994-03-17 | NULL  |
| Buffy | Harold | dog     | f    | 1989-05-13 | NULL  |
+-------+--------+---------+------+------------+-------+
附录G：MySQL正则表达式 提供了关于正则表达式的句法的详细信息。
3.3.4.8. 计数行
数据库经常用于回答这个问题，“某个类型的数据在表中出现的频度?”例如，你可能想要知道你有多少宠物，或每位主人有多少宠物，或你可能想要对你的动物进行各种类型的普查。 
计算你拥有动物的总数目与“在pet表中有多少行?”是同样的问题，因为每个宠物有一个记录。COUNT(*)函数计算行数，所以计算动物数目的查询应为：
mysql> SELECT COUNT(*) FROM pet;
+----------+
| COUNT(*) |
+----------+
|        9 |
+----------+
在前面，你检索了拥有宠物的人的名字。如果你想要知道每个主人有多少宠物，你可以使用COUNT( )函数：
mysql> SELECT owner, COUNT(*) FROM pet GROUP BY owner;
+--------+----------+
| owner  | COUNT(*) |
+--------+----------+
| Benny  |        2 |
| Diane  |        2 |
| Gwen   |        3 |
| Harold |        2 |
+--------+----------+
注意，使用GROUP BY对每个owner的所有记录分组，没有它，你会得到错误消息：
mysql> SELECT owner, COUNT(*) FROM pet;
ERROR 1140 (42000): Mixing of GROUP columns (MIN(),MAX(),COUNT(),...) 
with no GROUP columns is illegal if there is no GROUP BY clause
COUNT( )和GROUP BY以各种方式分类你的数据。下列例子显示出进行动物普查操作的不同方式。
每种动物的数量：
mysql> SELECT species, COUNT(*) FROM pet GROUP BY species;
+---------+----------+
| species | COUNT(*) |
+---------+----------+
| bird    |        2 |
| cat     |        2 |
| dog     |        3 |
| hamster |        1 |
| snake   |        1 |
+---------+----------+
每种性别的动物数量：
mysql> SELECT sex, COUNT(*) FROM pet GROUP BY sex;
+------+----------+
| sex  | COUNT(*) |
+------+----------+
| NULL |        1 |
| f    |        4 |
| m    |        4 |
+------+----------+
（在这个输出中，NULL表示“未知性别”。）
按种类和性别组合的动物数量： 
mysql> SELECT species, sex, COUNT(*) FROM pet GROUP BY species, sex;
+---------+------+----------+
| species | sex  | COUNT(*) |
+---------+------+----------+
| bird    | NULL |        1 |
| bird    | f    |        1 |
| cat     | f    |        1 |
| cat     | m    |        1 |
| dog     | f    |        1 |
| dog     | m    |        2 |
| hamster | f    |        1 |
| snake   | m    |        1 |
+---------+------+----------+
若使用COUNT( )，你不必检索整个表。例如, 前面的查询，当只对狗和猫进行时，应为：
mysql> SELECT species, sex, COUNT(*) FROM pet
    -> WHERE species = 'dog' OR species = 'cat'
    -> GROUP BY species, sex;
+---------+------+----------+
| species | sex  | COUNT(*) |
+---------+------+----------+
| cat     | f    |        1 |
| cat     | m    |        1 |
| dog     | f    |        1 |
| dog     | m    |        2 |
+---------+------+----------+
或，如果你仅需要知道已知性别的按性别的动物数目：
mysql> SELECT species, sex, COUNT(*) FROM pet
    -> WHERE sex IS NOT NULL
    -> GROUP BY species, sex;
+---------+------+----------+
| species | sex  | COUNT(*) |
+---------+------+----------+
| bird    | f    |        1 |
| cat     | f    |        1 |
| cat     | m    |        1 |
| dog     | f    |        1 |
| dog     | m    |        2 |
| hamster | f    |        1 |
| snake   | m    |        1 |
+---------+------+----------+
3.3.4.9. 使用1个以上的表
 
pet表追踪你有哪个宠物。如果你想要记录其它相关信息，例如在他们一生中看兽医或何时后代出生，你需要另外的表。这张表应该像什么呢？需要： 
·         它需要包含宠物名字以便你知道每个事件属于哪个动物。
·         需要一个日期以便你知道事件是什么时候发生的。
·         需要一个描述事件的字段。
·         如果你想要对事件进行分类，则需要一个事件类型字段。
综合上述因素，event表的CREATE TABLE语句应为：
mysql> CREATE TABLE event (name VARCHAR(20), date DATE,
    -> type VARCHAR(15), remark VARCHAR(255));
对于pet表，最容易的方法是创建包含信息的用定位符分隔的文本文件来装载初始记录：
name
date
type
remark
Fluffy
1995-05-15
litter
4 kittens, 3 female, 1 male
Buffy
1993-06-23
litter
5 puppies, 2 female, 3 male
Buffy
1994-06-19
litter
3 puppies, 3 female
Chirpy
1999-03-21
vet
needed beak straightened
Slim
1997-08-03
vet
broken rib
Bowser
1991-10-12
kennel
 
Fang
1991-10-12
kennel
 
Fang
1998-08-28
birthday
Gave him a new chew toy
Claws
1998-03-17
birthday
Gave him a new flea collar
Whistler
1998-12-09
birthday
First birthday
采用如下方式装载记录：
mysql> LOAD DATA LOCAL INFILE 'event.txt' INTO TABLE event;
根据你从已经运行在pet表上的查询中学到的，你应该能执行对event表中记录的检索；原理是一样的。但是什么时候event表本身不能回答你可能问的问题呢？
当他们有了一窝小动物时，假定你想要找出每只宠物的年龄。我们前面看到了如何通过两个日期计算年龄。event表中有母亲的生产日期，但是为了计算母亲的年龄，你需要她的出生日期，存储在pet表中。说明查询需要两个表：
mysql> SELECT pet.name,
    -> (YEAR(date)-YEAR(birth)) - (RIGHT(date,5)<RIGHT(birth,5)) AS age,
    -> remark
    -> FROM pet, event
    -> WHERE pet.name = event.name AND event.type = 'litter';
+--------+------+-----------------------------+
| name   | age  | remark                      |
+--------+------+-----------------------------+
| Fluffy |    2 | 4 kittens, 3 female, 1 male |
| Buffy  |    4 | 5 puppies, 2 female, 3 male |
| Buffy  |    5 | 3 puppies, 3 female         |
+--------+------+-----------------------------+
关于该查询要注意的几件事情：
FROM子句列出两个表，因为查询需要从两个表提取信息。 
当从多个表组合(联结)信息时，你需要指定一个表中的记录怎样能匹配其它表的记录。这很简单，因为它们都有一个name列。查询使用WHERE子句基于name值来匹配2个表中的记录。 
因为name列出现在两个表中，当引用列时，你一定要指定哪个表。把表名附在列名前即可以实现。 
你不必有2个不同的表来进行联结。如果你想要将一个表的记录与同一个表的其它记录进行比较，可以将一个表联结到自身。例如，为了在你的宠物之中繁殖配偶，你可以用pet联结自身来进行相似种类的雄雌配对：
 
mysql> SELECT p1.name, p1.sex, p2.name, p2.sex, p1.species
    -> FROM pet AS p1, pet AS p2
    -> WHERE p1.species = p2.species AND p1.sex = 'f' AND p2.sex = 'm';
+--------+------+--------+------+---------+
| name   | sex  | name   | sex  | species |
+--------+------+--------+------+---------+
| Fluffy | f    | Claws  | m    | cat     |
| Buffy  | f    | Fang   | m    | dog     |
| Buffy  | f    | Bowser | m    | dog     |
+--------+------+--------+------+---------+
在这个查询中，我们为表名指定别名以便能引用列并且使得每一个列引用与哪个表实例相关联更直观。
3.4. 获得数据库和表的信息
如果你忘记数据库或表的名字，或给定的表的结构是什么(例如，它的列叫什么)，怎么办？MySQL通过提供数据库及其支持的表的信息的几个语句解决这个问题。 
你已经见到了SHOW DATABASES，它列出由服务器管理的数据库。为了找出当前选择了哪个数据库，使用DATABASE( )函数：
mysql> SELECT DATABASE();
+------------+
| DATABASE() |
+------------+
| menagerie  |
+------------+
如果你还没选择任何数据库，结果是NULL。
为了找出当前的数据库包含什么表(例如，当你不能确定一个表的名字)，使用这个命令：
mysql> SHOW TABLES;
+---------------------+
| Tables in menagerie |
+---------------------+
| event               |
| pet                 |
+---------------------+
如果你想要知道一个表的结构，可以使用DESCRIBE命令；它显示表中每个列的信息：
mysql> DESCRIBE pet;
+---------+-------------+------+-----+---------+-------+
| Field   | Type        | Null | Key | Default | Extra |
+---------+-------------+------+-----+---------+-------+
| name    | varchar(20) | YES  |     | NULL    |       |
| owner   | varchar(20) | YES  |     | NULL    |       |
| species | varchar(20) | YES  |     | NULL    |       |
| sex     | char(1)     | YES  |     | NULL    |       |
| birth   | date        | YES  |     | NULL    |       |
| death   | date        | YES  |     | NULL    |       |
+---------+-------------+------+-----+---------+-------+
Field显示列名字，Type是列的数据类型，Null表示列是否能包含NULL值，Key显示列是否被索引而Default指定列的默认值。
如果表有索引，SHOW INDEX FROM tbl_name生成有关索引的信息。
3.5. 在批处理模式下使用mysql
在前面的章节中，你交互式地使用mysql输入查询并且查看结果。你也可以以批模式运行mysql。为了做到这些，把你想要运行的命令放在一个文件中，然后告诉mysql从文件读取它的输入：
shell> mysql < batch-file
如果在Windows下运行mysql，并且文件中有一些可以造成问题的特殊字符，可以这样操作：
C:\> mysql -e "source batch-file"
如果你需要在命令行上指定连接参数，命令应为：
shell> mysql -h host -u user -p < batch-file
Enter password: ********
当这样操作mysql时，则创建一个脚本文件，然后执行脚本。
如果你想在语句出现错误的时候仍想继续执行脚本，则应使用--force命令行选项。
为什么要使用一个脚本？有很多原因：
如果你需要重复运行查询(比如说，每天或每周)，可以把它编成一个脚本，则每次执行时不必重新键入。 
可以通过拷贝并编辑脚本文件从类似的现有的查询生成一个新查询。 
当你正在开发查询时，批模式也是很有用的，特别对多行命令或多语句命令序列。如果你犯了一个错误，你不必重新输入所有内容，只需要编辑脚本来改正错误，然后告诉mysql再次执行脚本。 
如果你有一个产生多个输出的查询，你可以通过一个分页器而不是盯着它翻屏到屏幕的顶端来运行输出： 
·                shell> mysql < batch-file | more
你可以捕捉文件中的输出以便进行进一步的处理： 
·                shell> mysql < batch-file > mysql.out
你可以将脚本分发给另外的人，以便他们也能运行命令。 
某些情况不允许交互地使用，例如, 当你从一个cron任务中运行查询时。在这种情况下，你必须使用批模式。 
当你以批模式运行mysql时，比起你交互地使用它时，其默认输出格式是不同的(更简明些)。例如，当交互式运行SELECT DISTINCT species FROM pet时，输出应为：
 
+---------+
| species |
+---------+
| bird    |
| cat     |
| dog     |
| hamster |
| snake   |
+---------+
但是当以批模式运行时，输出应为：
species
bird
cat
dog
hamster
snake
如果你想要在批模式中得到交互输出格式，使用mysql -t。为了回显以输出被执行的命令，使用mysql -vvv。
你还可以使用源代码或 \.命令从mysql提示符运行脚本：
mysql> source filename;
mysql> \. filename
3.6. 常用查询的例子
3.6.1. 列的最大值 
3.6.2. 拥有某个列的最大值的行 
3.6.3. 列的最大值：按组 
3.6.4. 拥有某个字段的组间最大值的行 
3.6.5. 使用用户变量 
3.6.6. 使用外键 
3.6.7. 根据两个键搜索 
3.6.8. 根据天计算访问量 
3.6.9. 使用AUTO_INCREMENT
下面是一些学习如何用MySQL解决一些常见问题的例子。
在一些例子中，使用数据库表“shop”来储存某个商人（经销商）的每件物品(物品号)的价格。假定每个商人对每项物品有一个固定价格，那么(物品，商人)即为该记录的主关键字。
启动命令行工具mysql并选择数据库：
shell> mysql your-database-name
（在大多数MySQL中，你可以使用test数据库）。
你可以使用以下语句创建示例表：
mysql> CREATE TABLE shop (
    -> article INT(4) UNSIGNED ZEROFILL DEFAULT '0000' NOT NULL,
    -> dealer  CHAR(20)                 DEFAULT ''     NOT NULL,
    -> price   DOUBLE(16,2)             DEFAULT '0.00' NOT NULL,
    -> PRIMARY KEY(article, dealer));
mysql> INSERT INTO shop VALUES
    -> (1,'A',3.45),(1,'B',3.99),(2,'A',10.99),(3,'B',1.45),
    -> (3,'C',1.69),(3,'D',1.25),(4,'D',19.95);
执行语句后，表应包含以下内容：
mysql> SELECT * FROM shop;
+---------+--------+-------+
| article | dealer | price |
+---------+--------+-------+
|    0001 | A      |  3.45 |
|    0001 | B      |  3.99 |
|    0002 | A      | 10.99 |
|    0003 | B      |  1.45 |
|    0003 | C      |  1.69 |
|    0003 | D      |  1.25 |
|    0004 | D      | 19.95 |
+---------+--------+-------+
3.6.1. 列的最大值
“最大的物品号是什么？”
SELECT MAX(article) AS article FROM shop;

+---------+
| article |
+---------+
|       4 |
+---------+
3.6.2. 拥有某个列的最大值的行
任务：找出最贵物品的编号、销售商和价格。 
这很容易用一个子查询做到：
SELECT article, dealer, price
FROM   shop
WHERE  price=(SELECT MAX(price) FROM shop);
另一个解决方案是按价格降序排序所有行并用MySQL特定LIMIT子句只得到第一行：
SELECT article, dealer, price
FROM shop
ORDER BY price DESC
LIMIT 1;
注:如果有多项最贵的物品( 例如每个的价格为19.95)，LIMIT解决方案仅仅显示其中一个！
3.6.3. 列的最大值：按组
任务：每项物品的的最高价格是多少？
SELECT article, MAX(price) AS price
FROM   shop
GROUP BY article

+---------+-------+
| article | price |
+---------+-------+
|    0001 |  3.99 |
|    0002 | 10.99 |
|    0003 |  1.69 |
|    0004 | 19.95 |
+---------+-------+
3.6.4. 拥有某个字段的组间最大值的行
任务：对每项物品，找出最贵价格的物品的经销商。
可以用这样一个子查询解决该问题：
SELECT article, dealer, price
FROM   shop s1
WHERE  price=(SELECT MAX(s2.price)
              FROM shop s2
              WHERE s1.article = s2.article);
3.6.5. 使用用户变量
你可以清空MySQL用户变量以记录结果，不必将它们保存到客户端的临时变量中。（参见 9.3节，“用户变量”.）。
例如，要找出价格最高或最低的物品的，其方法是：
mysql> SELECT @min_price:=MIN(price),@max_price:=MAX(price) FROM shop;
mysql> SELECT * FROM shop WHERE price=@min_price OR price=@max_price;
+---------+--------+-------+
| article | dealer | price |
+---------+--------+-------+
|    0003 | D      |  1.25 |
|    0004 | D      | 19.95 |
+---------+--------+-------+
3.6.6. 使用外键
在MySQL中，InnoDB表支持对外部关键字约束条件的检查。参见15.2节，“InnoDB存储引擎”。还可以参见 1.8.5.5节，“外键”。
只是联接两个表时，不需要外部关键字。对于除InnoDB类型的表，当使用REFERENCES tbl_name(col_name)子句定义列时可以使用外部关键字，该子句没有实际的效果，只作为备忘录或注释来提醒，你目前正定义的列指向另一个表中的一个列。执行该语句时，实现下面很重要：
·         MySQL不执行表tbl_name 中的动作，例如作为你正定义的表中的行的动作的响应而删除行；换句话说，该句法不会致使ON DELETE或ON UPDATE行为（如果你在REFERENCES子句中写入ON DELETE或ON UPDATE子句，将被忽略）。
·         该句法可以创建一个column；但不创建任何索引或关键字。
·         如果用该句法定义InnoDB表，将会导致错误。
你可以使用作为联接列创建的列，如下所示：
CREATE TABLE person (
    id SMALLINT UNSIGNED NOT NULL AUTO_INCREMENT,
    name CHAR(60) NOT NULL,
    PRIMARY KEY (id)
);
 
CREATE TABLE shirt (
    id SMALLINT UNSIGNED NOT NULL AUTO_INCREMENT,
    style ENUM('t-shirt', 'polo', 'dress') NOT NULL,
    color ENUM('red', 'blue', 'orange', 'white', 'black') NOT NULL,
    owner SMALLINT UNSIGNED NOT NULL REFERENCES person(id),
    PRIMARY KEY (id)
);
 
INSERT INTO person VALUES (NULL, 'Antonio Paz');
 
SELECT @last := LAST_INSERT_ID();
 
INSERT INTO shirt VALUES
(NULL, 'polo', 'blue', @last),
(NULL, 'dress', 'white', @last),
(NULL, 't-shirt', 'blue', @last);
 
INSERT INTO person VALUES (NULL, 'Lilliana Angelovska');
 
SELECT @last := LAST_INSERT_ID();
 
INSERT INTO shirt VALUES
(NULL, 'dress', 'orange', @last),
(NULL, 'polo', 'red', @last),
(NULL, 'dress', 'blue', @last),
(NULL, 't-shirt', 'white', @last);
 
SELECT * FROM person;
+----+---------------------+
| id | name                |
+----+---------------------+
|  1 | Antonio Paz         |
|  2 | Lilliana Angelovska |
+----+---------------------+
 
SELECT * FROM shirt;
+----+---------+--------+-------+
| id | style   | color  | owner |
+----+---------+--------+-------+
|  1 | polo    | blue   |     1 |
|  2 | dress   | white  |     1 |
|  3 | t-shirt | blue   |     1 |
|  4 | dress   | orange |     2 |
|  5 | polo    | red    |     2 |
|  6 | dress   | blue   |     2 |
|  7 | t-shirt | white  |     2 |
+----+---------+--------+-------+
 
 
SELECT s.* FROM person p, shirt s
 WHERE p.name LIKE 'Lilliana%'
   AND s.owner = p.id
   AND s.color <> 'white';
 
+----+-------+--------+-------+
| id | style | color  | owner |
+----+-------+--------+-------+
|  4 | dress | orange |     2 |
|  5 | polo  | red    |     2 |
|  6 | dress | blue   |     2 |
+----+-------+--------+-------+
按照这种方式使用，REFERENCES子句不会显示在SHOW CREATE TABLE或DESCRIBE的输出中: 
SHOW CREATE TABLE shirt\G
*************************** 1. row ***************************
Table: shirt
Create Table: CREATE TABLE `shirt` (
`id` smallint(5) unsigned NOT NULL auto_increment,
`style` enum('t-shirt','polo','dress') NOT NULL,
`color` enum('red','blue','orange','white','black') NOT NULL,
`owner` smallint(5) unsigned NOT NULL,
PRIMARY KEY  (`id`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1
在列定义中，按这种方式使用REFERENCES作为注释或“提示”适用于表MyISAM和BerkeleyDB。
3.6.7. 根据两个键搜索
可以充分利用使用单关键字的OR子句，如同AND的处理。
一个比较灵活的例子是寻找两个通过OR组合到一起的关键字：
SELECT field1_index, field2_index FROM test_table
WHERE field1_index = '1' OR  field2_index = '1'
该情形是已经优化过的。参见7.2.6节，“索引合并优化”。
还可以使用UNION将两个单独的SELECT语句的输出合成到一起来更有效地解决该问题。参见13.2.7.2节，“UNION语法
”。
每个SELECT只搜索一个关键字，可以进行优化：
SELECT field1_index, field2_index
    FROM test_table WHERE field1_index = '1'
UNION
SELECT field1_index, field2_index
    FROM test_table WHERE field2_index = '1';
3.6.8. 根据天计算访问量
下面的例子显示了如何使用位组函数来计算每个月中用户访问网页的天数。
CREATE TABLE t1 (year YEAR(4), month INT(2) UNSIGNED ZEROFILL,
             day INT(2) UNSIGNED ZEROFILL);
INSERT INTO t1 VALUES(2000,1,1),(2000,1,20),(2000,1,30),(2000,2,2),
            (2000,2,23),(2000,2,23);
示例表中含有代表用户访问网页的年－月－日值。可以使用以下查询来确定每个月的访问天数：
SELECT year,month,BIT_COUNT(BIT_OR(1<<day)) AS days FROM t1
       GROUP BY year,month;
将返回：
+------+-------+------+
| year | month | days |
+------+-------+------+
| 2000 |    01 |    3 |
| 2000 |    02 |    2 |
+------+-------+------+
该查询计算了在表中按年/月组合的不同天数，可以自动去除重复的询问。
3.6.9. 使用AUTO_INCREMENT
可以通过AUTO_INCREMENT属性为新的行产生唯一的标识：
CREATE TABLE animals (
     id MEDIUMINT NOT NULL AUTO_INCREMENT,
     name CHAR(30) NOT NULL,
     PRIMARY KEY (id)
 );
 
INSERT INTO animals (name) VALUES 
    ('dog'),('cat'),('penguin'),
    ('lax'),('whale'),('ostrich');
 
SELECT * FROM animals;
将返回：
+----+---------+
| id | name    |
+----+---------+
|  1 | dog     |
|  2 | cat     |
|  3 | penguin |
|  4 | lax     |
|  5 | whale   |
|  6 | ostrich |
+----+---------+
你可以使用LAST_INSERT_ID()SQL函数或mysql_insert_id() C API函数来查询最新的AUTO_INCREMENT值。这些函数与具体连接有关，因此其返回值不会被其它执行插入功能的连接影响。
注释：对于多行插入，LAST_INSERT_ID()和mysql_insert_id()从插入的第一行实际返回AUTO_INCREMENT关键字。在复制设置中，通过该函数可以在其它服务器上正确复制多行插入。
对于MyISAM和BDB表，你可以在第二栏指定AUTO_INCREMENT以及多列索引。此时，AUTO_INCREMENT列生成的值的计算方法为：MAX(auto_increment_column) + 1 WHERE prefix=given-prefix。如果想要将数据放入到排序的组中可以使用该方法。
CREATE TABLE animals (
    grp ENUM('fish','mammal','bird') NOT NULL,
    id MEDIUMINT NOT NULL AUTO_INCREMENT,
    name CHAR(30) NOT NULL,
    PRIMARY KEY (grp,id)
);
 
INSERT INTO animals (grp,name) VALUES 
    ('mammal','dog'),('mammal','cat'),
    ('bird','penguin'),('fish','lax'),('mammal','whale'),
    ('bird','ostrich');
 
SELECT * FROM animals ORDER BY grp,id;
将返回：
+--------+----+---------+
| grp    | id | name    |
+--------+----+---------+
| fish   |  1 | lax     |
| mammal |  1 | dog     |
| mammal |  2 | cat     |
| mammal |  3 | whale   |
| bird   |  1 | penguin |
| bird   |  2 | ostrich |
+--------+----+---------+
请注意在这种情况下（AUTO_INCREMENT列是多列索引的一部分），如果你在任何组中删除有最大AUTO_INCREMENT值的行，将会重新用到AUTO_INCREMENT值。对于MyISAM表也如此,对于该表一般不重复使用AUTO_INCREMENT值。
如果AUTO_INCREMENT列是多索引的一部分，MySQL将使用该索引生成以AUTO_INCREMENT列开始的序列值。。例如，如果animals表含有索引PRIMARY KEY (grp, id)和INDEX(id)，MySQL生成序列值时将忽略PRIMARY KEY。结果是，该表包含一个单个的序列，而不是符合grp值的序列。
要想以AUTO_INCREMENT值开始而不是1，你可以通过CREATE TABLE或ALTER TABLE来设置该值，如下所示:
mysql> ALTER TABLE tbl AUTO_INCREMENT = 100;
关于AUTO_INCREMENT的详细信息：
·         如何为列指定AUTO_INCREMENT属性：13.1.5节，“CREATE TABLE语法”和 13.1.2节，“ALTER TABLE语法”。
·         AUTO_INCREMENT的动作取决于SQL模式：5.3.2节，“SQL服务器模式”。
·         找出含有最新AUTO_INCREMENT值的行：12.1.3节，“比较函数和操作符”。
·         设置将用到的AUTO_INCREMENT值: 13.5.3节，“SET语法” 。
·         AUTO_INCREMENT和复制：6.7节，“复制特性和已知问题”. 
·         AUTO_INCREMENT相关的可用于复制的Server-system变量(auto_increment_increment和auto_increment_offset)：5.3.3节，“服务器系统变量”。
3.7. 孪生项目的查询
3.7.1. 查找所有未分发的孪生项 
3.7.2. 显示孪生对状态的表
这个项目是Institute of Environmental Medicine at Karolinska Institutet Stockholm 和 the Section on Clinical Research in Aging and Psychology at the University of Southern California的合作项目。
该项目包括筛选部分，即通过电话回访在瑞典超过 65 岁的所有孪生。满足某种标准的孪生进入下一阶段。在下一阶段中，医生/护士小组将访问想参加的孪生。部分检查包括物理检查和神经、心理检查、实验室试验、神经成像、心理状况评估和家族历史搜集。并且，应根据医疗和环境风险因素来搜集数据。
可从以下链接找到孪生研究的更多信息：
http://www.mep.ki.se/twinreg/index_en.html 
用一个用Perl和MySQL编写的web接口来管理项目的后面部分。
每天晚上所有会谈的数据被移入一个MySQL数据库。
3.7.1. 查找所有未分发的孪生项
下列查询用来决定谁进入项目的第二部分：
SELECT
    CONCAT(p1.id, p1.tvab) + 0 AS tvid,
    CONCAT(p1.christian_name, ' ', p1.surname) AS Name,
    p1.postal_code AS Code,
    p1.city AS City,
    pg.abrev AS Area,
    IF(td.participation = 'Aborted', 'A', ' ') AS A,
    p1.dead AS dead1,
    l.event AS event1,
    td.suspect AS tsuspect1,
    id.suspect AS isuspect1,
    td.severe AS tsevere1,
    id.severe AS isevere1,
    p2.dead AS dead2,
    l2.event AS event2,
    h2.nurse AS nurse2,
    h2.doctor AS doctor2,
    td2.suspect AS tsuspect2,
    id2.suspect AS isuspect2,
    td2.severe AS tsevere2,
    id2.severe AS isevere2,
    l.finish_date
FROM
    twin_project AS tp
    /* For Twin 1 */
    LEFT JOIN twin_data AS td ON tp.id = td.id
              AND tp.tvab = td.tvab
    LEFT JOIN informant_data AS id ON tp.id = id.id
              AND tp.tvab = id.tvab
    LEFT JOIN harmony AS h ON tp.id = h.id
              AND tp.tvab = h.tvab
    LEFT JOIN lentus AS l ON tp.id = l.id
              AND tp.tvab = l.tvab
    /* For Twin 2 */
    LEFT JOIN twin_data AS td2 ON p2.id = td2.id
              AND p2.tvab = td2.tvab
    LEFT JOIN informant_data AS id2 ON p2.id = id2.id
              AND p2.tvab = id2.tvab
    LEFT JOIN harmony AS h2 ON p2.id = h2.id
              AND p2.tvab = h2.tvab
    LEFT JOIN lentus AS l2 ON p2.id = l2.id
              AND p2.tvab = l2.tvab,
    person_data AS p1,
    person_data AS p2,
    postal_groups AS pg
WHERE
    /* p1 gets main twin and p2 gets his/her twin. */
    /* ptvab is a field inverted from tvab */
    p1.id = tp.id AND p1.tvab = tp.tvab AND
    p2.id = p1.id AND p2.ptvab = p1.tvab AND
    /* Just the screening survey */
    tp.survey_no = 5 AND
    /* Skip if partner died before 65 but allow emigration (dead=9) */
    (p2.dead = 0 OR p2.dead = 9 OR
     (p2.dead = 1 AND
      (p2.death_date = 0 OR
       (((TO_DAYS(p2.death_date) - TO_DAYS(p2.birthday)) / 365)
        >= 65))))
    AND
    (
    /* Twin is suspect */
    (td.future_contact = 'Yes' AND td.suspect = 2) OR
    /* Twin is suspect - Informant is Blessed */
    (td.future_contact = 'Yes' AND td.suspect = 1
                               AND id.suspect = 1) OR
    /* No twin - Informant is Blessed */
    (ISNULL(td.suspect) AND id.suspect = 1
                        AND id.future_contact = 'Yes') OR
    /* Twin broken off - Informant is Blessed */
    (td.participation = 'Aborted'
     AND id.suspect = 1 AND id.future_contact = 'Yes') OR
    /* Twin broken off - No inform - Have partner */
    (td.participation = 'Aborted' AND ISNULL(id.suspect)
                                  AND p2.dead = 0))
    AND
    l.event = 'Finished'
    /* Get at area code */
    AND SUBSTRING(p1.postal_code, 1, 2) = pg.code
    /* Not already distributed */
    AND (h.nurse IS NULL OR h.nurse=00 OR h.doctor=00)
    /* Has not refused or been aborted */
    AND NOT (h.status = 'Refused' OR h.status = 'Aborted'
    OR h.status = 'Died' OR h.status = 'Other')
ORDER BY
    tvid;
一些解释：
·         CONCAT(p1.id, p1.tvab) + 0 AS tvid
我们想要在id和tvab的连接上以数字顺序排序。结果加0使得MySQL把结果变为一个数字。
·         列id
这标识一对孪生。它是所有表中的一个键。
·         列tvab 
这标识孪生中的一个。它的值为1或2。
·         列ptvab
这是tvab的一个逆运算。当tvab是1，它是2，反之亦然。它用来保存输入并且使MySQL的优化查询更容易。
这个查询表明，怎样用联结(p1和p2)从同一个表中查找表。在例子中，这被用来检查孪生的一个是否在65岁前死了。如果如此，行不返回值。
上述所有孪生信息存在于所有表中。我们对id,tvab（所有表）和id,ptvab (person_data) 上采用键以使查询更快。
在我们的生产机器上(一台200MHz UltraSPARC)，这个查询返回大约 150-200 行并且时间不超过一秒。
表
行数
person_data
71074
lentus
5291
twin_project
5286
twin_data
2012
informant_data
663
harmony
381
postal_groups
100
3.7.2. 显示孪生对状态的表
每一次会面以一个称为event的状态码结束。下面显示的查询被用来显示按事件组合的所有孪生的表。这表明多少对孪生已经完成，多少对的其中之一已完成而另一个拒绝了，等等。
SELECT
        t1.event,
        t2.event,
        COUNT(*)
FROM
        lentus AS t1,
        lentus AS t2,
        twin_project AS tp
WHERE
        /* We are looking at one pair at a time */
        t1.id = tp.id
        AND t1.tvab=tp.tvab
        AND t1.id = t2.id
        /* Just the screening survey */
        AND tp.survey_no = 5
        /* This makes each pair only appear once */
        AND t1.tvab='1' AND t2.tvab='2'
GROUP BY
        t1.event, t2.event;
3.8. 与Apache一起使用MySQL
还有一些项目，你可以从MySQL数据库鉴别用户，并且你还可以将日志文件写入MySQL数据库表。 
你可以将以下内容放到Apache配置文件中，更改Apache日志格式，使MySQL更容易读取：
LogFormat \
        "\"%h\",%{%Y%m%d%H%M%S}t,%>s,\"%b\",\"%{Content-Type}o\",  \
        \"%U\",\"%{Referer}i\",\"%{User-Agent}i\""
要想将该格式的日志文件装载到MySQL，你可以使用以下语句: 
LOAD DATA INFILE '/local/access_log' INTO TABLE tbl_name
FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"' ESCAPED BY '\\'
所创建的表中的列应与写入日志文件的LogFormat行对应。

第4章：MySQL程序概述
目录
4.1. MySQL程序概述 
4.2. 调用MySQL程序 
4.3. 指定程序选项 
4.3.1. 在命令行上使用选项 
4.3.2. 使用选项文件 
4.3.3. 用环境变量指定选项 
4.3.4. 使用选项设置程序变量
本章简要概述了MySQL AB提供的命令行程序，并讨论了运行这些程序时如何指定选项。大多数程序具有其操作专用的选项，但指定选项的语法都近似。后面的几章更加详细地描述了各个程序，包括它们识别的选项。
MySQL AB还提供了3个GUI客户程序供MySQL服务器使用：
·         MySQL管理器：该工具用于管理MySQL服务器、数据库、表以及用户。
·         MySQL查询浏览器：该图形工具由MySQL AB提供，用于创建、执行以及优化对MySQL数据库的查询。
·         MySQL移植工具包：该工具可以帮助你将计划和数据从其它关系数据库管理系统移植到MySQL。
4.1. MySQL程序概述
MySQL AB提供了几种类型的程序：
·         MYSQL服务器和服务器启动脚本：
o        mysqld是MySQL服务器
o        mysqld_safe、mysql.server和mysqld_multi是服务器启动脚本
o        mysql_install_db初始化数据目录和初始数据库
在第5章：数据库管理中详细讨论了这些程序。
·         访问服务器的客户程序：
o        mysql是一个命令行客户程序，用于交互式或以批处理模式执行SQL语句。
o        mysqladmin是用于管理功能的客户程序。
o        mysqlcheck执行表维护操作。
o        mysqldump和mysqlhotcopy负责数据库备份。
o        mysqlimport导入数据文件。  
o        mysqlshow显示信息数据库和表的相关信息。
在第8章：客户端和实用工具程序中详细讨论了这些程序。
·         独立于服务器操作的工具程序：
o        myisamchk执行表维护操作。
o        myisampack产生压缩、只读的表。
o        mysqlbinlog是处理二进制日志文件的实用工具。
o        perror显示错误代码的含义。
在第5章：数据库管理中详细讨论了myisamchk。在第8章：客户端和实用工具程序中详细讨论了其它程序。
大多数MySQL分发包括上述的全部程序，只是不包含那些与平台相关的程序。(例如，在Windows中不使用服务器启动脚本）。不同的只是RPM分发更加具体化。可能一个RPM是服务器分发，另一个RPM是客户程序分发等等。如果你丢失了一个或多个程序，要想查阅关于分发类型和它们所包含内容的信息，参见第2章：安装MySQL。也可能需要安装一些其它内容。
4.2. 调用MySQL程序
要想从命令行调用MySQL程序(即从shell或命令提示)，应输入程序名，并随后输入指导操作发的选项或其它参量。下面的命令显示了一些程序调用的例子。“shell>”表示命令解释符提示；并不是输入的部分。你所看见的具体提示取决于命令解释符。典型提示符：sh或bash为$，csh或tcsh为%，Windows command.com或cmd.exe为C:\>。
shell> mysql test
shell> mysqladmin extended-status variables
shell> mysqlshow --help
shell> mysqldump --user=root personnel
以破折号开始的参数为选项参量。它们通常指定程序与服务器的连接类型或影响其操作模式。关于选项语法的描述参见4.3节，“指定程序选项”。
非选项参数(不以破折号开始的参量)可以为程序提供更详细的信息。例如，mysql程序将第一个非选项参量解释为数据库名，因此命令 mysql test表示你想要使用test数据库。
后面的章节描述了具体的程序，表示程序可以理解的选项，并描述了其它非选项参量的含义。
部分选项对部分程序是通用的。最常用的是指定连接参数的--host、--user和--password选项。它们指示MySQL服务器运行的主机和MySQL账户的用户名和 密码。所有MySQL客户程序可以理解这些选项；它们允许你指定连接哪个服务器，以及在该服务器上使用的 账户。
你也许会发现需要使用MySQL程序安装的bin目录的路径名来调用MySQL程序。如果你试图不在bin目录下运行MySQL程序，可能会遇到“程序未找到”错误。为了更方便地使用MySQL，可以将bin目录的路径名添加到PATH环境变量中。然后运行程序时只需要输入程序名，而不需要输入整个路径名。
关于设置PATH的指令的命令解释符请查阅相关文档。设置环境变量的语法与解释符有关。
4.3. 指定程序选项
4.3.1. 在命令行上使用选项 
4.3.2. 使用选项文件 
4.3.3. 用环境变量指定选项 
4.3.4. 使用选项设置程序变量
可以用几种方式提供MySQL程序的选项：
·         在命令行中在程序名后面提供。这对于具体程序调用时使用的选项很普遍。
·         在程序启动时读取的选项文件中设置。这对于每次程序运行时使用的选项很普遍。
·         在环境变量中设置。这对每次程序运行时所使用的选项很有用，尽管实际上最常用选项文件。(5.12.2节，“在Unix中运行多个服务器”中讨论了环境变量会很有帮助的一种情况。描述了使用这些变量来指定服务器和客户程序的TCP/IP端口号和Unix套接字文件的各种技术）。
MySQL程序首先检查环境变量，然后检查选项文件，然后检查命令行来确定给出了哪些选项。如果多次指定一个选项，最后出现的选项占先。这说明环境变量具有最低的优先级，命令行选项具有最高优先级。
可以在选项文件中指定程序选项的默认值来让MySQL程序处理各选项。不需要在每次运行程序时输入选项，但可以根据需要通过命令行选项来覆盖默认值。
4.3.1. 在命令行上使用选项
在命令行中指定的程序选项遵从下述规则：
·         在命令名后面紧跟选项。
·         选项参量以一个和两个破折号开始，取决于它具有短名还是长名。许多选项有两种形式。例如，-?和--help是指导MySQL程序显示帮助消息的选项的短名和长名。
·         选项名对大小写敏感。-v和-V均有效，但具有不同的含义。(它们是--verbose和--version选项的短名）。 
·         部分选项在选项名后面紧随选项值。例如，-h localhost或--host=localhost表示客户程序的MySQL服务器主机。选项值可以告诉程序MySQL服务器运行的主机名。
·         对于带选项值的长选项，通过一个‘=’将选项名和值隔离开来。对于带选项值的短选项，选项值可以紧随选项字母后面，或者二者之间可以用一个空格隔开。(-hlocalhost和-h localhost是等效的）。该规则的例外情况是指定MySQL密码的选项。该选项的形式可以为--password=pass_val或--password。在后一种情况(未给出 密码值)，程序将提示输入密码。也可以给出密码选项，短形式为-ppass_val或-p。然而，对于短形式，如果给出了 密码值，必须紧跟在选项后面，中间不能插入空格。这样要求的原因是如果选项后面有空格，程序没有办法来告知后面的参量是 密码值还是其它某种参量。因此，下面两个命令的含义完全不同：
·                shell> mysql -ptest
·                shell> mysql -p test
第一个命令让mysql使用密码test，但没有指定默认数据库。第二个命令让mysql提示输入 密码并使用test作为默认数据库。
部分选项控制可以开关的行为。例如，mysql客户端支持--column-names选项，确定是否在查询结果开头显示一行栏目名。默认情况，该选项被启用。但是可能在某些情况下你想要禁用它，例如将mysql的输出发送到另一个只希望看到数据而不希望看到开始的标题行的程序中。
要想禁用列名，可以使用下面的形式来指定选项：
--disable-column-names
--skip-column-names
--column-names=0
--disable和--skip前缀与=0后缀的效果相同：它们均关闭选项。
可以用下述方法“启用”选项：
--column-names
--enable-column-names
--column-names=1
如果选项有前缀--loose，如果程序未识别出选项不会提示错误退出，但是会发出一条警告：
shell> mysql --loose-no-such-option
mysql: WARNING: unknown option '--no-such-option'
当你从安装了多个MySQL的同一台机器上运行程序时，--loose前缀会很有用。当你在一个选项文件中列出选项时，该前缀会特别有用。有可能不能被程序的所有版本识别的选项可以冠以--loose前缀(或在选项文件中用loose)。不能识别选项的程序版本将会发出一条警告并忽视该选项。
对mysql偶尔有用的另一个选项是-e或--execute选项，可用来将SQL语句传递给服务器。该语句必须用引号引起来(单引号或双引号)。(然而，如果想要在查询中将值引起来，则对于查询应使用双引号，查询中引用的值应使用单引号）。当使用该选项时，语句被执行，然后mysql立即退出命令外壳。
例如，你可以用下面的命令获得用户账户列表：
shell> mysql -u root -p -e "SELECT User, Host FROM User" mysql
Enter password: ******
+------+-----------+
| User | Host      |
+------+-----------+
|      | gigan     |
| root | gigan     |
|      | localhost |
| jon  | localhost |
| root | localhost |
+------+-----------+
shell>
请注意mysql数据库名作为一个独立的参量传递。然而，相同的查询可能已经使用mysql -u root -p -e "SELECT User，Host FROM mysql.User"从外壳中执行。
可以按这种方式传递多个SQL语句，用分号隔开：
shell> mysql -u root -p --execute="SELECT Name FROM Country WHERE Name LIKE 'AU%';SELECT COUNT(*) FROM City" world
Enter password: ******
+-----------+
| Name      |
+-----------+
| Australia |
| Austria   |
+-----------+
+----------+
| COUNT(*) |
+----------+
|     4079 |
+----------+
请注意长形式(--execute)后面必须紧跟一个等号(=)。
-e选项也可以以类似方式用来将命令传递给MySQL簇的ndb_mgm管理客户端。相关例子参见17.3.6节，“安全关闭和重启”。
4.3.2. 使用选项文件
MySQL程序可以从选项文件(有时也称为配置文件)读取启动选项。选项文件提供了一种很方便的方式来指定常用的选项，因此不需要每次运行程序时从命令行输入。
下面的程序支持选项文件：myisamchk、myisampack、mysql、mysql.server、mysqladmin、mysqlbinlog、mysqlcc、mysqlcheck、mysqld_safe、mysqldump、mysqld、mysqlhotcopy、mysqlimport和mysqlshow。
注释：MySQL簇程序使用的选项文件参见17.4节，“MySQL簇的配置”。
在Windows中，MySQL程序从以下文件读取启动选项：
文件名
目的
WINDIR\my.ini
全局选项
C:\my.cnf
全局选项
INSTALLDIR\my.ini
全局选项
defaults-extra-file
用--defaults-extra-file=path指定的文件，如果有
WINDIR表示Windows目录的位置。通常为C:\WINDOWS或C:\WINNT。你可以使用下面的命令通过环境变量WINDIR的值确定其确切位置：
C:\> echo %WINDIR%
INSTALLDIR表示MySQL的安装目录。一般为C:\PROGRAMDIR\MySQL\MySQL 5.1 Server，其中PROGRAMDIR表示程序目录(通常为Windows英文版的Program Files)，MySQL 5.1的安装是根据安装和配置向导完成的。参见2.3.5.14节，“my.ini文件的位置”。
在Unix中，MySQL程序从下面的文件读取启动选项：
文件名
目的
/etc/my.cnf
全局选项
$MYSQL_HOME/my.cnf
服务器相关选项
defaults-extra-file
用--defaults-extra-file=path指定的文件，如果有
~/.my.cnf
用户相关选项
MYSQL_HOME是一个环境变量，包含服务器相关的my.cnf文件驻留的目录路径。
如果未设置MYSQL_HOME，并且DATADIR中有一个my.cnf文件，BASEDIR中没有my.cnf文件，mysqld_safe将MYSQL_HOME设置为DATADIR。否则，如果未设置MYSQL_HOME并且在DATADIR中没有my.cnf，则mysqld_safe将MYSQL_HOME设置为BASEDIR。
典型情况二进制安装的目录为/usr/local/mysql/data或源代码安装的目录为/usr/local/var。请注意这是配置时指定的数据目录的位置，而不是 mysqld启动时用--datadir指定的。运行时使用--datadir对寻找选项文件的服务器没有效果，因为服务器在处理命令行参量之前寻找这些选项。
MySQL按照上述顺序寻找选项文件，并读存在的选项文件。如果你想要使用的某个选项文件不存在，则用明文文本编辑器创建。如果存在多个选项文件，文件中指定的后读取的选项要优先文件中指定的先读取的选项。
注释：在Unix平台上，MySQL忽略人人可写的配置文件。这是故意的，是一个安全措施。
任何可以在运行MySQL程序时在命令行给出的长选项也可以在选项文件中给出。要想列出程序的适用选项，用--help选项运行程序。
在选项文件中指定选项的语法类似于命令行语法，例外的是要忽略掉两个破折号。例如，命令行中的--quick或--host=localhost在选项文件中应指定为quick或host=localhost。要想在选项文件中指定--loose-opt_name形式的选项，应写为loose-opt_name。
选项文件中的空行被忽略掉。非空行可以采用下面任何形式：
·         #注释，；注释
注释行以‘#’或‘；’开头。‘#’注释也可以从行的中部开始。
·         [group]
group是你想要设置选项的程序名或组名。在组行后面，任何opt_name或set-variable行适用于组名，直到选项文件结尾或给出其它组行。
·         opt_name
等价于命令行中的--opt_name。
·         opt_name=value
等价于命令行中的--opt_name=value。在选项文件中，‘=’字符附近可以有空格，而在命令行中是不允许的。你可以用单引号或双引号来引用值。如果值包含一个‘#’注释字符或空格时很有用。
选项名和值前后的空白将自动删除掉。你可以在选项值中使用转义序列‘\b’、‘\t’、‘\n’、‘\r’、‘\\’以及‘\s’来表示退格、tab、换行符、回车以及空格字符。
在Windows中，如果某个选项值表示一个路径名，应使用‘/’而不是‘\’作为路径名间隔符来指定值。如果使用‘\’，必须用双斜线‘\\’，因为‘\’在MySQL中为转义字符。
如果选项组名与程序名相同，则组内的选项专用于该程序。
所有客户程序(但不能被mysqld)读取[client]选项组。这样允许你指定适用于所有客户端的选项。例如，[client]是用于指定连接服务器的 密码的理想的组。(但应确保该选项文件只能由你自己读写，以便其他人不能发现你的密码）。一定不要随意在[client]组内放置选项，除非它可以被你使用的所有客户程序识别。如果你试图运行程序，如果程序不理解选项则会显示一条错误消息后退出。
从5.0系列的MySQL 5.0.4开始，可以在选项文件中使用!include指令来包括具体文件和!includedir来搜索选项文件的具体目录。例如，要包括文件/home/mydir/myopt.cnf，可以使用：
!include /home/me/myopt.cnf
要搜索所有以.cnf结尾的文件的目录/home/mydir并作为选项文件读取，应使用：
!includedir /home/mydir
请注意这些选项与节有关。例如，假定你想要使用my.cnf中的某些内容，如下所示：
[mysqld]
!include /home/mydir/myopt.cnf
在这种情况下，只为该服务器处理文件myopt.cnf，并且!include指令将被客户应用程序忽略。然而，如果你使用下面的部分：
[mysqldump]
!includedir /home/mydir/my-dump-option
则只有mysqldump为以.cnf结尾的文件检查目录/home/mydir/my-dump-option，服务器或其它客户应用程序均不检查。
注释：目前，在Unix操作系统中，所发现的使用!includedir指令包括的文件的文件名必须以.cnf为扩展名。在Windows中，该指令也为有.ini扩展名(包括.cnf)的文件做检查。
如果你想要创建只由一个具体mysqld服务器发布系列读取的选项组，选项组可以用[mysqld-5.0]、[mysqld-5.1]等名称。下面的组表示--new选项只能用于5.1.x 版本的MySQL服务器：
[mysqld-5.1]
new
下面是一个典型的全局选项文件：
[client]
port=3306
socket=/tmp/mysql.sock
 
[mysqld]
port=3306
socket=/tmp/mysql.sock
key_buffer_size=16M
max_allowed_packet=8M
 
[mysqldump]
quick
在上述的选项文件中，设置key_buffer_size和max_allowed_packet变量的行使用了var_name=value语法。
下面是一个典型的用户选项文件：
[client]
# The following password will be sent to all standard MySQL clients
password="my_password"
 
[mysql]
no-auto-rehash
connect_timeout=2
 
[mysqlhotcopy]
interactive-timeout
 
如果你有一个源代码分发，可以从support-file目录中找到名为my-xxxx.cnf的示例选项文件。如果你有一个二进制分发，在MySQL安装目录的support-file目录中查找。在Windows中，示例选项文件也可以位于MySQL的安装目录(如果你不知道在哪里，查阅本节前面或第2章：安装MySQL)。目前有小、中等、大以及非常大的系统的示例选项文件。要想练习这些文件，在Windows中复制到C:\my.cnf或在Unix中复制到根目录的.my.cnf。
注释：在Windows中，可以不显示.cnf选项文件的扩展名。
所有支持选项文件的MySQL程序可以处理下面的命令行选项：
·         --no-defaults
不读取任何选项文件。
·         --print-defaults
打印从选项文件中获得的程序名和所有选项。
·         --defaults-file=path_name
只使用给出的选项文件。path_name是文件的全路径名。
·         --defaults-extra-file=path_name
在全局选项文件后但在用户选项文件前读该选项文件。path_name是文件的全路径名。
为了正确工作，每个选项必须紧随命令行中的命令名后，例外情况是--print-defaults可以紧随--defaults-file或--defaults-extra-file。
在shell脚本中，可以使用my_print_defaults程序来分析选项文件。下面的例子显示了当要求显示[client]和[mysql]组内发现的选项时my_print_defaults产生的输出：
shell> my_print_defaults client mysql
--port=3306
--socket=/tmp/mysql.sock
--no-auto-rehash
开发人员请注意：在C客户程序库中，只是通过处理命令行参量前面的所有匹配选项(即相应组内的选项)来处理选项文件。对于使用多次指定的最后的选项实例的程序，可以很好地工作。如果你有一个C或C++程序按这种方式处理多次指定的选项，但不读取选项文件，只需要添加两行来实现该功能。检查标准MySQL客户程序的源代码来看看如何做。
其它几个MySQL语言接口基于C客户库，它们中的一部分提供了访问选项文件的一种方式。包括Perl和Python。关于接口的详细信息参见相关文档。
4.3.3. 用环境变量指定选项
要想用环境变量指定选项，使用适用注释处理器的语法来设置变量。例如，在Windows或NetWare中，可以设置USER变量来指定MySQL账户名。要想实现，使用语法：
SET USER=your_name
在Unix中的语法取决于你的外壳。假定你想要使用MYSQL_TCP_PORT变量指定TCP/IP端口号。典型的语法为(例如sh、bash、zsh等等)：
MYSQL_TCP_PORT=3306
export MYSQL_TCP_PORT
第1个命令设置变量，export命令将变量导出到外壳环境，以便其值可供MySQL和其它进程访问。
csh和tcsh有类似的问题。运行这些外壳时，使用setenv使外壳变量适用环境：
setenv MYSQL_TCP_PORT 3306
可以在命令提示符下执行设置环境变量的命令，以便立即生效。这些设定值持续到你注销。要向让这些设定值在你每次登录时生效，将相应命令放入每次启动时命令解释符所读的启动文件中。在Windows中典型启动文件为AUTOEXEC.BAT，bash为.bash_profile，或者tcsh为.tcshrc。关于命令解释符的具体细节请查阅文档。
附录F：环境变量 了列出影响MySQL程序操作的所有环境变量。
4.3.4. 使用选项设置程序变量
许多MySQL程序有一些内部变量可以在运行时设置。程序变量的设置与带有值的其它长选项相同。例如，mysql有一个max_allowed_packet变量，可以控制其通信缓冲区的最大长度。要想为mysql将max_allowed_packet变量的值设置为16MB，使用下面的任何一个命令：
shell> mysql --max_allowed_packet=16777216
shell> mysql --max_allowed_packet=16M
第1个命令以字节指定值。第2个命令以兆字节指定值。变量值可以有一个后缀K、M或者G(可以为大写或小写)来表示千字节、兆字节或者十亿字节的单位。
在选项文件中，变量设定值没有引导破折号：
[mysql]
max_allowed_packet=16777216
或：
[mysql]
max_allowed_packet=16M
如果你喜欢，变量名的下划线可以为破折号。
注释：MySQL 5.1仍然能识别旧的语法--set-variable = option=value，但现在不赞成使用。
部分服务器变量可以在运行时设置。详情参见5.3.3.1节，“动态系统变量”。

第5章：数据库管理
目录
5.1. MySQL服务器和服务器启动脚本 
5.1.1. 服务器端脚本和实用工具概述 
5.1.2. mysqld-max扩展MySQL服务器 
5.1.3. mysqld_safe：MySQL服务器启动脚本 
5.1.4. mysql.server：MySQL服务器启动脚本 
5.1.5. mysqld_multi：管理多个MySQL服务器的程序
5.2. mysqlmanager：MySQL实例管理器 
5.2.1. 用MySQL实例管理器启动MySQL服务器 
5.2.2. 连接到MySQL实例管理器并创建用户账户 
5.2.3. MySQL实例管理器命令行选项 
5.2.4. MySQL实例管理器配置文件 
5.2.5. MySQL实例管理器识别的命令
5.3. mysqld：MySQL服务器 
5.3.1. mysqld命令行选项 
5.3.2. SQL服务器模式 
5.3.3. 服务器系统变量 
5.3.4. 服务器状态变量
5.4. mysql_fix_privilege_tables：升级MySQL系统表 
5.5. MySQL服务器关机进程 
5.6. 一般安全问题 
5.6.1. 通用安全指南 
5.6.2. 使MySQL在攻击者面前保持安全 
5.6.3. Mysqld安全相关启动选项 
5.6.4. LOAD DATA LOCAL安全问题
5.7. MySQL访问权限系统 
5.7.1. 权限系统的作用 
5.7.2. 权限系统工作原理 
5.7.3. MySQL提供的权限 
5.7.4. 与MySQL服务器连接 
5.7.5. 访问控制, 阶段1：连接核实 
5.7.6. 访问控制, 阶段2：请求核实 
5.7.7. 权限更改何时生效 
5.7.8. 拒绝访问错误的原因 
5.7.9. MySQL 4.1中的密码哈希处理
5.8. MySQL用户账户管理 
5.8.1. MySQL用户名和密码 
5.8.2. 向MySQL增加新用户账户 
5.8.3. 从MySQL删除用户账户 
5.8.4. 限制账户资源 
5.8.5. 设置账户密码 
5.8.6. 使你的密码安全 
5.8.7. 使用安全连接
5.9. 备份与恢复 
5.9.1. 数据库备份 
5.9.2. 示例用备份与恢复策略 
5.9.3. 自动恢复 
5.9.4. 表维护和崩溃恢复 
5.9.5. myisamchk：MyISAM表维护实用工具 
5.9.6. 建立表维护计划 
5.9.7. 获取关于表的信息
5.10. MySQL本地化和国际应用 
5.10.1. 数据和排序用字符集 
5.10.2. 设置错误消息语言 
5.10.3. 添加新的字符集 
5.10.4. 字符定义数组 
5.10.5. 字符串比较支持 
5.10.6. 多字节字符支持 
5.10.7. 字符集问题 
5.10.8. MySQL服务器时区支持
5.11. MySQL日志文件 
5.11.1. 错误日志 
5.11.2. 通用查询日志 
5.11.3. 二进制日志 
5.11.4. 慢速查询日志 
5.11.5. 日志文件维护
5.12. 在同一台机器上运行多个MySQL服务器 
5.12.1. 在Windows下运行多个服务器 
5.12.2. 在Unix中运行多个服务器 
5.12.3. 在多服务器环境中使用客户端程序
5.13. MySQL查询高速缓冲 
5.13.1. 查询高速缓冲如何工作 
5.13.2. 查询高速缓冲SELECT选项 
5.13.3. 查询高速缓冲配置 
5.13.4. 查询高速缓冲状态和维护
本章涵盖了MySQL安装管理主题，例如配置服务器、管理用户账户和备份。
5.1. MySQL服务器和服务器启动脚本
5.1.1. 服务器端脚本和实用工具概述 
5.1.2. mysqld-max扩展MySQL服务器 
5.1.3. mysqld_safe：MySQL服务器启动脚本 
5.1.4. mysql.server：MySQL服务器启动脚本 
5.1.5. mysqld_multi：管理多个MySQL服务器的程序
MySQL服务器，即mysqld，是在MySQL安装中负责大部分工作的主程序。服务器随附了几个相关脚本，当你安装MySQL时它们可以执行设置操作，或者是帮助你启动和停止服务器的帮助程序。
本节提供了服务器和相关程序的概述，以及服务器启动脚本相关信息。关于配置服务器的信息参见5.3节，“mysqld：MySQL服务器”。
5.1.1. 服务器端脚本和实用工具概述
MySQL程序采用各种不同的选项。但每个MySQL程序提供一个--help选项,你可以用来查阅程序选项相关说明。例如，你可以试试mysqld --help。
你可以在命令行中或在选项文件中指定选项来替换所有标准程序中的默认选项。参见4.3节，“指定程序选项”。
下面简单描述了MySQL服务器和服务器相关程序：
·         mysqld
SQL后台程序(即MySQL服务器)。要想使用客户端程序，该程序必须运行，因为客户端通过连接服务器来访问数据库。参见5.3节，“mysqld：MySQL服务器”。
·         mysqld-max
包括更多特性的一个服务器版本。参见5.1.2节，“mysqld-max扩展MySQL服务器”
·         mysqld_safe
服务器启动脚本。如果mysqld-max存在,mysqld_safe试图启动它，否则启动mysqld。参见5.1.3节，“mysqld_safe：MySQL服务器启动脚本”。
·         mysql.server
服务器启动脚本。该脚本用于使用包含为特定级别的运行启动服务的脚本的运行目录的系统。它调用mysqld_safe来启动MySQL服务器。参见5.1.4节，“mysql.server：MySQL服务器启动脚本”。
·         mysqld_multi
服务器启动脚本，可以启动或停止系统上安装的多个服务器。参见5.1.5节，“mysqld_multi：管理多个MySQL服务器的程序”
·         mysql_install_db
该脚本用默认权限创建MySQL授权表。通常只是在系统上首次安装MySQL时执行一次。参见2.9.2节，“Unix下安装后的过程”。
·         mysql_fix_ privilege_tables
在升级安装后，如果新版本MySQL中的 授权表有更改，则使用该脚本来更改授权表。参见2.10.2节，“升级授权表”。
服务器主机上还运行其它几个程序：
·         myisamchk
用来描述、检查、优化和维护MyISAM表的实用工具。在5.9.5节，“myisamchk：MyISAM表维护实用工具”中描述了myisamchk。
·         make_binary_distribution
该程序可以生成编译过的MySQL的二进制版本。可以通过FTP上传到ftp.mysql.com的/pub/mysql/upload/，供其它MySQL用户使用。
·         mysqlbug
MySQL 缺陷报告脚本。它可以用来向MySQL邮件系统发送缺陷报告。(你也可以访问http://bugs.mysql.com/在线创建缺陷报告文件。参见1.7.1.3节，“如何通报缺陷和问题”）。 
5.1.2. mysqld-max扩展MySQL服务器
MySQL-Max服务器是mysqld MySQL服务器的一个版本，包含了更多的特性。
该分发版的使用取决于你的平台：
·         对于Windows，MySQL二进制分发版包括标准服务器 (mysqld.exe)和MySQL-Max服务器(mysqld-max.exe)，因此你不再需要专用分发版。只需要使用一个常规Windows分发版，可以从http://dev.mysql.com/downloads/获得。参见2.3节，“在Windows上安装MySQL”。
·         对于Linux，如果你使用RPM分发版安装MySQL，首先使用常规MySQL-server RPM来安装标准mysqld服务器。然后使用MySQL-Max RPM来安装mysqld-max服务器。MySQL-Max RPM假定你已经安装了常规服务器RPM。关于Linux RPM软件包的详细信息，参见2.4节，“在Linux下安装MySQL”。
·         所有其它MySQL-Max分发版包含一个mysqld服务器，但具有更多的特性。
你可以从MySQL AB网址http://dev.mysql.com/downloads/找到MySQL-Max二进制版本。
MySQL AB使用下面的configure选项构建MySQL-Max服务器：
·         --with-server-suffix=-max
该选项为mysqld版本字符串添加一个-max后缀。
·         --with-innodb
该选项启用InnoDB存储引擎支持。MySQL-Max服务器包括InnoDB支持。在MySQL 4.0及以上版本中，默认InnoDB包括在所有二进制分发版中，因此你不需要用MySQL-Max服务器只是用来获取InnoDB支持。
·         --with-bdb
该选项启用Berkeley DB (BDB)存储引擎支持。
·         --with-blackhole-storage-engine
该选项启用BLACKHOLE存储引擎支持。
·         USE_SYMDIR
启用该定义来为Windows打开数据库符号链接支持。符号链接支持适用于所有Windows服务器，因此Max服务器不需要支持该特性。
·         --with-ndbcluster
该选项启用NDB Cluster存储引擎支持。目前(5.1.2-alpha)只有Linux、Solaris和Mac OS X支持Cluster。已有一些用户报告在BSD 操作系统上成功使用了从源码构建的MySQL Cluster，但目前还没有得到官方支持。
MySQL-Max二进制分发版对于想要安装预编译程序的用户很方便。如果你使用源码分发版构建MySQL，你可以通过在配置时启用MySQL-Max二进制分发版构建所用的相同的特性来构建你自己的Max-like服务器。
MySQL-Max服务器包括BerkeleyDB (BDB)存储引擎，但并非所有平台支持BDB。
Solaris、Mac OS X和Linux(在大多数平台上)的MySQL-Max服务器包括NDB CLUSTER存储引擎支持。请注意必须用ndbcluster选项启动服务器，以便使服务器做为MySQL Cluster的一部分来运行。(详细信息参见17.4节，“MySQL簇的配置”）。 
下面的表显示了MySQL-Max二进制在哪个平台上包括BDB和/或NDB CLUSTER支持：
系统
BDB支持
NDB支持
AIX 4.3
N
N
HP-UX 11.0
N
N
Linux-Alpha
N
Y
Linux-IA-64
N
N
Linux-Intel
Y
Y
Mac OS X
N
N
NetWare
N
N
SCO OSR5
Y
N
Solaris-SPARC
Y
Y
Solaris-Intel
N
Y
UnixWare
Y
N
Windows NT/2000/XP
Y
N
要想找出你的服务器支持哪个存储引擎，执行下面的语句：
mysql> SHOW ENGINES;
+------------+---------+----------------------------------------------------------------+
| Engine     | Support | Comment                                                        |
+------------+---------+----------------------------------------------------------------+
| MyISAM     | DEFAULT | Default engine as of MySQL 3.23 with great performance         |
| MEMORY     | YES     | Hash based, stored in memory, useful for temporary tables      |
| HEAP       | YES     | Alias for MEMORY                                               |
| MERGE      | YES     | Collection of identical MyISAM tables                          |
| MRG_MYISAM | YES     | Alias for MERGE                                                |
| ISAM       | NO      | Obsolete storage engine, now replaced by MyISAM                |
| MRG_ISAM   | NO      | Obsolete storage engine, now replaced by MERGE                 |
| InnoDB     | YES     | Supports transactions, row-level locking, and foreign keys     |
| INNOBASE   | YES     | Alias for INNODB                                               |
| BDB        | YES     | Supports transactions and page-level locking                   |
| BERKELEYDB | YES     | Alias for BDB                                                  |
| NDBCLUSTER | NO      | Clustered, fault-tolerant, memory-based tables                 |
| NDB        | NO      | Alias for NDBCLUSTER                                           |
| EXAMPLE    | NO      | Example storage engine                                         |
| ARCHIVE    | YES     | Archive storage engine                                         |
| CSV        | NO      | CSV storage engine                                             |
| FEDERATED  | YES     | Federated MySQL storage engine                                 |
| BLACKHOLE  | YES     | /dev/null storage engine (anything you write to it disappears) |
+------------+---------+----------------------------------------------------------------+
18 rows in set (0.00 sec)
(另参见13.5.4.8节，“SHOW ENGINES语法”）。 
你还可以使用下面的语句代替SHOW ENGINES，并检查你感兴趣的存储引擎的变量值：
mysql> SHOW VARIABLES LIKE 'have%';
+-----------------------+----------+
| Variable_name         | Value    |
+-----------------------+----------+
| have_archive          | YES      |
| have_bdb              | NO       |
| have_blackhole_engine | YES      |
| have_compress         | YES      |
| have_crypt            | YES      |
| have_csv              | YES      |
| have_example_engine   | NO       |
| have_federated_engine | NO       |
| have_geometry         | YES      |
| have_innodb           | YES      |
| have_isam             | NO       |
| have_ndbcluster       | DISABLED |
| have_openssl          | NO       |
| have_partition_engine | YES      |
| have_query_cache      | YES      |
| have_raid             | NO       |
| have_rtree_keys       | YES      |
| have_symlink          | YES      |
+-----------------------+----------+
18 rows in set (0.01 sec)
SHOW命令的精确输出随使用的MySQL版本(和启用的特性)的不同而有变化。第2列的值表示各特性支持的服务器级别，如下所示：
值
含义
YES
 支持该特性并已经激活。
NO
 不支持该特性。
DISABLED
 支持该特性但被禁用。
NO值表示编译的服务器不支持该特性，因此在运行时不能激活。
出现DISABLED值是因为服务器启动时该特性被禁用，或没有给出启用它的所有选项。在后一种情况，host_名.err错误日志文件应包含该选项被禁用的原因。
如果服务器支持InnoDB或BDB存储引擎，你还可以看见DISABLED，但在运行启动时使用了--skip-innodb或--skip-bdb选项。对于NDB CLUSTER存储引擎，DISABLED表示服务器支持MySQL Cluster，但启动时未启用--ndb-cluster选项。
所有MySQL服务器支持MyISAM表，因为MyISAM是 默认存储引擎。
5.1.3. mysqld_safe：MySQL服务器启动脚本
在Unix和NetWare中推荐使用mysqld_safe来启动mysqld服务器。mysqld_safe增加了一些安全特性，例如当出现错误时重启服务器并向错误日志文件写入运行时间信息。本节后面列出了NetWare的特定行为。
注释：为了保持同旧版本MySQL的向后兼容性，MySQL二进制分发版仍然包括safe_mysqld作为mysqld_safe的符号链接。但是，你不应再依赖它，因为再将来将删掉它。
默认情况下，mysqld_safe尝试启动可执行mysqld-max（如果存在），否则启动mysqld。该行为的含义是：
·         在Linux中，MySQL-Max RPM依赖该mysqld_safe的行为。RPM安装可执行mysqld-max，使mysqld_safe从该点起自动使用可执行命令。
·         如果你安装包括mysqld-max服务器的MySQL-Max分发版，后面升级到非-Max的MySQL版本，mysqld_safe仍然试图运行旧的 mysqld-max服务器。升级时，你应手动删除旧的mysqld-max服务器以确保mysqld_safe运行新的mysqld服务器。
要想越过默认行为并显式指定你想要运行哪个服务器，为mysqld_safe指定--mysqld或--mysqld-version选项。
mysqld_safe的许多选项与mysqld的相同的。参见5.3.1节，“mysqld命令行选项”。
所有在命令行中为mysqld_safe指定的选项被传递给mysqld。如果你想要使用mysqld不支持的mysqld_safe的选项，不要在命令行中指定。相反，在选项文件的[mysqld_safe]组内将它们列出来。参见4.3.2节，“使用选项文件”。
mysqld_safe从选项文件的[mysqld]、[server]和[mysqld_safe]部分读取所有选项。为了保证向后兼容性，它还读取 [safe_mysqld]部分，尽管在MySQL 5.1安装中你应将这部分重新命名为[mysqld_safe]。
mysqld_safe支持下面的选项：
·         --help
显示帮助消息并退出。
·         --autoclose
(只在NetWare中)在NetWare中，mysqld_safe可以保持窗口。当你关掉mysqld_safe NLM时，窗口不按默认设置消失。相反，它提示用户输入：
*<NLM has terminated; Press any key to close the screen>*
如果你想让NetWare自动关闭窗口，在mysqld_safe中使用--autoclose选项。
·         --basedir=path
MySQL安装目录的路径。
·         --core-file-size=size
mysqld能够创建的内核文件的大小。选项值传递给ulimit -c。
·         --datadir=path
数据目录的路径。
·           --defaults-extra-file=path
除了通用选项文件所读取的选项文件名。如果给出，必须首选该选项。
·         --defaults-file=path
读取的代替通用选项文件的选项文件名。如果给出，必须首选该选项。
·         --ledir=path
包含mysqld程序的目录的路径。使用该选项来显式表示服务器位置。
·         --log-error=path
将错误日志写入给定的文件。参见5.11.1节，“错误日志”。
·         --mysqld=prog_name
想要启动的服务器程序名(在ledir目录)。如果你使用MySQL二进制分发版但有二进制分发版之外的数据目录需要该选项。
·         --mysqld-version =suffix
该选项类似--mysqld选项，但你只指定服务器程序名的后缀。基本名假定为mysqld。例如，如果你使用--mysqld-version =max，mysqld_safe启动ledir目录中的mysqld-max程序。如果--mysqld-version的参数为空，mysqld_safe使用目录中的mysqld。
·         --nice=priority
使用nice程序根据给定值来设置服务器的调度优先级。
·         --no-defaults
不要读任何选项文件。如果给出，必须首选该选项。
·         --open-files-limit=count
mysqld能够打开的文件的数量。选项值传递给 ulimit -n。请注意你需要用root启动mysqld_safe来保证正确工作！
·         --pid-file=path
进程ID文件的路径。
·         --port=port_num
 用来帧听TCP/IP连接的端口号。端口号必须为1024或更大值，除非MySQL以root系统用户运行。
·         --skip-character-set-client-handshake
忽略客户端发送的字符集信息，使用服务器的默认字符集。(选择该选项，MySQL的动作与MySQL 4.0相同）。 
·         --socket=path
用于本地连接的Unix套接字文件。
·         --timezone=zone
为给定的选项值设置TZ时区环境变量。从操作系统文档查阅合法的时区规定格式。
·         --user={user_name | user_id}
以用户名user_name或数字用户ID user_id运行mysqld服务器。(本文中的“用户”指系统登录账户，而不是 授权表中的MySQL用户）。 
执行mysqld_safe时，必须先给出--defaults-file或--defaults-extra-option，或不使用选项文件。例如，该命令将不使用选项文件：
mysqld_safe --port=port_num --defaults-file=file_name
相反，使用下面的命令：
mysqld_safe --defaults-file=file_name --port=port_num
一般情况mysqld_safe脚本可以启动从源码或二进制MySQL分发版安装的服务器，即使这些分发版将服务器安装到稍微不同的位置。(参见2.1.5节，“安装布局”）。 mysqld_safe期望下面的其中一个条件是真的：
·         可以根据调用mysqld_safe的目录找到服务器和数据库。在二进制分发版中，mysqld_safe看上去在bin和data目录的工作目录下。对于源码分发版，为libexec和var目录。如果你从MySQL安装目录执行mysqld_safe应满足该条件(例如，二进制分发版为/usr/local/mysql)。
·         如果不能根据工作目录找到服务器和数据库，mysqld_safe试图通过绝对路径对它们定位。典型位置为/usr/local/libexec和/usr/local/var。实际位置由构建分发版时配置的值确定如果MySQL安装到配置时指定的位置，它们应该是正确的。
因为mysqld_safe试图通过工作目录找到服务器和数据库，只要你从MySQL安装目录运行mysqld_safe，可以将MySQL二进制分发版安装到其它位置：
shell> cd mysql_installation_directory
shell> bin/mysqld_safe &
如果mysqld_safe失败，即使从MySQL安装目录调用仍然失败，你可以指定--ledir和--datadir选项来指示服务器和数据库在你的系统中的安装目录。
一般情况，你不应编辑mysqld_safe脚本。相反，应使用命令行选项或my.cnf选项文件的[mysqld_safe]部分的选项来配置mysqld_safe。一般不需要编辑mysqld_safe来正确启动服务器。但是，如果你编辑，将来升级MySQL后会覆盖你修改的mysqld_safe版本，因此你应对你修改的版本进行备份以便将来重装。
在NetWare中，mysqld_safe是一个NetWare Loadable Module (NLM)，从原Unix shell脚本移植。它执行：
1.    检查系统和选项。
2.    检查MyISAM表。
3.    保持MySQL服务器窗口。
4.    启动并监视mysqld，如果因错误终止则重启。
5.    将mysqld的错误消息发送到数据目录中的host_name.err 文件。
6.    将mysqld_safe的屏幕输出发送到数据目录中的host_name.safe文件。
5.1.4. mysql.server：MySQL服务器启动脚本
在Unix中的MySQL分发版包括mysql.server脚本。它可以用于使用System V-style运行目录来启动和停止系统服务的系统，例如Linux和Solaris。它还用于MySQL的Mac OS X Startup Item。
mysql.server位于MySQL源码树MySQL安装目录下的support-files目录中。
如果你使用Linux 服务器RPM软件包(MySQL-server-VERSION.rpm)，mysql.server脚本将安装到/etc/init.d目录下，名为mysql。你不需要 手动安装。关于Linux RPM软件包的详细信息参见2.4节，“在Linux下安装MySQL”。
一些卖方提供的RPM软件包安装的启动脚本用其它名，例如mysqld。
如果你从不自动安装mysql.server的源码分发版或二进制分发版格式安装MySQL，也可以手动安装。相关说明参见2.9.2.2节，“自动启动和停止MySQL”。
mysql.server从 [mysql.server]和选项文件的[mysqld]部分读取选项。(为了保证向后兼容性，它还读取 [safe_mysqld]部分，尽管在MySQL 5.1安装中你应将这部分重新命名为[mysqld_safe]）。
5.1.5. mysqld_multi：管理多个MySQL服务器的程序
mysqld_multi可以管理多个帧听不同Unix套接字文件和TCP/IP端口的连接的mysqld 进程。它可以启动或停止服务器，或报告它们的当前状态。
程序寻找my.cnf中的[mysqldN]组(或--config-file选项指定的文件)。N 可以为任何正整数。在下面的讨论中该数字指选项组号，或GNR。组号区别各选项组，并用作mysqld_multi的参数来指定想要启动、停止哪个服务器或获取哪个服务器的状态报告。这些组中的选项与将用来启动mysqld的[mysqld]组中的相同。(例如，参见2.9.2.2节，“自动启动和停止MySQL”）。但是，当使用多个服务器时，需要每个服务器使用自己的选项值，例如Unix套接字文件和TCP/IP端口号。关于在多服务器环境中，每个服务器对应唯一选项的详细信息，参见5.12节，“在同一台机器上运行多个MySQL服务器”。
要想调用mysqld_multi，使用下面的语法：
shell> mysqld_multi [options] {start|stop|report} [GNR[,GNR] ...]
start、stop和report表示你想要执行的操作。你可以在单个服务器或多个服务器上执行指定的操作，取决于选项名后面的GNR 列。如果没有该列，mysqld_multi为选项文件中的所有服务器执行该操作。
每个GNR值代表一个选项组号或组号范围。GNR值应为选项文件中组名末尾的号。例如，组[mysqld17]的GNR为17。要想指定组号的范围，用破折号间隔开第1个和最后1个号。GNR值10-13代表组[mysqld10]到[mysqld13]。可以在命令行中指定多个组或组范围，用逗号间隔开。GNR列不能有空格字符(空格或tab)；空格字符后面的内容将被忽略掉。
该命令使用选项组[mysqld17]启动单个服务器：
shell> mysqld_multi start 17
该命令停止多个服务器，使用选项组[mysql8]和[mysqld10]至[mysqld13]：
shell> mysqld_multi stop 8,10-13
使用该命令列出设置选项文件的示例：
shell> mysqld_multi --example
mysqld_multi支持下面的选项：
·         --config-file=name
指定选项文件名。这关系到mysqld_multi从哪里寻找[mysqldN]选项组。没有该选项，从通用my.cnf文件读所有选项。选项不影响 mysqld_multi从哪里读取自己的选项，总是从通用my.cnf文件的[mysqld_multi]组读取。
·         --example
显示示例选项文件。
·         --help
显示帮助消息并退出。
·         --log=name
指定日志文件名。如果该文件存在，后面为日志输出。
·         --mysqladmin=prog_name
用来停止服务器的mysqladmin二进制。
·         --mysqld=prog_name
可用的mysqld二进制。请注意你还可以将该选项的值指定为mysqld_safe。选项被传递给 mysqld。确保在PATH环境变量设定值或mysqld_safe中有mysqld所在目录。
·         --no-log
按照标准输出打印日志信息，不要写入日志文件。默认情况下，输出写入日志文件。
·         --password=password
调用mysqladmin时使用的MySQL账户的密码。请注意该密码值不是可选项，不象其它MySQL程序。
·         --silent 
禁用警告。
·         --tcp-ip
通过TCP/IP端口而不是Unix套接字文件来连接每个MySQL服务器。(如果找不到套接字文件， 服务器仍然可以运行，但只能通过 TCP/IP端口访问）。默认情况下，使用Unix套接字文件进行连接。该选项影响stop和report操作。
·         --user=user_name
调用mysqladmin时使用的MySQL账户的用户名。
·         --verbose 
更详细。
·         --version
显示版本信息并退出。
关于mysqld_multi的一些注解：
·         确保停止mysqld服务器(用mysqladmin程序)的MySQL账户在各个服务器中的用户名和密码相同。并且应确保账户具有SHUTDOWN权限。如果你想要管理的服务器的管理账户有许多不同的用户名或密码，你需要在每个服务器上创建一个账户，并具有相同的用户名和密码。例如，你可以执行下面的命令为每个服务器设置一个普通multi_admin账户：
·                shell> mysql -u root -S /tmp/mysql.sock -proot_password
·                mysql> GRANT SHUTDOWN ON *.*
·                    -> TO 'multi_admin'@'localhost' IDENTIFIED BY 'multipass'；
参见5.7.2节，“权限系统工作原理”。你必须为每个mysqld服务器执行该操作。当连接时适当更改连接参数。请注意账户名的主机部分必须允许你用multi_admin从你想要运行mysqld_multi的主机进行连接。
·         如果你使用mysqld_safe来启动mysqld(例如，--mysqld=mysqld_safe)，--pid-file选项很重要。每个mysqld应有自己的进程ID文件。使用mysqld_safe而不使用mysqld的好处是mysqld_safe“守护”其mysqld进程，如果用kill –9发送的信号或由于其它原因（例如分段故障）进程终止，则重启进程。请注意mysqld_safe脚本需要你从某个位置启动它。这说明运行mysqld_multi前你必须进入某个目录。如果启动时有问题，请参见mysqld_safe脚本。特别是要检查下列行：
·                ----------------------------------------------------------------
·                MY_PWD=`pwd`
·                # Check if we are starting this relative (for the binary release)
·                if test -d $MY_PWD/data/mysql -a -f ./share/mysql/english/errmsg.sys -a \
·                -x ./bin/mysqld
·                ----------------------------------------------------------------
参见5.1.3节，“mysqld_safe：MySQL服务器启动脚本”。上述行执行的测试应成功，否则你可能遇到了问题。
·         每个mysqld的Unix套接字文件和TCP/IP端口号必须不同。
·         你可能想要为mysqld使用--user选项，但为此你需要用Unix root用户运行mysqld_multi脚本。选项文件中有选项不要紧；如果你不是超级用户，并且你用自己的Unix账户重启mysqld进程，你只会得到警告。
·         重要：确保mysqld进程启动所用Unix账户可以完全访问数据目录。不要使用Unix root账户，除非你知道你在做什么。
·         非常重要：使用mysqld_multi前，确保理解传递给mysqld服务器的选项的含义以及你为什么想要独立的mysqld进程。应清楚 在相同的数据目录下使用多个mysqld服务器的危险。使用单独的数据目录，除非你知道你在做什么。在线程系统中，在相同的数据目录下启动多个服务器不会得到超性能。参见5.12节，“在同一台机器上运行多个MySQL服务器”。
下面的示例显示了你如何设置选项文件来使用mysqld_multi。专门省去第1个和第5个[mysqldN]组来说明你的选项文件可以稍有不同。这样给你更大的灵活性。mysqld程序重启或停止的顺序由它们在选项文件中的顺序决定。
# This file should probably be in your home dir (~/.my.cnf)
# or /etc/my.cnf
# Version 2.1 by Jani Tolonen
 
[mysqld_multi]
mysqld     = /usr/local/bin/mysqld_safe
mysqladmin = /usr/local/bin/mysqladmin
user       = multi_admin
password   = multipass
 
[mysqld2]
socket     = /tmp/mysql.sock2
port       = 3307
pid-file   = /usr/local/mysql/var2/hostname.pid2
datadir    = /usr/local/mysql/var2
language   = /usr/local/share/mysql/english
user       = john
 
[mysqld3]
socket     = /tmp/mysql.sock3
port       = 3308
pid-file   = /usr/local/mysql/var3/hostname.pid3
datadir    = /usr/local/mysql/var3
language   = /usr/local/share/mysql/swedish
user       = monty
 
[mysqld4]
socket     = /tmp/mysql.sock4
port       = 3309
pid-file   = /usr/local/mysql/var4/hostname.pid4
datadir    = /usr/local/mysql/var4
language   = /usr/local/share/mysql/estonia
user       = tonu
 
[mysqld6]
socket     = /tmp/mysql.sock6
port       = 3311
pid-file   = /usr/local/mysql/var6/hostname.pid6
datadir    = /usr/local/mysql/var6
language   = /usr/local/share/mysql/japanese
user       = jani
参见4.3.2节，“使用选项文件”。
5.2. mysqlmanager：MySQL实例管理器
5.2.1. 用MySQL实例管理器启动MySQL服务器 
5.2.2. 连接到MySQL实例管理器并创建用户账户 
5.2.3. MySQL实例管理器命令行选项 
5.2.4. MySQL实例管理器配置文件 
5.2.5. MySQL实例管理器识别的命令
MySQL实例管理器(IM)是通过TCP/IP端口运行的后台程序，用来监视和管理MySQL数据库服务器实例。MySQL实例管理器 适合Unix-类操作系统和Windows。
可以在mysqld_safe脚本使用MySQL实例管理器来启动和停止MySQL服务器，甚至可以从一个远程主机。MySQL实例管理器还执行mysqld_multi脚本的功能(和大多数语法)。下面为MySQL实例管理器的详细描述。
5.2.1. 用MySQL实例管理器启动MySQL服务器
一般情况，用mysql.server脚本启动MySQL Database Server（MySQL数据库服务器），通常驻留在/etc/init.d/ 文件夹。默认情况下该脚本调用mysqld_safe脚本。但是，你可以在脚本中将use_mysqld_safe变量设置为0(零)以便使用MySQL实例管理器来启动服务器。
在这种情况下，Instance Manager的行为取决于MySQL配置文件中的选项。如果没有配置文件，MySQL实例管理器创建mysqld实例并试图用默认(编译嵌入的)配置来启动。这说明如果mysqld没有安装到 默认位置，IM不能猜出它的位置。如果你已经在非标准位置安装了MySQL服务器，你应使用配置文件。参见2.1.5节，“安装布局”。
如果有配置文件，IM将分析配置文件搜索[mysqld]部分(例如[mysqld]、[mysqld1]、[mysqld2]等)。每个部分指定一个实例。启动时IM将启动所有找到的实例。IM关闭时默认停止所有实例。
请注意有一个特殊选项mysqld-path(mysqld-path = path-to-mysqld- binary)，只能用IM识别。使用该变量让IM知道mysqld二进制驻留在哪儿。你还应该为服务器设置basedir和datadir选项。
启用MySQL实例管理器的典型MySQL服务器启动/关闭循环为：
·          用/etc/init.d/mysql脚本启动MySQL实例管理器。
·          MySQL实例管理器启动所有实例并监视它们。
·         如果某个服务器实例失败，MySQL实例管理器重启它。
·         如果MySQL实例管理器被关闭(例如用/etc/init.d/mysql stop命令)，所有实例被MySQL实例管理器关闭。
5.2.2. 连接到MySQL实例管理器并创建用户账户
使用MySQL客户端-服务器协议来处理同MySQL实例管理器之间的通信。你不能使用标准mysql客户端程序和MySQL C API来连接IM。IM支持客户端工具和mysql-4.1或以后的版本所分发的库所用的MySQL客户端-服务器协议版本。
IM将用户信息保存到密码文件中。密码文件的默认位置为/etc/mysqlmanager.passwd。
密码应类似于：
petr:*35110DC9B4D8140F5DE667E28C72DD2597B5C848
要想生成密码用--passwd选项调用IM。则输出可以重定向到/etc/mysqlmanager.passwd文件以添加新用户。下面为示例命令。
./mysqlmanager --passwd >> /etc/mysqlmanager.passwd
Creating record for new user.
Enter user name: mike
Enter password: <password>
Re-type password: <password>
下面的行将加到/etc/mysqlmanager.passwd：
mike:*00A51F3F48415C7D4E8908980D443C29C69B60C9
如果/etc/mysqlmanager.passwd文件中没有该条，则不能连接IM。
5.2.3. MySQL实例管理器命令行选项
MySQL实例管理器支持许多命令行选项。执行./mysqlmanager --help命令可以简单列出。有下面的选项： 
·         --help，-? 
显示帮助消息并退出。
·         --bind-address=name
绑定地址用于连接。
·         --default-mysqld-path=name
在Unix中，如果实例部分没有路径，则为寻找MySQL服务器二进制的地点。例如：default-mysqld-path = /usr/sbin/mysqld
·         --defaults-file=file_name
从给定文件读Instance Manager和MySQL服务器设定值。所有Instance Manager更改的配置将加入该文件。只能用于Instance Manager的第一选项。
·         --install
在Windows中，将Instance Manager安装为Windows服务。
·         --log=name
IM日志文件的路径。结合--run-as-service选项使用。
·         --monitoring-interval=Seconds
监视实例的间隔，单位为秒。Instance Manager将尝试连接每个监视的实例来检查它们是否是活动的/没有挂起。出现故障，IM将重启几次(实际上是多次)实例。可以用nonguarded选项为特定实例禁用该行为。如果未给定任何值， 默认使用20秒。
·         --passwd，-P
编写passwd文件并退出。
·         --password-file=name
从该文件中寻找Instance Manager用户和密码。默认文件是/etc/mysqlmanager.passwd。
·         --pid-file=name
使用的进程ID文件。默认情况下，该文件文件名为mysqlmanager.pid。
·         -- port=port_num
用于连接的端口号。(IANA分配的 默认端口号为2273)。
·         --print-defaults 
打印当前的默认值并退出。只能用作Instance Manager的第一选项。
·         --remove
在Windows中，删掉Instance Manager Windows服务。假定前面已经用--install运行了Instance Manager。
·         --run-as-service
使完善进程变为后台程序并启动。完善进程很简单，不易崩溃。出现故障后它将自己重启IM。
·         --socket=name
Unix中用于连接的套接字文件。默认情况下，文件名为/tmp/mysqlmanager.sock。
·         --standalone
在Windows中以单机模式运行Instance Manager。
·         --user=name
启动并运行mysqlmanager的用户名。建议使用运行mysqld服务器的用户账户来运行mysqlmanager。
·         --version, -V
输出版本信息并退出。
5.2.4. MySQL实例管理器配置文件
Instance Manager使用标准my.cnf文件。它使用[manager]部分为自己读取选项并读取[mysqld]部分来创建实例。[manager]部分包含上述列出的选项。下面为[manager]部分示例：
# MySQL Instance Manager options section
[manager]
default-mysqld-path = /usr/local/mysql/libexec/mysqld
socket=/tmp/manager.sock
pid-file=/tmp/manager.pid
password-file = /home/cps/.mysqlmanager.passwd
monitoring-interval = 2
port = 1999
bind-address = 192.168.1.5
MySQL实例管理器只在Unix中读取并管理/etc/my.cnf文件。在Windows中，MySQL实例管理器从Instance Manager的安装目录读取my.ini文件。用--defaults-file=file_ name选项可以更改默认选项文件的位置。
实例部分指定启动时给每个实例的选项。这些主要是普通MySQL服务器选项，但有一些IM-专用选项：
·         mysqld-path = <path-to-mysqld-binary>
mysqld服务器二进制的路径。
·         shutdown-delay = Seconds
IM应等待实例关闭的秒数。 默认为35秒。超过延迟时间后，IM假定实例正挂起并试图“kill –9”它。如果你使用带large表的InnoDB，你应当增加该值。
·         nonguarded
如果你想要为某个实例禁用IM监视功能，应设置该选项。
下面给出了几个实例示例。
[mysqld]
mysqld-path=/usr/local/mysql/libexec/mysqld
socket=/tmp/mysql.sock
port=3307
server_id=1
skip-stack-trace
core-file
skip-bdb
log-bin
log-error
log=mylog
log-slow-queries
 
[mysqld2]
nonguarded
port=3308
server_id=2
mysqld-path= /home/cps/mysql/trees/mysql-5.1/sql/mysqld
socket     = /tmp/mysql.sock5
pid-file   = /tmp/hostname.pid5
datadir= /home/cps/mysql_data/data_dir1
language=/home/cps/mysql/trees/mysql-5.1/sql/share/english
log-bin
log=/tmp/fordel.log
5.2.5. MySQL实例管理器识别的命令
一旦你已经为MySQL实例管理器设置了一个密码文件并且IM正在运行，你可以连接它。你可以使用mysql客户端工具通过标准MySQL API来连接。以下是MySQL实例管理器目前可以接收的命令的清单和例子。 
·         START INSTANCE <instance_name>
该命令将试图启动一个实例：
mysql> START INSTANCE mysqld4;
Query OK, 0 rows affected (0,00 sec)
·         STOP INSTANCE <instance_name>
将试图停止一个实例：
mysql> STOP INSTANCE mysqld4;
Query OK, 0 rows affected (0,00 sec)
·         SHOW INSTANCES
显示所有载入的实例名：
mysql> show instances;
+---------------+---------+
| instance_name | status  |
+---------------+---------+
| mysqld3       | offline |
| mysqld4       | online  |
| mysqld2       | offline |
+---------------+---------+
3 rows in set (0,04 sec)
·         SHOW INSTANCE STATUS <instance_name>
显示选定的实例的状态和版本信息：
mysql> SHOW INSTANCE STATUS mysqld3;
+---------------+--------+---------+
| instance_name | status | version |
+---------------+--------+---------+
| mysqld3       | online | unknown |
+---------------+--------+---------+
1 row in set (0.00 sec)
·         SHOW INSTANCE OPTIONS <instance_name>
显示实例使用的选项：
mysql> SHOW INSTANCE OPTIONS mysqld3;
+---------------+---------------------------------------------------+
| option_name   | value                                             |
+---------------+---------------------------------------------------+
| instance_name | mysqld3                                           |
| mysqld-path   | /home/cps/mysql/trees/mysql-4.1/sql/mysqld        |
| port          | 3309                                              |
| socket        | /tmp/mysql.sock3                                  |
| pid-file      | hostname.pid3                                     |
| datadir       | /home/cps/mysql_data/data_dir1/                   |
| language      | /home/cps/mysql/trees/mysql-4.1/sql/share/english |
+---------------+---------------------------------------------------+
7 rows in set (0.01 sec)
·         SHOW <instance_name> LOG FILES
该命令提供实例使用的所有日志文件。结果包含日志文件的路径和日志文件的大小。如果没有在配置文件中指定日志文件的路径 (例如log=/var/mysql.log)，IM试图猜出它的位置。如果IM不能猜出日志文件的位置，你应明确指定日志文件的位置。
mysql> SHOW mysqld LOG FILES;
+-------------+------------------------------------+----------+
| Logfile     | Path                               | Filesize |
+-------------+------------------------------------+----------+
| ERROR LOG   | /home/cps/var/mysql/owlet.err      | 9186     |
| GENERAL LOG | /home/cps/var/mysql/owlet.log      | 471503   |
| SLOW LOG    | /home/cps/var/mysql/owlet-slow.log | 4463     |
+-------------+------------------------------------+----------+
3 rows in set (0.01 sec)
·         SHOW <instance_name> LOG {ERROR | SLOW | GENERAL} size[,offset_from_end]
该命令查找指定的日志文件的一部分。因为大多数用户关注最新的日志消息，用size参数定义你想要从日志末尾开始索取的字节数。你可以指定可选offset_from_end参数从日志文件中部索取数据。下面的示例可以索取21个字节的数据，从日志文件末尾开始23个字节，2个字节用于结束：
mysql> SHOW mysqld LOG GENERAL 21, 2;
+---------------------+
| Log                 |
+---------------------+
| using password: YES |
+---------------------+
1 row in set (0.00 sec)
·         SET instance_name.option_name=option_value
该命令编辑指定的实例的配置文件以更改/增加实例选项。IM假定配置文件位于/etc/my.cnf。你应检查文件是否存在，并具有合适的权限。
mysql> SET mysqld2.port=3322;
Query OK, 0 rows affected (0.00 sec)
在MySQL服务器重启前，对配置文件进行的更改不会生效。并且，执行FLUSH INSTANCES命令后，才会将这些更改保存到Instance Manager的实例设定值的本地缓存中。
·         UNSET instance_name.option_name
该命令从实例的配置文件删除一个选项。
mysql> UNSET mysqld2.port;
Query OK, 0 rows affected (0.00 sec)
在MySQL服务器重启前，对配置文件进行的更改不会生效。并且，执行FLUSH INSTANCES命令后，才会将这些更改保存到Instance Manager的实例设定值的本地缓存中。
·         FLUSH INSTANCES
该命令强制IM重读配置文件并清空内部结构。编辑配置文件后应执行该命令。该命令不重启实例：
mysql> FLUSH INSTANCES;
Query OK, 0 rows affected (0.04 sec)
5.3. mysqld：MySQL服务器
5.3.1. mysqld命令行选项 
5.3.2. SQL服务器模式 
5.3.3. 服务器系统变量 
5.3.4. 服务器状态变量
mysqld是MySQL服务器。下面讨论MySQL服务器的配置： 
·         服务器支持的启动选项 
·         如何设置服务器SQL模式
·         服务器系统变量 
·         服务器状态变量
5.3.1. mysqld命令行选项
当启动mysqld服务器时，你可以使用4.3节，“指定程序选项”中描述的方法指定程序选项。最常用的方法是在选项文件中或在命令行提供选项。但是，在大多数情况下，希望服务器每次运行时使用相同的选项。最好的方法是确保将它们列在选项文件中。参见4.3.2节，“使用选项文件”。
mysqld从[mysqld]和[server]组读取选项。mysqld_safe从[mysqld]、[server]、[mysqld_safe]和[safe_mysqld]组读取选项。mysql.server从 [mysqld]和[mysql.server]组读取选项。嵌入式MySQL服务器通常从[server]、[embedded]和[xxxxx_SERVER]组读取选项，其中xxxxx是服务器嵌入的应用程序名。
mysqld接受许多命令行选项。执行mysqld --help可以简单列出来。要想看全部列表列，使用命令mysqld --verbose --help。
下面列出了一些最常用的服务器选项。其它的选项在其它地方描述：
·         影响安全的选项：参见5.6.3节，“Mysqld安全相关启动选项”。
·         SSL-相关选项：参见5.8.7.6节，“SSL命令行选项”。
·         二进制日志控制选项：参见5.11.3节，“二进制日志”。
·         复制相关选项：参见6.8节，“复制启动选项”。
·         特定存储引擎相关选项：参见15.1.1节，“MyISAM启动选项”、15.5.3节，“BDB启动选项”和15.2.4节，“InnoDB启动选项”。
你还可以将变量名作为一个选项，设置服务器系统变量的值，如本节后面所述。
·         --help，-?
显示简短的帮助消息并退出。使用--verbose和--help选项来看全部内容。
·         --allow-suspicious-udfs
该选项控制是否用户定义的函数只有一个xxx符，用作可载入的主函数。默认情况下，该选项被关闭，只有至少有一个附属符的UDF  可以载入。这样可以防止从未包含合法UDF的共享文件装载函数。参见27.2.3.6节，“用户定义函数安全注意事项”。
·         --ansi
使用标准(ANSI)SQL语法代替MySQL语法。参见1.8.3节，“在ANSI模式下运行MySQL”。使用--sql-mode选项可以更精确控制服务器SQL模式。
·         --basedir=path, -b path
MySQL安装目录的路径。通常所有路径根据该路径来解析。
·         --bind-address=IP
待绑定的IP地址。
·         --bootstrap
mysql_install_db脚本使用该选项来创建MySQL授权表，不需要启动MySQL服务器。
·         --console
将错误日志消息写入stderr和stdout，即使指定了--log-error。在Windows中，如果使用该选项，mysqld不关闭控制台窗口。
·         --character-sets-dir=path
字符集安装的目录。参见5.10.1节，“数据和排序用字符集”。
·         --chroot=path
通过chroot()系统调用在启动过程中将mysqld服务器放入一个封闭环境中。这是推荐的一个安全措施。请注意使用该选项可以 限制LOAD DATA INFILE和SELECT ... INTO OUTFILE。
·         --character-set-server=charset
使用charset作为 默认服务器字符集。参见5.10.1节，“数据和排序用字符集”。
·         --core-file
如果mysqld终止，写内核文件。在某些系统中，你还必须为mysqld_safe指定--core-file-size 选项。参见5.1.3节，“mysqld_safe：MySQL服务器启动脚本”。请注意对于一些系统，例如Solaris，如果你使用--user选项不会获得内核文件。
·         --collation-server=collation
使用collation作为 默认服务器校对规则。参见5.10.1节，“数据和排序用字符集”。
·         --datadir=path, -h path
数据目录的路径。
·         --debug[=debug_options], -# [debug_options]
如果MySQL配置了--with-debug，你可以使用该选项来获得一个跟踪文件，跟踪mysqld正进行的操作。debug_options字符串通常为'd:t:o，file_name'。参见E.1.2节，“创建跟踪文件”。
·         (DEPRECATED) --default-character-set=charset
使用char设置作为 默认字符集。由于--character-set-server，反对使用该选项。参见5.10.1节，“数据和排序用字符集”。
·         --default-collation=collation
使用collation 作为默认校对规则。由于--collation-server，反对使用该选项。参见5.10.1节，“数据和排序用字符集”。
·         --default-storage-engine=type
该选项为--default-table-type的同义词。
·         --default-table-type=type
设置表的默认类型。参见第15章：存储引擎和表类型。
·         --default-time-zone=type
设置默认服务器时区。该选项设置全局time_zone系统变量。如果未给出该选项， 默认时区与系统时区相同(用system_time_zone系统变量值给定)。
·         --delay-key-write[= OFF | ON | ALL]
如何使用DELAYED KEYS选项。键写入延迟会造成再次写MyISAM表时键缓冲区不能被清空。OFF禁用延迟的键写入。ON启用用DELAYED KEYS选项创建的表的延迟的键写入。ALL延迟所有MyISAM表的键写入。参见7.5.2节，“调节服务器参数”。参见15.1.1节，“MyISAM启动选项”。
注释：如果你将该变量设置为ALL，你不应从另一个正使用MyISAM表的程序中使用MyISAM表(例如从另一个MySQL服务器或用myisamchk)。这样操作会导致索引破坏。
·         --des-key-file=file_name
从该文件读DES_ENCRYPT()和DES_DECRYPT()使用的 默认键。
·         --enable-named-pipe
启用命名管道支持。该选项只适用Windows NT、2000、XP和2003系统，并且只适用支持命名管道连接的mysqld-nt和mysqld-max-nt服务器。
 
·         --exit-info[=flags], -T [flags]
这是不同标志的一个位掩码，你可以用来调试mysqld服务器。不要使用该选项，除非你确切知道它在做什么！
·         --external-locking
启用系统锁定。请注意如果你在lockd不能完全工作的系统上使用该选项(例如在Linux中)，mysqld容易死锁。该选项以前叫--enable-locking。
注释：如果你在许多MySQL进程中使用该选项来更新MyISAM表，你必须确保满足下述条件：
o        使用正被另一个进程更新的表的查询的缓存不可使用。
o        不应在共享表中使用--delay-key-write=ALL或DELAY_KEY_WRITE=1。
最简单的方法是结合使用--external-locking和--delay-key-write=OFF --query-cache-size=0。
(默认不能实现，因为在许多设置中，结合使用上述选项很有用）。 
·         --flush
执行SQL语句后向硬盘上清空更改。一般情况执行SQL语句后 MySQL向硬盘写入所有更改，让操作系统处理与硬盘的同步。参见A.4.2节，“如果MySQL依然崩溃，应作些什么”。
·         --init-file=file
启动时从该文件读SQL语句。每个语句必须在同一行中并且不应包括注释。
·         --language=lang_name, -L lang_name
用给定语言给出客户端错误消息。lang_name可以为语言名或语言文件安装目录的全路径名。参见5.10.2节，“设置错误消息语言”。
·         --large-pages
一些硬件/操作系统架构支持大于 默认值(通常4 KB)的内存页。实际支持取决于使用的硬件和OS。大量访问内存的应用程序通过使用较大的页，降低了Translation Lookaside Buffer (TLB)损失，可以改善性能。
目前，MySQL只在Linux中支持大页面(在Linux中被称作HugeTLB)。我们已经计划将该支持扩展到FreeBSD、Solaris和其它可能的平台。
在Linux中可以使用大页面前，需要配置HugeTLB内存池。参考Linux内核源码中的hugetlbpage.txt文件。
默认情况下该选项被禁用。
·         ---log[=file], -l [file]
日志连接和对文件的查询。参见5.11.2节，“通用查询日志”。如果你不指定文件名，MySQL使用host_name.log作为文件名。
·         --log-bin=[file]
二进制日志文件。将更改数据的所有查询记入该文件。用于备份和复制。参见5.11.3节，“二进制日志”。建议指定一个文件名(原因参见A.8.1节，“MySQL中的打开事宜”)，否则MySQL使用host_name-bin作为日志文件基本名。
·         --log-bin-index[=file]
二进制日志文件名的索引文件。参见5.11.3节，“二进制日志”。如果你不指定文件名，并且如果你没有在--log-bin中指定，MySQL使用host_name-bin.index作为文件名。
·         --log-bin-trust-routine-creators[={0|1}]
没有参数或参数为1,该选项将系统变量log_bin_trust_routine_creators设置为1。为参数 0时，该选项将系统变量设置为0。log_bin_trust_routine_creators影响MySQL如何对保存的程序的创建强加限制。参见20.4节，“存储子程序和触发程序的二进制日志功能”。
·         --log-error[=file]
该文件的日志错误和启动消息。参见5.11.1节，“错误日志”。如果你不指定文件名，MySQL使用host_name.err作为文件名。如果文件名没有扩展名，则加上.err扩展名。
·         --log-isam[=file]
将所有MyISAM更改记入该文件(只有调试MyISAM时才使用)。
·         (DEPRECATED) --log-long-format
记录激活的更新日志、二进制更新日志、和慢查询日志的大量信息。例如，所有查询的用户名和时间戳将记录下来。不赞成选用该选项，因为它现在代表 默认记录行为。(参见--log-short-format描述）。--log-queries-not-using-indexes选项适合将未使用索引的查询记录到慢查询日志中。
·         --log-queries-not-using-indexes
如果你结合--log-slow-queries使用该选项，未使用索引的查询也被记录到慢查询日志中。参见5.11.4节，“慢速查询日志”。
·         --log-short-format
记录激活的更新日志、二进制更新日志、和慢查询日志的少量信息。例如，用户名和时间戳不记录下来。
·         ---log-slow-admin-statements
将慢管理语句例如OPTIMIZE TABLE、ANALYZE TABLE和ALTER TABLE记入慢查询日志。
·         --log-slow-queries[=file]
将所有执行时间超过long_query_time 秒的查询记入该文件。参见5.11.4节，“慢速查询日志”。详细信息参见--log-long-format和--log-short-format选项描述。
 
·         --log-warnings, -W
将警告例如Aborted connection...打印到错误日志。建议启用该选项，例如，如果你使用复制 (你可以得到关于所发生事情的详细信息，例如关于网络故障和重新连接的消息)。默认情况下启用该选项；要想禁用它，使用--skip-log-warnings。中断的连接不会记入错误日志，除非值大于1。参见A.2.10节，“通信错误和失效连接”。
·         --low-priority-updates
表修改(INSERT, REPLACE, DELETE, UPDATE)比选择的优先级要低。也可以通过{INSERT | REPLACE | DELETE | UPDATE} LOW_PRIORITY ... 来降低某个查询的优先级来实现，或通过SET LOW_PRIORITY_UPDATES=1来更改一个线程的优先级。参见7.3.2节，“表锁定事宜”。
·          --memlock
将mysqld 进程锁定在内存中。在支持mlockall()系统调用的系统上有效，例如Solaris。如果操作系统使mysqld在硬盘上交换时出现问题，可以为你提供帮助。请注意使用该选项时需要以root运行服务器，但从安全考虑并不是一个好注意。
·         --myisam-recover [=option[,option...]]]
将存储引擎MyISAM设置为恢复模式。该选项值是DEFAULT、BACKUP、FORCE或QUICK值的任何组合。如果你指定多个值，用逗号间隔开。你还可以使用""值来禁用该选项。使用如果该选项，当mysqld打开MyISAM表时，检查是否表标记为崩溃或没有正确关闭。(只有用--skip-external-lockingare运行时，最后的选项才工作）。 如果是这种情况，mysqld则检查 表。如果表被破坏，mysqld试图维护它。
下面的选项影响维护工作：
选项
描述
DEFAULT
与没有使用--myisam-recover选项相同。
BACKUP
如果在恢复过程中，数据文件被更改了，将tbl_name.MYD文件备份为tbl_name-datetime.BAK。
FORCE
即使.MYD文件将丢掉多个行也进行恢复。
QUICK
如果没有删除块，不要检查表中的行。
在表自动修复前，MySQL错误日志添加一条注解。如果你不想用户干涉干涉大多数问题，你应使用BACKUP,FORCE选项。该选项强制维护表，即使一些行将会被删除也不例外，但它保持旧的数据文件做为备份，以便你可以在后来进行检查。
·         --ndb-connectstring=connect_string
当使用NDB存储引擎时，可以指出通过设置连接字符串选项来分发群集配置的管理服务器。相关语法参见17.4.4.2节，“MySQL簇连接字符串”。
·         --ndbcluster
如果二进制支持NDB CLUSTER存储引擎，使用该选项可以代替禁用MySQL Cluster支持的 默认设置。参见第17章：MySQL簇。
·         --old-passwords
强制服务器为新密码生成短(4.1前)密码哈希。如果服务器必须支持旧客户端程序，为保证兼容性这很有用。参见5.7.9节，“MySQL 4.1中的密码哈希处理”。
·         --one-thread
只使用一个线程(用于在Linux中调试)。只有服务器启用了调试，该选项才可用。参见E.1节，“调试MySQL服务器”。
·         --open-files-limit=count
用来更改mysqld文件描述符的数量。如果没有设置或设置为0，则mysqld通过setrlimit()使用该值来保存文件描述符。如果该值为0，则mysqld 保存max_connections*5或max_connections + table_cache*2(取较大者)个文件。如果mysqld给出你错误"打开的文件太多。"，你应试试增加该值。
·         --pid-file=path
mysqld_safe使用的进程ID文件的路径。
·         --port=port_num, -P port_num
帧听TCP/IP连接时使用的端口号。
·         --safe-mode
跳过一些优化阶段。
·         (DEPRECATED) --safe-show-database
参见5.7.3节，“MySQL提供的权限”。
·         --safe-user-create
启用后如果用户没有mysql.user表或表中列的INSERT权限，则用户不能用GRANT语句创建新用户。
·         --secure-auth
不允许使用旧(4.1之前)密码的账户进行鉴定。
·         --shared-memory
启用本地客户端的共享内存连接。该选项只用于Windows。
·         --shared-memory-base-name=name
共享内存连接名。该选项只用于Windows。
·         --skip-bdb
禁用BDB存储引擎。这样可以节省内存，并可能加速某些操作。如果你需要BDB表则不要使用该选项。
·         --skip-concurrent-insert
关闭在同一时间在MyISAM表中选择和插入的能力。(只有你发现缺陷时才使用该选项）。 
·         --skip-external-locking
不要使用系统锁定。要想使用myisamchk，你必须关闭服务器。(参见1.4.3节，“MySQL稳定性”）。 要避免该需求，使用MySQL Monitor中的CHECK TABLE和REPAIR TABLE来检查并维护MyISAM表。
·         --skip-grant-tables
该选项使服务器不使用权限系统。该权限允许访问服务器的用户不受限制地访问所有数据库。你可以从系统外壳命令行执行mysqladmin flush-privileges或mysqladmin reload命令，或执行MySQL FLUSH PRIVILEGES语句让运行的服务器重新开始使用 授权表。
·         --skip-host-cache
为了更快地在名称-IP之间进行解析，不要使用内部主机名缓存。相反，每次客户端连接时查询DNS服务器。参见7.5.6节，“MySQL如何使用DNS”。
·         --skip-innodb
禁用InnoDB存储引擎。这样可以节省内存，并可能加速某些操作。如果你需要BDB表则不要使用该选项。
·         --skip-name-resolve
不要解析正检查客户端连接的主机名。只使用IP号。如果你使用该项， 授权表中的所有Host列值必须为IP号或localhost。参见7.5.6节，“MySQL如何使用DNS”。
·         --skip-ndbcluster
禁用NDB CLUSTER存储引擎。这是支持NDB CLUSTER存储引擎的二进制的默认设置，说明只有用--ndbcluster选项显式覆盖--skip-ndbcluster选项时，系统才为该存储引擎分配内存和其它资源。使用示例参见17.4.3节，“MySQL簇的快速测试设置”。
·         --skip-networking
不帧听TCP/IP连接。必须通过命名管道或共享内存(在Windows中)或Unix套接字文件(在Unix中)完成mysqld的相互操作。对于只允许本地客户端的系统，大力推荐该选项。参见7.5.6节，“MySQL如何使用DNS”。
·         --standalone
只适合基于Windows-NT的系统；指导MySQL服务器不做为服务来运行。
·         --symbolic-links, --skip-symbolic-links
启用或禁用符号链接支持。在Windows和Unix中，该选项的作用是不同的：
o        在Windows中，启用符号链接，你可以通过创建包含实际目录路径的directory.sym文件来建立数据库目录的符号链接。参见7.6.1.3节，“在Windows平台上使用关于数据库的符号链接”。
在Unix中，启用符号链接表示你可以用CREATE TABLE语句的INDEX DIRECTORY或DATA DIRECTORY选项将MyISAM索引文件或数据文件链接到另一个目录。如果你删除或重新命名表，符号链接所指的文件也被删除或重新命名。参见13.1.5节，“CREATE TABLE语法”。
·         --skip-safemalloc
如果MySQL配置了--with-debug=full，所有MySQL程序在内存分配和释放时检查内存是否溢出。检查很慢，因此如果你不需要你可以用--skip-safemalloc选项来避免。
·         --skip-show-database
使用该选项，只允许具有SHOW DATABASES权限的用户执行SHOW DATABASES语句，该语句显示所有数据库名。不使用该选项，允许所有用户执行SHOW DATABASES，但只向具有SHOW DATABASES权限或部分数据库权限的用户显示每个数据库名。请注意全局权限为数据库的一种权限。
·         --skip-stack-trace
不跟踪写堆栈。当调试运行mysqld时该选项有用。在一些系统中，你还必须使用该选项来获得内核文件。参见E.1节，“调试MySQL服务器”。
·         --skip-thread-priority
在快速响应中禁用线程优先级。
·         --socket=path
在Unix中，该选项指定用于本地连接的Unix套接字文件。 默认值是/tmp/mysql.sock。在Windows中，该选项指定本地连接所使用的管道名。 默认值是MySQL。
·         --sql-mode=value[,value[,value...]]
将MySQL设置为SQL模式。参见5.3.2节，“SQL服务器模式”。
·         --temp-pool
该选项使服务器创建的大多数临时文件使用一系列文件名，而不是每个新文件使用唯一的文件名。这样解决了在Linux内核中用 不同的名创建许多新文件的问题。在以前，Linux似乎“泄漏”内存，因为它被直接分配到directory entry缓存而不是硬盘缓存。
·         --transaction-isolation=level
设置默认事务隔离级别，可以READ-UNCOMMITTED、READ-COMMITTEE、REPEATABLE-READ或SERIALIZABLE。参见13.4.6节，“SET TRANSACTION语法”。
·         --tmpdir=path, -t path
创建临时文件的目录路径。默认/tmp目录在太小不能容纳临时表的分区时该选项很有用。该选项接受round-robin模式的几个路径。在Unix中路径应用冒号(‘:’) 间隔开，在Windows、NetWare和OS/2中用分号(‘；’) 间隔开。如果MySQL服务器为复制从机，你不应让--tmpdir指向基于内存的文件系统中的目录或服务器主机重启时会清除的目录。复制从机需要临时文件，机器重启时可以复制临时表或执行LOAD DATA INFILE操作。如果服务器重启时临时文件目录中的文件丢失，复制失败。
·         --user={user_name | user_id}, -u {user_name | user_id}
用user_name或数字用户ID user_id运行mysqld服务器。(“用户”指系统登录账户，而不是 授权表中所列的MySQL用户）。 
用root启动mysqld时强制使用该选项。服务器在启动序列中更改用户ID，让它做为具体用户而不是root运行。参见5.6.1节，“通用安全指南”。
要避免用户在my.cnf文件中添加--user=root选项(使服务器用root运行)时可能出现的安全漏洞，mysqld只使用指定的第1个--user选项，如果有多个--user选项则会出现警告。在命令行选项前处理/etc/my.cnf和$MYSQL_HOME/my.cnf中的选项，因此建议你在/etc/my.cnf中放一个--user选项，并指定root之外的其它值。在其它--user选项前先找到/etc/my.cnf中的选项，确保服务器用其它用户运行，如果找到其它--user选项则会出现警告。
·         --version, -V
显示版本信息并退出。
你可以使用--var_name=value形式的选项为服务器系统变量。例如，--key_buffer_size=32M将变量key_buffer_size设为32MB。
请注意设置变量时，MySQL可以自动将它纠正到某个给定范围内，或如果只允许某个值，则将设置值调节到最接近允许的值。
还可以通过--set-variable=var_name=value或-O var_name=value语法来设置变量。但是，现在不赞成使用该语法。
5.3.3节，“服务器系统变量”完全描述了全部系统变量。调节服务器参数部分包括如何对他们进行优化。参见7.5.2节，“调节服务器参数”。
你可以用SET语句更改大多数服务器系统变量的值。参见13.5.3节，“SET语法”。
如果你想用SET 限制启动项可设的最大值，你可以使用--maximum-var_name命令行选项来定义。
5.3.2. SQL服务器模式
MySQL服务器可以以不同的SQL模式来操作，并且可以为不同客户端应用不同模式。这样每个应用程序可以根据自己的需求来定制服务器的操作模式。
模式定义MySQL应支持哪些SQL语法，以及应执行哪种数据验证检查。这样可以更容易地在不同的环境中使用MySQL，并结合其它数据库服务器使用MySQL。
你可以用--sql-mode="modes"选项启动mysqld来设置默认SQL模式。如果你想要重设，该值还可以为空(--sql-mode ="")。
你还可以在启动后用SET [SESSION|GLOBAL] sql_mode='modes'语句设置sql_mode变量来更改SQL模式。设置 GLOBAL变量时需要拥有SUPER权限，并且会影响从那时起连接的所有客户端的操作。设置SESSION变量只影响当前的客户端。任何客户端可以随时更改自己的会话 sql_mode值。
Modesis是用逗号(‘，’)间隔开的一系列不同的模式。你可以用SELECT @@sql_mode语句查询当前的模式。默认值是空(没有设置任何模式)。
主要重要sql_mode值为：
·         ANSI
更改语法和行为，使其更符合标准SQL。
·         STRICT_TRANS_TABLES
如果不能将给定的值插入到事务表中，则放弃该语句。对于非事务表，如果值出现在单行语句或多行语句的第1行，则放弃该语句。本节后面给出了更详细的描述。
·         TRADITIONAL
Make MySQL的行为象“传统”SQL数据库系统。该模式的简单描述是当在列中插入不正确的值时“给出错误而不是警告”。注释：一旦发现错误立即放弃INSERT/UPDATE。如果你使用非事务存储引擎，这种方式不是你想要的，因为出现错误前进行的数据更改不会“滚动”，结果是更新“只进行了一部分”。
本手册指“严格模式”，表示至少STRICT _TRANS_TABLES或STRICT _ALL_TABLES被启用的模式。
下面描述了支持的所有模式：
·         ALLOW_INVALID_DATES
在严格模式下不要检查全部日期。只检查1到12之间的月份和1到31之间的日。这在Web应用程序中，当你从三个不同的字段获取年、月、日，并且想要确切保存用户插入的内容(不进行日期验证)时很重要。该模式适用于DATE和DATETIME列。不适合TIMESTAMP列，TIMESTAMP列需要验证日期。
启用严格模式后，服务器需要合法的月和日，不仅仅是分别在1到12和1到31范围内。例如，禁用严格模式时'2004-04-31'是合法的，但启用严格模式后是非法的。要想在严格模式允许遮掩固定日期，还应启用ALLOW_INVALID_DATES。
·         ANSI_QUOTES
将‘"’视为识别符引号(‘`’引号字符)，不要视为字符串的引号字符。在ANSI模式，你可以仍然使用‘`’来引用识别符。启用ANSI_QUOTES后，你不能用双引号来引用字符串，因为它被解释为识别符。
·         ERROR_FOR_DIVISION_BY_ZERO
在严格模式，在INSERT或UPDATE过程中，如果被零除(或MOD(X，0))，则产生错误(否则为警告)。如果未给出该模式，被零除时MySQL返回NULL。如果用到INSERT IGNORE或UPDATE IGNORE中，MySQL生成被零除警告，但操作结果为NULL。
·         HIGH_NOT_PRECEDENCE
NOT操作符的优先顺序是表达式例如NOT a BETWEEN b AND c被解释为NOT (a BETWEEN b AND c)。在一些旧版本MySQL中， 表达式被解释为(NOT a) BETWEEN b AND c。启用HIGH_NOT_PRECEDENCESQL模式，可以获得以前的更高优先级的结果。
mysql> SET sql_mode = '';
mysql> SELECT NOT 1 BETWEEN -5 AND 5;
        -> 0
mysql> SET sql_mode = 'broken_not';
mysql> SELECT NOT 1 BETWEEN -5 AND 5;
        -> 1
·         IGNORE_SPACE
允许函数名和‘(’之间有空格。强制将所有函数名视为保存的字。结果是，如果你想要访问保存为字的数据库、表或列名，你必须引用它。例如，因为有USER()函数，mysql数据库中的user表名和该表内的User列被保存下来，因此你必须引用它们：
SELECT "User" FROM mysql."user";
·         NO_AUTO_CREATE_USER
防止GRANT自动创建新用户，除非还指定了密码。
·         NO_AUTO_VALUE_ON_ZERO
NO_AUTO_VALUE_ON_ZERO影响AUTO_INCREMENT列的处理。一般情况，你可以向该列插入NULL或0生成下一个序列号。NO_AUTO_VALUE_ON_ZERO禁用0，因此只有NULL可以生成下一个序列号。
如果将0保存到表的AUTO_INCREMENT列，该模式会很有用。(不推荐采用该惯例)。例如，如果你用mysqldump转储表并重载，MySQL遇到0值一般会生成新的序列号，生成的表的内容与转储的表不同。重载转储文件前启用NO_AUTO_VALUE_ON_ZERO可以解决该问题。mysqldump在输出中自动包括启用NO_AUTO_VALUE_ON_ZERO的语句。
·         NO_BACKSLASH_ESCAPES
禁用反斜线字符(‘\’)做为字符串内的退出字符。启用该模式，反斜线则成为普通字符。
·         NO_DIR_IN_CREATE
创建表时，忽视所有INDEX DIRECTORY和DATA DIRECTORY指令。该选项对从复制服务器有用。
·         NO_ENGINE_SUBSTITUTION
如果需要的存储引擎被禁用或未编译，可以防止自动替换存储引擎。
·         NO_FIELD_OPTIONS
不要在SHOW CREATE TABLE的输出中打印MySQL专用列选项。该模式在可移植模式（portability mode）下用于mysqldump。
·         NO_KEY_OPTIONS
不要在SHOW CREATE TABLE的输出中打印MySQL专用索引选项。该模式在可移植模式（portability mode）下用于mysqldump。
·         NO_TABLE_OPTIONS
不要在SHOW CREATE TABLE的输出中打印MySQL专用表选项（例如ENGINE）。该模式在可移植模式（portability mode）下用于mysqldump。
·         NO_UNSIGNED_SUBTRACTION
在减运算中，如果某个操作数没有符号，不要将结果标记为UNSIGNED。请注意这样使UNSIGNED BIGINT不能100%用于上下文中。参见12.8节，“Cast函数和操作符”。
 
·         NO_ZERO_DATE
在严格模式，不要将 '0000-00-00'做为合法日期。你仍然可以用IGNORE选项插入零日期。在非严格模式，可以接受该日期，但会生成警告。
·         NO_ZERO_IN_DATE
在严格模式，不接受月或日部分为0的日期。如果使用IGNORE选项，我们为类似的日期插入'0000-00-00'。在非严格模式，可以接受该日期，但会生成警告。
·         ONLY_FULL_GROUP_BY
不要让GROUP BY部分中的查询指向未选择的列。
·         PIPES_AS_CONCAT
将||视为字符串连接操作符（＋）(同CONCAT())，而不视为OR。
·         REAL_AS_FLOAT
将REAL视为FLOAT的同义词，而不是DOUBLE的同义词。
·         STRICT_TRANS_TABLES
为所有存储引擎启用严格模式。非法数据值被拒绝。后面有详细说明。
·         STRICT_TRANS_TABLES
为事务存储引擎启用严格模式，也可能为非事务存储引擎启用严格模式。后面有详细说明。
严格模式控制MySQL如何处理非法或丢失的输入值。有几种原因可以使一个值为非法。例如，数据类型错误，不适合列，或超出范围。当新插入的行不包含某列的没有显示定义DEFAULT子句的值，则该值被丢失。
对于事务表，当启用STRICT_ALL_TABLES或STRICT_TRANS_TABLES模式时，如果语句中有非法或丢失值，则会出现错误。语句被放弃并滚动。
对于非事务表，如果插入或更新的第1行出现坏值，两种模式的行为相同。语句被放弃，表保持不变。如果语句插入或修改多行，并且坏值出现在第2或后面的行，结果取决于启用了哪个严格选项：
·         对于STRICT_ALL_TABLES，MySQL返回错误并忽视剩余的行。但是，在这种情况下，前面的行已经被插入或更新。这说明你可以部分更新，这可能不是你想要的。要避免这点，最好使用单行语句，因为这样可以不更改表即可以放弃。
·         对于STRICT_TRANS_TABLES，MySQL将非法值转换为最接近该列的合法值并插入调整后的值。如果值丢失，MySQL在列中插入隐式 默认值。在任何情况下，MySQL都会生成警告而不是给出错误并继续执行语句。13.1.5节，“CREATE TABLE语法”描述了隐式默认值。
严格模式不允许非法日期，例如'2004-04-31'。它不允许禁止日期使用“零”部分，例如'2004-04-00'或“零”日期。要想禁止，应在严格模式基础上，启用NO_ZERO_IN_DATE和NO_ZERO_DATE SQL模式。
如果你不使用严格模式(即不启用STRICT_TRANS_TABLES或STRICT_ALL_TABLES模式)，对于非法或丢失的值，MySQL将插入调整后的值并给出警告。在严格模式，你可以通过INSERT IGNORE或UPDATE IGNORE来实现。参见13.5.4.22节，“SHOW WARNINGS语法”。
下面的特殊模式快速组合了前面所列的模式。
其中包括大多数最新版本MySQL中的所有模式值。旧版本中，组合模式不包括新版本中没有的不适用的具体模式值。
·         ANSI
等同REAL_AS_FLOAT、PIPES_AS_CONCAT、ANSI_QUOTES、IGNORE_SPACE。参见1.8.3节，“在ANSI模式下运行MySQL”。
·         DB2
等同PIPES_AS_CONCAT、ANSI_QUOTES、IGNORE_SPACE、NO_KEY_OPTIONS、NO_TABLE_OPTIONS、NO_FIELD_OPTIONS。
·         MAXDB
等同PIPES_AS_CONCAT、ANSI_QUOTES、IGNORE_SPACE、NO_KEY_OPTIONS、NO_TABLE_OPTIONS、NO_FIELD_OPTIONS、 NO_AUTO_CREATE_USER。
·         MSSQL
等同PIPES_AS_CONCAT、ANSI_QUOTES、IGNORE_SPACE、NO_KEY_OPTIONS、NO_TABLE_OPTIONS、 NO_FIELD_OPTIONS。
·         MYSQL323 
等同NO_FIELD_OPTIONS、HIGH_NOT_PRECEDENCE。
·         MYSQL40
等同NO_FIELD_OPTIONS、HIGH_NOT_PRECEDENCE。
·         ORACLE
等同PIPES_AS_CONCAT、ANSI_QUOTES、IGNORE_SPACE、NO_KEY_OPTIONS、NO_TABLE_OPTIONS、NO_FIELD_OPTIONS、NO_AUTO_CREATE_USER。
·         POSTGRESQL
等同PIPES_AS_CONCAT、ANSI_QUOTES、IGNORE_SPACE、NO_KEY_OPTIONS、NO_TABLE_OPTIONS、NO_FIELD_OPTIONS。
·         TRADITIONAL
等同STRICT_TRANS_TABLES、STRICT_ALL_TABLES、NO_ZERO_IN_DATE、NO_ZERO_DATE、ERROR_FOR_DIVISION_BY_ZERO、NO_AUTO_CREATE_USER。
5.3.3. 服务器系统变量
5.3.3.1. 动态系统变量
服务器将维护许多表示其配置的系统变量。所有变量均有默认值。可以在命令行中或选项文件设置选项在服务器启动时对它们进行设置。大多数可以在运行时使用SET语句来设置。
mysqld服务器维护两种变量。全局变量影响服务器的全局操作。会话变量影响具体客户端连接相关操作。
服务器启动时，将所有全局变量初始化为默认值。可以在选项文件或命令行中指定的选项来更改这些默认值。服务器启动后，通过连接服务器并执行SET GLOBAL var_name语句可以更改动态全局变量。要想更改全局变量，必须具有SUPER权限。
服务器还为每个客户端连接维护会话变量。连接时使用相应全局变量的当前值对客户端会话变量进行初始化。客户可以通过SET SESSION var_name语句来更改动态会话变量。设置会话变量不需要特殊权限，但客户可以只更改自己的会话变量，而不更改其它客户的会话变量。
任何访问全局变量的客户端都可以看见对全局变量的更改。但是，它只影响在更改后连接的从该全局变量初始化相应会话变量的客户端。它不会影响已经连接上的客户端的会话变量(甚至是执行SET GLOBAL语句的客户端)。
当使用启动选项设置变量时，变量值可以使用后缀K、M或G分别表示千字节、兆字节或gigabytes。例如，下面的命令启动服务器时的键值缓冲区大小为16 megabytes：
mysqld --key_buffer_size=16M
后缀的大小写美关系；16M和16m是同样的。
运行时，使用SET语句来设置系统变量。此时，不能使用后缀，但值可以采取下列表达式：
mysql> SET sort_buffer_size = 10 * 1024 * 1024;
要想显式指定是否设置全局或会话变量，使用GLOBAL或SESSION选项：
mysql> SET GLOBAL sort_buffer_size = 10 * 1024 * 1024;
mysql> SET SESSION sort_buffer_size = 10 * 1024 * 1024;
两个选项均没有，则语句设置会话变量。
5.3.3.1节，“动态系统变量”中列出了可以在运行时设置的变量。
如果你想用SET语句限制系统变量可设的最大值，可以在服务器启动时通过--maximum-var_name形式的选项来指定。例如，要想防止query_cache_size的值运行时超过32MB，使用选项--maximum-query_cache_size=32M。
你可以通过SHOW VARIABLES语句查看系统变量及其值。详细信息参见9.4节，“系统变量”。
mysql> SHOW VARIABLES;
+---------------------------------+-------------------------------------------+
| Variable_name                   | Value                                     |
+---------------------------------+-------------------------------------------+
| auto_increment_increment        | 1                                         |
| auto_increment_offset           | 1                                         |
| automatic_sp_privileges         | ON                                        |
| back_log                        | 50                                        |
| basedir                         | /home/jon/bin/mysql/                      |
| binlog_cache_size               | 32768                                     |
| bulk_insert_buffer_size         | 8388608                                   |
| character_set_client            | latin1                                    |
| character_set_connection        | latin1                                    |
| character_set_database          | latin1                                    |
| character_set_results           | latin1                                    |
| character_set_server            | latin1                                    |
| character_set_system            | utf8                                      |
| character_sets_dir              | /home/jon/bin/mysql/share/mysql/charsets/ |
| collation_connection            | latin1_swedish_ci                         |
| collation_database              | latin1_swedish_ci                         |
| collation_server                | latin1_swedish_ci                         |
| completion_type                 | 0                                         |
| concurrent_insert               | 1                                         |
| connect_timeout                 | 5                                         |
| datadir                         | /home/jon/bin/mysql/var/                  |
| date_format                     | %Y-%m-%d                                  |
| datetime_format                 | %Y-%m-%d %H:%i:%s                         |
| default_week_format             | 0                                         |
| delay_key_write                 | ON                                        |
| delayed_insert_limit            | 100                                       |
| delayed_insert_timeout          | 300                                       |
| delayed_queue_size              | 1000                                      |
| div_precision_increment         | 4                                         |
| engine_condition_pushdown       | OFF                                       |
| expire_logs_days                | 0                                         |
| flush                           | OFF                                       |
| flush_time                      | 0                                         |
| ft_boolean_syntax               | + -><()~*:""&|                            |
| ft_max_word_len                 | 84                                        |
| ft_min_word_len                 | 4                                         |
| ft_query_expansion_limit        | 20                                        |
| ft_stopword_file                | (built-in)                                |
| group_concat_max_len            | 1024                                      |
| have_archive                    | YES                                       |
| have_bdb                        | NO                                        |
| have_blackhole_engine           | YES                                       |
| have_compress                   | YES                                       |
| have_crypt                      | YES                                       |
| have_csv                        | YES                                       |
| have_example_engine             | NO                                        |
| have_federated_engine           | NO                                        |
| have_geometry                   | YES                                       |
| have_innodb                     | YES                                       |
| have_isam                       | NO                                        |
| have_ndbcluster                 | DISABLED                                  |
| have_openssl                    | NO                                        |
| have_partition_engine           | YES                                       |
| have_query_cache                | YES                                       |
| have_raid                       | NO                                        |
| have_rtree_keys                 | YES                                       |
| have_symlink                    | YES                                       |
| init_connect                    |                                           |
| init_file                       |                                           |
| init_slave                      |                                           |
| innodb_additional_mem_pool_size | 1048576                                   |
| innodb_autoextend_increment     | 8                                         |
| innodb_buffer_pool_awe_mem_mb   | 0                                         |
| innodb_buffer_pool_size         | 8388608                                   |
| innodb_checksums                | ON                                        |
| innodb_commit_concurrency       | 0                                         |
| innodb_concurrency_tickets      | 500                                       |
| innodb_data_file_path           | ibdata1:10M:autoextend                    |
| innodb_data_home_dir            |                                           |
| innodb_doublewrite              | ON                                        |
| innodb_fast_shutdown            | 1                                         |
| innodb_file_io_threads          | 4                                         |
| innodb_file_per_table           | OFF                                       |
| innodb_flush_log_at_trx_commit  | 1                                         |
| innodb_flush_method             |                                           |
| innodb_force_recovery           | 0                                         |
| innodb_lock_wait_timeout        | 50                                        |
| innodb_locks_unsafe_for_binlog  | OFF                                       |
| innodb_log_arch_dir             |                                           |
| innodb_log_archive              | OFF                                       |
| innodb_log_buffer_size          | 1048576                                   |
| innodb_log_file_size            | 5242880                                   |
| innodb_log_files_in_group       | 2                                         |
| innodb_log_group_home_dir       | ./                                        |
| innodb_max_dirty_pages_pct      | 90                                        |
| innodb_max_purge_lag            | 0                                         |
| innodb_mirrored_log_groups      | 1                                         |
| innodb_open_files               | 300                                       |
| innodb_support_xa               | ON                                        |
| innodb_sync_spin_loops          | 20                                        |
| innodb_table_locks              | ON                                        |
| innodb_thread_concurrency       | 20                                        |
| innodb_thread_sleep_delay       | 10000                                     |
| interactive_timeout             | 28800                                     |
| join_buffer_size                | 131072                                    |
| key_buffer_size                 | 8388600                                   |
| key_cache_age_threshold         | 300                                       |
| key_cache_block_size            | 1024                                      |
| key_cache_division_limit        | 100                                       |
| language                        | /home/jon/bin/mysql/share/mysql/english/  |
| large_files_support             | ON                                        |
| large_page_size                 | 0                                         |
| large_pages                     | OFF                                       |
| license                         | GPL                                       |
| local_infile                    | ON                                        |
| locked_in_memory                | OFF                                       |
| log                             | ON                                        |
| log_bin                         | ON                                        |
| log_bin_trust_routine_creators  | OFF                                       |
| log_error                       | /home/jon/bin/mysql/var/master1.err       |
| log_slave_updates               | OFF                                       |
| log_slow_queries                | OFF                                       |
| log_warnings                    | 1                                         |
| long_query_time                 | 10                                        |
| low_priority_updates            | OFF                                       |
| lower_case_file_system          | OFF                                       |
| lower_case_table_names          | 0                                         |
| max_allowed_packet              | 1048576                                   |
| max_binlog_cache_size           | 4294967295                                |
| max_binlog_size                 | 1073741824                                |
| max_connect_errors              | 10                                        |
| max_connections                 | 100                                       |
| max_delayed_threads             | 20                                        |
| max_error_count                 | 64                                        |
| max_heap_table_size             | 16777216                                  |
| max_insert_delayed_threads      | 20                                        |
| max_join_size                   | 4294967295                                |
| max_length_for_sort_data        | 1024                                      |
| max_relay_log_size              | 0                                         |
| max_seeks_for_key               | 4294967295                                |
| max_sort_length                 | 1024                                      |
| max_tmp_tables                  | 32                                        |
| max_user_connections            | 0                                         |
| max_write_lock_count            | 4294967295                                |
| multi_range_count               | 256                                       |
| myisam_data_pointer_size        | 6                                         |
| myisam_max_sort_file_size       | 2147483647                                |
| myisam_recover_options          | OFF                                       |
| myisam_repair_threads           | 1                                         |
| myisam_sort_buffer_size         | 8388608                                   |
| ndb_autoincrement_prefetch_sz   | 32                                        |
| ndb_cache_check_time            | 0                                         |
| ndb_force_send                  | ON                                        |
| ndb_index_stat_cache_entries    | 32                                        |
| ndb_index_stat_enable           | ON                                        |
| ndb_index_stat_update_freq      | 20                                        |
| ndb_use_exact_count             | ON                                        |
| ndb_use_transactions            | ON                                        |
| net_buffer_length               | 16384                                     |
| net_read_timeout                | 30                                        |
| net_retry_count                 | 10                                        |
| net_write_timeout               | 60                                        |
| new                             | OFF                                       |
| old_alter_table                 | OFF                                       |
| old_passwords                   | OFF                                       |
| open_files_limit                | 1024                                      |
| optimizer_prune_level           | 1                                         |
| optimizer_search_depth          | 62                                        |
| pid_file                        | /home/jon/bin/mysql/var/hostname.pid1     |
| port                            | 3306                                      |
| preload_buffer_size             | 32768                                     |
| protocol_version                | 10                                        |
| query_alloc_block_size          | 8192                                      |
| query_cache_limit               | 1048576                                   |
| query_cache_min_res_unit        | 4096                                      |
| query_cache_size                | 0                                         |
| query_cache_type                | ON                                        |
| query_cache_wlock_invalidate    | OFF                                       |
| query_prealloc_size             | 8192                                      |
| range_alloc_block_size          | 2048                                      |
| read_buffer_size                | 131072                                    |
| read_only                       | OFF                                       |
| read_rnd_buffer_size            | 262144                                    |
| relay_log_purge                 | ON                                        |
| relay_log_space_limit           | 0                                         |
| rpl_recovery_rank               | 0                                         |
| secure_auth                     | OFF                                       |
| server_id                       | 1                                         |
| skip_external_locking           | ON                                        |
| skip_networking                 | OFF                                       |
| skip_show_database              | OFF                                       |
| slave_compressed_protocol       | OFF                                       |
| slave_load_tmpdir               | /tmp/                                     |
| slave_net_timeout               | 3600                                      |
| slave_skip_errors               | OFF                                       |
| slave_transaction_retries       | 10                                        |
| slow_launch_time                | 2                                         |
| socket                          | /tmp/mysql.sock                           |
| sort_buffer_size                | 2097144                                   |
| sql_mode                        |                                           |
| sql_notes                       | ON                                        |
| sql_warnings                    | ON                                        |
| storage_engine                  | MyISAM                                    |
| sync_binlog                     | 0                                         |
| sync_frm                        | ON                                        |
| sync_replication                | 0                                         |
| sync_replication_slave_id       | 0                                         |
| sync_replication_timeout        | 10                                        |
| system_time_zone                | EST                                       |
| table_cache                     | 64                                        |
| table_lock_wait_timeout         | 50                                        |
| table_type                      | MyISAM                                    |
| thread_cache_size               | 0                                         |
| thread_stack                    | 196608                                    |
| time_format                     | %H:%i:%s                                  |
| time_zone                       | SYSTEM                                    |
| timed_mutexes                   | OFF                                       |
| tmp_table_size                  | 33554432                                  |
| tmpdir                          |                                           |
| transaction_alloc_block_size    | 8192                                      |
| transaction_prealloc_size       | 4096                                      |
| tx_isolation                    | REPEATABLE-READ                           |
| updatable_views_with_limit      | YES                                       |
| version                         | 5.1.2-alpha-log                           |
| version_comment                 | Source distribution                       |
| version_compile_machine         | i686                                      |
| version_compile_os              | suse-linux                                |
| wait_timeout                    | 28800                                     |
+---------------------------------+-------------------------------------------+
218 rows in set (0.03 sec)
此处描述了大多数系统变量。没有版本的变量在所有MySQL 5.1 发布中适用。关于其使用历史信息，请参见MySQL 5.0参考指南和MySQL 4.1参考指南。InnoDB系统变量列于 15.2.4节，“InnoDB启动选项”。
若没有另行规定，缓冲区大小、长度和堆栈大小的单位均为字节。
关于这些变量的调节信息参见7.5.2节，“调节服务器参数”。
·         auto_increment_increment
auto_increment_increment和auto_increment_offset用于主服务器－主服务器（master-to-master）复制，并可以用来控制AUTO_INCREMENT列的操作。两个变量均可以设置为全局或局部变量，并且假定每个值都可以为1到65,535之间的整数值。将其中一个变量设置为0会使该变量为1。如果试图将这些变量设置为大于65,535或小于0的值，则会将该值设置为65,535。如果向将auto_increment_increment或auto_increment_offset设置为非整数值，则会给出错误，并且变量的实际值在这种情况下保持不变。
这两个变量影响AUTO_INCREMENT列的方式：
o        auto_increment_increment控制列中的值的增量值。例如: 
o                       mysql> SHOW VARIABLES LIKE 'auto_inc%';
o                       +--------------------------+-------+
o                       | Variable_name            | Value |
o                       +--------------------------+-------+
o                       | auto_increment_increment | 1     |
o                       | auto_increment_offset    | 1     |
o                       +--------------------------+-------+
o                       2 rows in set (0.00 sec)
o                      
o                       mysql> CREATE TABLE autoinc1 (col INT NOT NULL AUTO_INCREMENT PRIMARY KEY);
o                       Query OK, 0 rows affected (0.04 sec)
o                      
o                       mysql> SET @auto_increment_increment=10;
o                       Query OK, 0 rows affected (0.00 sec)
o                      
o                       mysql> SHOW VARIABLES LIKE 'auto_inc%';
o                       +--------------------------+-------+
o                       | Variable_name            | Value |
o                       +--------------------------+-------+
o                       | auto_increment_increment | 10    |
o                       | auto_increment_offset    | 1     |
o                       +--------------------------+-------+
o                       2 rows in set (0.01 sec)
o                      
o                       mysql> INSERT INTO autoinc1 VALUES (NULL), (NULL), (NULL), (NULL);
o                       Query OK, 4 rows affected (0.00 sec)
o                       Records: 4  Duplicates: 0  Warnings: 0
o                      
o                       mysql> SELECT col FROM autoinc1;
o                       +-----+
o                       | col |
o                       +-----+
o                       |   1 |
o                       |  11 |
o                       |  21 |
o                       |  31 |
o                       +-----+
o                       4 rows in set (0.00 sec)
(注明如何使用SHOW VARIABLES来获取这些变量的当前值）。
o        auto_increment_offset确定AUTO_INCREMENT列值的起点。假定在与前面的例子的相同的会话中执行下面的命令：
o                       mysql> SET @auto_increment_offset=5;
o                       Query OK, 0 rows affected (0.00 sec)
o                      
o                       mysql> SHOW VARIABLES LIKE 'auto_inc%';
o                       +--------------------------+-------+
o                       | Variable_name            | Value |
o                       +--------------------------+-------+
o                       | auto_increment_increment | 10    |
o                       | auto_increment_offset    | 5     |
o                       +--------------------------+-------+
o                       2 rows in set (0.00 sec)
o                      
o                       mysql> CREATE TABLE autoinc2 (col INT NOT NULL AUTO_INCREMENT PRIMARY KEY);
o                       Query OK, 0 rows affected (0.06 sec)
o                      
o                       mysql> INSERT INTO autoinc2 VALUES (NULL), (NULL), (NULL), (NULL);
o                       Query OK, 4 rows affected (0.00 sec)
o                       Records: 4  Duplicates: 0  Warnings: 0
o                      
o                       mysql> SELECT col FROM autoinc2;
o                       +-----+
o                       | col |
o                       +-----+
o                       |   5 |
o                       |  15 |
o                       |  25 |
o                       |  35 |
o                       +-----+
o                       4 rows in set (0.02 sec)
o                      
如果auto_increment_offset的值大于auto_increment_increment的值，则auto_increment_offset的值被忽略。
如果其中一个或两个变量被更改了，然后更改插入到包含AUTO_INCREMENT列的表中的新行，结果可能看上去有问题，由于计算AUTO_INCREMENT系列值时没有考虑列内已经存在的值，并且插入的下一个值是列内最小的值，大于AUTO_INCREMENT列内已有的最大值。换句话说，数值的计算方法为：
auto_increment_offset+ N * auto_increment_increment
其中N为系列内的正整数值[1,2,3,...]。例如：
mysql> SHOW VARIABLES LIKE 'auto_inc%';
+--------------------------+-------+
| Variable_name            | Value |
+--------------------------+-------+
| auto_increment_increment | 10    |
| auto_increment_offset    | 5     |
+--------------------------+-------+
2 rows in set (0.00 sec)
 
mysql> SELECT col FROM autoinc1;
+-----+
| col |
+-----+
|   1 |
|  11 |
|  21 |
|  31 |
+-----+
4 rows in set (0.00 sec)
 
mysql> INSERT INTO autoinc1 VALUES (NULL), (NULL), (NULL), (NULL);
Query OK, 4 rows affected (0.00 sec)
Records: 4  Duplicates: 0  Warnings: 0
 
mysql> SELECT col FROM autoinc1;
+-----+
| col |
+-----+
|   1 |
|  11 |
|  21 |
|  31 |
|  35 |
|  45 |
|  55 |
|  65 |
+-----+
8 rows in set (0.00 sec)
auto_increment_increment和auto_increment_offset所示的值可以生成系列5 + N * 10,即，[5,15,25,35,45,...]。在INSERT前col 列内最大的值为31,AUTO_INCREMENT数列的下一个值为35,因此col中插入的值从该点开始，结果如SELECT查询所示。
一定要记住不可能将这两个变量的结果限制到一个表中，因此不会替代其它数据库管理系统提供的序列；这些变量控制MySQL服务器上all表AUTO_INCREMENT列的所有行为。如果某个变量设为全局变量，则只有通过局部设置将全局值更改和覆盖后或mysqld重启后其作用方可改变；如果局部设置，则新值影响所有表的AUTO_INCREMENT列，在这个会话期间当前用户在这些表中插入了新行，除非在会话期间更改了这些值。
auto_increment_increment的 默认值为1。参见6.12节，“多服务器复制中的Auto-Increment”。
·         auto_increment_offset
该变量的默认值为1。详见auto_increment_increment的描述。
·         back_log
MySQL有的主要连接请求的数量。当主MySQL线程在短时间内得到许多连接请求时发挥作用。主线程需要花一些时间(尽管很少)来检查连接并启动一个新线程。back_log值说明MySQL临时停止响应新请求前在短时间内可以堆起多少请求。如果你需要在短时间内允许大量连接，可以增加该数值。
换句话说，该值为“进”TCP/IP连接帧听队列的大小。操作系统有该队列自己的限制值。本手册中Unix listen()系统调用页应有更详细的信息。该变量最大值请查阅OS文档。企图将back_log设置为高于你的操作系统限值是徒劳无益的。
·         basedir
MySQL安装基准目录。可以用--basedir选项设置该变量。
·         bdb_cache_size
为BDB表缓存索引和行分配的缓冲区的大小。如果你不使用BDB表，你应用--skip-bdb启动mysqld以便不浪费该缓存。
·         bdb_home
BDB表基准目录。应与datadir变量的值相同。
·         bdb_log_buffer_size
为BDB表缓存索引和行分配的缓冲区的大小。如果你不使用BDB表，你应将该值设置为0或用--skip-bdb启动mysqld以便不浪费该缓存。
·         bdb_logdir
BDB存储引擎写它日志文件的目录。可以用--bdb-logdir选项设置该变量。
·         bdb_max_lock
在BDB表下可以激活的最大锁数(默认为10,000)。如果当你执行长事务或当mysqld必须检查许多行来计算查询时出现下面的错误，你应增加该值：
bdb: Lock table is out of available locks
Got error 12 from ...
·         bdb_shared_data
如果你正使用--bdb-shared-data应为ON。
·         bdb_tmpdir
--bdb-tmpdir选项的值。
 
·         binlog_cache_size
在事务过程中容纳二进制日志SQL语句的缓存大小。二进制日志缓存是服务器支持事务存储引擎并且服务器启用了二进制日志(--log-bin选项)的前提下为每个客户端分配的内存。如果你经常使用大的，多语句事务，你可以增加该值以获得更有的性能。Binlog_cache_use和Binlog_cache_disk_use状态变量可以用来调整该变量的大小。参见5.11.3节，“二进制日志”。
·         bulk_insert_buffer_size
MyISAM 使用专用树状缓存来使INSERT ... SELECT、INSERT ... VALUES (...)、(...)、 ...和LOAD DATA INFILE的大块插入更快。该变量用每线程的字节数限制缓存树的大小。将它设置为0禁用优化。注释：只有向非空表添加数据时才使用该缓存。 默认值是8MB。
·         character_set_client
来自客户端的语句的字符集。
·         character_set_connection
用于没有字符集导入符的文字和数字－字符串转换。
·         character_set_database
默认数据库使用的字符集。当默认数据库更改时，服务器则设置该变量。如果没有默认数据库，变量的值同character_set_server。
·         character_set_results
用于向客户端返回查询结果的字符集。
·         character_set_ server
服务器的默认字符集。
·         character_set_system
服务器用来保存识别符的字符集。该值一定是utf8。
·         character_sets_dir
字符集安装目录。
·         collation_connection
连接字符集的校对规则。
·         collation_database
默认数据库使用的校对规则。当默认数据库改变时服务器则设置该变量。如果没有默认数据库，变量的值同collation_server。
·         collation_server
服务器的默认校对规则。
·         completion_type
事务结束类型：
o        如果该值为0(默认)，COMMIT和ROLLBACK不受影响。
o        如果该值为1，COMMIT和ROLLBACK分别等同于COMMIT AND CHAIN和ROLLBACK AND CHAIN。(新事务用刚刚结束的事务相同的间隔等级立即启动）。 
o        如果该值为2，COMMIT和ROLLBACK分别等同于COMM它RELEASE和ROLLBACK RELEASE。(事务终止后，服务器断开）。 
·         concurrent_insert
如果为ON(默认值)，MySQL允许INSERT和SELECT语句在中间没有空数据块的MyISAM表中并行运行。你可以用--safe或--skip-new启动mysqld关闭该选项。
该变量为整数，有3个值：
值
描述
0
关
1
(默认)在没有空数据块的MyISAM表中启用并行插入
2
为所有MyISAM表启用并行插入。如果表有空记录或正被另一线程使用，新行将插入到表的最后。如果表未使用，MySQL将进行普通读锁定并将新行插入空记录。
·         connect_timeout
mysqld服务器用Bad handshake响应前等待连接包的秒数。
·         datadir
MySQL数据目录。可以用--datadir选项设置该变量。
·         date_format
该变量未使用。
·         datetime_format
该变量未使用。
·         default_week_format
WEEK() 函数使用的默认模式。
·         delay_key_write
该选项只适用MyISAM表。它具有下述值可以影响CREATE TABLE语句使用的DELAY_KEY_WRITE表选项的处理。
选项
描述
OFF
DELAY_KEY_WRITE被忽略。
ON
MySQL在CREATE TABLE中用DELAY_KEY_WRITE选项。这是 默认值。
ALL
用启用DELAY_KEY_WRITE选项创建表的相同方法对所有新打开表的进行处理。
如果启用了DELAY_KEY_WRITE，说明使用该项的表的键缓冲区在每次更新索引时不被清空，只有关闭表时才清空。遮掩盖可以大大加快键的写操作，但如果你使用该特性，你应用--myisam-recover选项启动服务器，为所有MyISAM表添加自动检查(例如，--myisam-recover=BACKUP,FORCE)。参见5.3.1节，“mysqld命令行选项”和15.1.1节，“MyISAM启动选项”。
请注意--external-locking不为使用延迟键写入的表提供索引破坏保护。
·         delayed_insert_limit
插入delayed_insert_limit 延迟行后，INSERT DELAYED 处理器线程检查是否有挂起的SELECT语句。如果有，在继续插入延迟的行之前，允许它们先执行。
·         delayed_insert_timeout
INSERT DELAYED处理器线程终止前应等待INSERT语句的时间。
·         delayed_queue_size
这是各个表中处理INSERT DELAYED语句时队列中行的数量限制。如果队列满了，执行INSERT DELAYED语句的客户端应等待直到队列内再有空间。
·         div_precision_increment
该变量说明用/操作符执行除操作的结果可增加的精确度的位数。 默认值是4。最小和最大值分别为0和30。下面的示例说明了增加 默认值的结果。
mysql> SELECT 1/7;
+--------+
| 1/7    |
+--------+
| 0.1429 |
+--------+
mysql> SET div_precision_increment = 12;
mysql> SELECT 1/7;
+----------------+
| 1/7            |
+----------------+
| 0.142857142857 |
+----------------+
·         engine_condition_pushdown
该变量适用于NDB。默认值为0(OFF)：如果你执行类似查询SELECT * FROM t WHERE mycol = 42，其中mycol为没有索引的列，当满了的表扫描每个NDB节点时，执行该查询。每个节点使用WHERE条件将每一行发送给MySQL服务器。如果engine_condition_pushdown被设置为1(ON)，该条件“pushed down”给存储引擎并发送给NDB节点。每个节点都执行扫描，并只向MySQL服务器发送回匹配条件的行。
·         expire_logs_days
二进制日志自动删除的天数。默认值为0,表示“没有自动删除”。启动时和二进制日志循环时可能删除。
·         flush
如果用--flush选项启动mysqld该值为ON。
·         flush_time
如果设为非零值，每隔flush_time秒则关闭所有表以释放硬盘资源并同步未清空的数据。我们建议只在Windows 9x或Me，或有最小资源的系统中使用该选项。
·         ft_boolean_syntax
使用IN BOOLEAN MODE执行的布尔全文搜索支持的操作符系列。参见12.7.1节，“布尔全文搜索”。
默认变量值为 '+ -><()~*:""&|'。更改这些值的规则是：
o        操作符函数由其在字符串内的位置决定。
o        替换值必须是14个字符。
o        每个字符必须为ASCII码非文字数字字符。
o        第1个或第2个字符必须为空格。
o        除非语句在第11个字符和第12个字符处引用了操作符，否则不允许复制。这两个字符可以不相同，但这是唯一可能的两个。
o        位置10、13和14(默认设置为‘:’、‘&’和‘|’)保留用于将来扩展。
·         ft_max_word_len
FULLTEXT索引中所包含的字的最大长度。
注释：更改该变量后必须重建FULLTEXT索引。应使用REPAIR TABLE tbl_name QUICK。
·         ft_min_word_len
FULLTEXT索引中所包含的字的最小长度。
注释：更改该变量后必须重建FULLTEXT索引。应使用REPAIR TABLE tbl_name QUICK。
·         ft_query_expansion_limit
使用WITH QUERY EXPANSION进行全文搜索的最大匹配数。
·         ft_stopword_file
用于读取全文搜索的停止字清单的文件。该文件中的所有字都会用到；注释不重要。默认情况下，使用内嵌式停止字清单(如myisam/ft_static.c文件中所定义)。将该变量设置为空字符串('')则禁用停止字过滤。
注释：更改该变量或停止字文件的内容后必须重建FULLTEXT索引。应使用REPAIR TABLE tbl_name QUICK。
·         group_concat_max_len
允许的GROUP_CONCAT()函数结果的最大长度。
·         have_archive
如果mysqld支持ARCHIVE表则为YES，否则为NO。
·         have_bdb
如果mysqld支持BDB表则为YES。如果使用--skip-bdb则为DISABLED。
·         have_blackhole_engine
如果mysqld支持BLACKHOLE表则为YES，否则为NO。
·         have_compress
是否zlib压缩库适合该服务器。如果不适合，不能使用COMPRESS()和UNCOMPRESS()函数。
·         have_crypt
是否crypt()系统调用适合该服务器。如果不适合，不能使用CRYPT()函数。
·         have_csv
如果mysqld支持ARCHIVE表则为YES，否则为NO。
·         have_example_engine
如果mysqld支持EXAMPLE表则为YES，否则为NO。
have_federated_engine
如果mysqld支持FEDERATED表则为YES，否则为NO。
·         have_geometry
是否服务器支持空间数据类型。
·         have_innodb
如果mysqld支持InnoDB表则为YES。如果使用--skip-innodb则为DISABLED。
·         have_isam
在MySQL 5.1中,只是为了向后兼容显示该值，并且总是NO，因为不再支持ISAM表。
·         have_ndbcluster
如果mysqld支持NDB CLUSTER表则为YES。如果使用了--skip-ndbcluster则为DISABLED。
·         have_partition_engine
如果mysqld支持分区则为YES。在MySQL 5.1.1中加入。
·         have_openssl
如果mysqld支持客户端/服务器协议的SSL(加密)则为YES。
·         have_query_cache
如果mysqld支持查询缓存则为YES。
·         have_raid
如果mysqld支持RAID选项则为YES。
·         have_rtree_keys
RTREE索引是否可用。(用于MyISAM表的空间索引）。 
·         have_symlink
是否启用符号链接支持。在Unix中需要用于支持DATA DIRECTORY和INDEX DIRECTORY表选项。
·         init_connect
服务器为每个连接的客户端执行的字符串。字符串由一个或多个SQL语句组成。要想指定多个语句，用分号间隔开。例如，每个客户端开始时默认启用autocommit模式。没有全局服务器变量可以规定autocommit默认情况下应禁用，但可以用init_connect来获得相同的效果：
SET GLOBAL init_connect='SET AUTOCOMMIT=0';
还可以在命令行或选项文件中设置该变量。要想使用选项文件设置变量，应包括下述行：
[mysqld]
init_connect='SET AUTOCOMMIT=0'
请注意init_connect的内容并不为拥有SUPER权限的用户执行；实际是内容设置错误(包含错误查询，例如语法错误)，这样使所有连接失败。不为SUPER用户执行，使SUPER用户可以打开连接并固定init_connect。
·         init_file
启动服务器时用--init-file选项指定的文件名。文件中包含服务器启动时要执行的SQL语句。每个语句必须在同一行中并且不能包括注释。
·         init_slave
该变量类似init_connect，但是每次SQL线程启动时从服务器应执行该字符串。该字符串的格式与init_connect变量相同。
·         innodb_xxx
InnoDB系统变量列入15.2.4节，“InnoDB启动选项”。
·         interactive_timeout
服务器关闭交互式连接前等待活动的秒数。交互式客户端定义为在mysql_real_connect()中使用CLIENT_INTERACTIVE选项的客户端。又见wait_timeout。
·         join_buffer_size
用于完全联接的缓冲区的大小(当不使用索引的时候使用联接操作)。一般情况获得快速联接的最好方法是添加索引。当增加索引时不可能通过增加join_buffer_size值来获得快速完全联接。将为两个表之间的每个完全联接分配联接缓冲区。对于多个表之间不使用索引的复杂联接，需要多联接缓冲区。
·         key_buffer_size
MyISAM表的索引块分配了缓冲区，由所有线程共享。key_buffer_size是索引块缓冲区的大小。键值缓冲区即为键值缓存。
key_buffer_size的最大允许设定值为4GB。有效最大值可以更小，取决于可用物理RAM和操作系统或硬件平台强加的每个进程的RAM限制。
增加该值，达到你可以提供的更好的索引处理(所有读和多个写操作)。通常为主要运行MySQL的机器内存的25%。但是，如果你将该值设得过大(例如，大于总内存的50%)，系统将转换为页并变得极慢。MySQL依赖操作系统来执行数据读取时的文件系统缓存，因此你必须为文件系统缓存留一些空间。
同时写多行时要想速度更快，应使用LOCK TABLES。参见13.4.5节，“LOCK TABLES和UNLOCK TABLES语法”。
你可以通过执行SHOW STATUS语句并检查Key_read_requests、Key_reads、Key_write_requests和Key_writes状态变量来检查键值缓冲区的性能。参见13.5.4节，“SHOW语法”。
Key_reads/Key_read_requests比例一般应小于0.01。如果你使用更新和删除，Key_writes/Key_write_requests比例通常接近1，但如果你更新时会同时影响到多行或如果你正使用DELAY_KEY_WRITE表选项，可能小得多。
用key_buffer_size结合Key_blocks_unused状态变量和缓冲区块大小，可以确定使用的键值缓冲区的比例。从key_cache_block_size服务器变量可以获得缓冲区块大小。使用的缓冲区的比例为：
1 - ((Key_blocks_unused * key_cache_block_size) / key_buffer_size)
该值为约数，因为键值缓冲区的部分空间被分配用作内部管理结构。
可以创建多个MyISAM键值缓存。4GB限制可以适合每个缓存，而不是一个组。参见7.4.6节，“MyISAM键高速缓冲”。
·         key_cache_age_threshold
该值控制将缓冲区从键值缓存热子链(sub-chain)降级到温子链(sub-chain)。如果值更低，则降级更快。最小值为100。 默认值是300。参见7.4.6节，“MyISAM键高速缓冲”。
·         key_cache_block_size
键值缓存内块的字节大小。默认值是1024。参见7.4.6节，“MyISAM键高速缓冲”。
·         key_cache_division_limit
键值缓存缓冲区链热子链和温子链的划分点。该值为缓冲区链用于温子链的百分比。允许的值的范围为1到100。 默认值是100。参见7.4.6节，“MyISAM键高速缓冲”。
·         language
错误消息所用语言。
·          large_file_support
mysqld编译时是否使用了大文件支持选项。
·         large_pages
说明是否启用了大页面支持。
·         license
服务器的许可类型。
·         local_infile
是否LOCAL支持LOAD DATA INFILE语句。
·         locked_in_memory
是否用–memlock将mysqld锁在内存中。
·         log
是否启用将所有查询记录到常规查询日志中。参见5.11.2节，“通用查询日志”。
·         log_bin
是否启用二进制日志。参见5.11.3节，“二进制日志”。
·         log_bin_trust_routine_creators
若启用了二进制记录，则该变量适用。它控制是否可以信任保存的程序的作者不会创建向二进制日志写入不安全事件的程序。如果设置为0(默认情况)，不允许用户创建或修改保存的程序，除非他们不仅拥有CREATE ROUTINE或ALTER ROUTINE权限还拥有SUPER权限。
设置为0还强制限制，程序必须用DETERMINISTIC 特征或用READS SQL DATA或NO SQL特征声明。如果变量设置为1,MySQL不对保存程序的创建强加限制。
参见20.4节，“存储子程序和触发程序的二进制日志功能”。
·         log_error
错误日志的位置。
·         log_slave_updates
是否从服务器从主服务器收到的更新应记入从服务器自己的二进制日志。要想生效，必须启用从服务器的二进制记录。参见6.8节，“复制启动选项”。
·         log_slow_queries
是否记录慢查询。用long_query_time变量的值来确定“慢查询”。参见5.11.4节，“慢速查询日志”。
·         log_warnings
是否产生其它警告消息。默认情况下启用。放弃的连接不记入错误日志，除非值大于1。
·         long_query_time
如果查询时间超过该值，则增加Slow_queries状态变量。如果你正使用--log-slow-queries选项，则查询记入慢查询日志文件。用实际时间测量该值，而不是CPU时间，因此低于轻负载系统阈值的查询可能超过重负载系统的阈值。参见5.11.4节，“慢速查询日志”。
·         low_priority_updates
如果设置为1，所有INSERT、UPDATE、DELETE和LOCK TABLE WRITE语句将等待直到受影响的表没有挂起的SELECT或LOCK TABLE READ。该变量以前叫做sql_low_priority_updates。
·         lower_case_file_system
该变量说明是否数据目录所在的文件系统对文件名的大小写敏感。ON说明对文件名的大小写不敏感，OFF表示敏感。
·           lower_case_table_names
如果设置为1,表名用小写保存到硬盘上，并且表名比较时不对大小写敏感。如果设置为2，按照指定的保存表名，但按照小写来比较。该选项还适合数据库名和表的别名。参见9.2.2节，“识别符大小写敏感性”。
如果你正使用InnoDB表，你应在所有平台上将该变量设置为1，强制将名字转换为小写。
如果运行MySQL的系统对文件名的大小写不敏感(例如Windows或Mac OS X)，你不应将该变量设置为0。如果启动时没有设置该变量，并且数据目录所在文件系统对文件名的大小写不敏感，MySQL自动将lower_case_table_names设置为2。
·         max_allowed_packet
包或任何生成的/中间字符串的最大大小。
包消息缓冲区初始化为net_buffer_length字节，但需要时可以增长到max_allowed_packet字节。该值默认很小，以捕获大的(可能是错误的)数据包。
如果你使用大的BLOB 列或长字符串，你必须增加该值。应同你想要使用的最大的BLOB一样大。max_allowed_packet的协议限制为1GB。
·         max_binlog_cache_size
如果多语句事务需要更大的内存，你会得到错误Multi-statement transaction required more than 'max_binlog_cache_size' bytes of storage。
·         max_binlog_size
如果二进制日志写入的内容超出给定值，日志就会发生滚动。你不能将该变量设置为大于1GB或小于4096字节。 默认值是1GB。
请注意如果你正使用事务：事务以一个块写入二进制日志，因此不不能被几个二进制日志拆分。因此，如果你有大的事务，二进制日志可能会大于max_binlog_size。
如果max_relay_log_size为0, max_binlog_size的值也适用于中继日志。
·         max_connect_errors
如果中断的与主机的连接超过该数目，该主机则阻塞后面的连接。你可以用 FLUSH HOSTS语句解锁锁定的主机。
·         max_connections
允许的并行客户端连接数目。增大该值则增加mysqld 需要的文件描述符的数量。关于文件描述符限制的注释参见7.4.9节，“MySQL如何打开和关闭表”。还可参见A.2.6节，“连接数过多”。
·         max_delayed_threads
不要启动大于该数目的线程来处理INSERT DELAYED语句。如果所有INSERT DELAYED线程已经在使用，你想在新表中插入数据，行 插入时好像未指定DELAYED属性。如果你将该值设置为0,MySQL不会创建线程来处理DELAYED行；其结果是完全禁用了DELAYED。
·         max_error_count
保存由SHOW ERRORS或SHOW WARNINGS显示的错误、警告和注解的最大数目。
·         max_heap_table_size
该变量设置MEMORY (HEAP)表可以增长到的最大空间大小。该变量用来计算MEMORY表的MAX_ROWS值。在已有的MEMORY表上设置该变量没有效果，除非用CREATE TABLE或TRUNCATE TABLE等语句重新创建表。
·         max_insert_delayed_threads
该变量为max_delayed_threads的同义词。
·         max_join_size
不允许可能需要检查多于max_join_size行(为单个表语句)或行组合(为多个表语句)或可能执行大于max_join_size次硬盘查询的SELECT语句。通过设置该值，你可以捕获键使用不正确并可能花很长时间的SELECT语句。如果用户想要执行没有WHERE子句的花较长时间或返回数百万行的联接，则设置它。
将该变量设置为DEFAULT之外的值，将SQL_BIG_SELECTS的值重设为0。如果你重新设置SQL_BIG_SELECTS值，max_join_size变量被忽略。
如果查询结果位于查询缓存中，则不检查结果大小，因为前面已经计算了结果，不会要求服务器将它发送给客户端。
该变量以前叫做sql_max_join_size。
·         max_length_for_sort_data
确定使用的filesort算法的索引值大小的限值。参见7.2.12节，“MySQL如何优化ORDER BY”。
·         max_relay_log_size
如果复制从服务器写入中继日志时超出给定值，则滚动中继日志。通过该变量你可以对中继日志和二进制日志设置不同的限制。但是，将该变量设置为0，MySQL可以对二进制日志和中继日志使用max_binlog_size。max_relay_log_size必须设置在4096字节和1GB(包括)之间，或为0。 默认值是0。参见6.3节，“复制实施细节”。
·         max_seeks_for_key
限制根据键值寻找行时的最大搜索数。MySQL优化器假定当用扫描键在表内搜索匹配的行时，不需要超过该数量的键值搜索，而不管键的实际基数是什么(参见13.5.4.11节，“SHOW INDEX语法”)。将该值设置为较低的值(100?)，你可以强制MySQL选择键值而不选择表扫描。
·         max_sort_length
当排序BLOB或TEXT值时使用的字节数。只使用每个值的前max_sort_length字节；其它的被忽略。
·         max_tmp_tables
客户端可以同时打开的临时表的最大数。(但该选项还未生效）。 
·         max_user_connections
任何给定的MySQL账户允许的最大同时连接数。0值表示“没有限制”。
该变量具有全局范围和(只读)会话范围。会话变量的的值与全局变量的值相同，除非当前账户具有非零MAX_USER_CONNECTIONS资源限制。在这种情况下，会话值反应了账户限制。
·         max_write_lock_count
超过写锁定限制后，允许部分读锁定。
·         myisam_data_pointer_size
默认指针大小，单位是字节，当未指定MAX_ROWS选项时，CREATE TABLE使用该变量创建MyISAM表。该变量不能小于2或大于7。 默认值是6。参见A.2.11节，“表已满”。
·         (DEPRECATED) myisam_max_extra_sort_file_size
注释：MySQL 5.1不支持该变量。详细信息参见MySQL 5.0 参考手册。
·         myisam_max_sort_file_size
重建MyISAM索引(在REPAIR TABLE、ALTER TABLE或LOAD DATA INFILE过程中)时，允许MySQL使用的临时文件的最大空间大小。如果文件的大小超过该值，则使用键值缓存创建索引，要慢得多。该值的单位为字节。
·         myisam_recover_options
--myisam-recover选项的值。
·         myisam_repair_threads
如果该值大于1，在Repair by sorting过程中并行创建MyISAM表索引(每个索引在自己的线程内)。 默认值是1。注释：多线程维护仍然是alpha 编码。
·         myisam_sort_buffer_size
当在REPAIR TABLE或用CREATE INDEX创建索引或ALTER TABLE过程中排序 MyISAM索引分配的缓冲区。
·         myisam_stats_method
当为MyISAM表搜集关于索引值分发的统计信息时服务器如何处理NULL值。该变量有两个可能的值，nulls_equal和nulls_unequal。对于nulls_equal，认为所有NULL索引值时相等的，并形成一个数值组，其空间大小等于NULL值的数。对于nulls_unequal，NULL值认为是不相等的，每个NULL形成一个数值组，大小为1。
方法用于生成表统计信息，影响优化器如何选择索引来执行查询，详细描述见7.4.7节，“MyISAM索引统计集合”。
·         multi_read_range
指定范围选择过程中发送到存储引擎的范围的最大值。默认值是256。向引擎发送多个范围可以大大改进某些选择的性能，特别是对NDBCLUSTER。该引擎需要向所有节点发送范围请求，同时发送许多请求可以大大降低通信成本。
·         named_pipe
(只适用Windows)说明服务器是否支持命名管道连接。
·         net_buffer_length
在查询之间将通信缓冲区重设为该值。一般情况不应改变，但如果内存很小，可以将它设置为期望的客户端发送的SQL语句的长度。如果语句超出该长度，缓冲区自动扩大，直到max_allowed_packet字节。
·         net_read_timeout
中断读前等待连接的其它数据的秒数。当服务器从客户端读数时，net_read_timeout指控制何时中断的超时值。当服务器向客户端写时，net_write_timeout指控制何时中断的超时值。又见slave_net_timeout。
·         net_retry_count
如果某个通信端口的读操作中断了，在放弃前重试多次。在FreeBSD中该值应设得很高，因为内部中断将发送至所有线程。
·         net_write_timeout
中断写之前等待块写入连接的秒数。又见net_read_timeout。
·         new
在MySQL 4.0中使用该变量来打开4.1中的一些行为，并用于向后兼容性。在MySQL 5.1中,它的值一直是OFF.
·         old_passwords
是否服务器应为MySQL用户账户使用pre-4.1-style密码。参见A.2.3节，“客户端不支持鉴定协议”。
·         one_shot
这不是一个变量，但当设置变量是可以使用它。其描述见13.5.3节，“SET语法”。
·         one_shot
这不是一个变量，但当设置变量是可以使用它。其描述见13.5.3节，“SET语法”。
·         open_files_limit
操作系统允许mysqld打开的文件的数量。这是系统允许的实际值，可能与你在启动选项中赋给mysqld的值不同。若在系统中MySQL不能更改打开的文件的数量，则该值为0。
·         optimizer_prune_level
在查询优化从优化器搜索空间裁减低希望局部计划中使用的控制方法。0值禁用该方法，以便优化器进行穷举搜索。值为1使优化器根据中间方案中得出的行数来裁减方案。
·         optimizer_search_depth 
查询优化器进行的搜索的最大深度。如果值大于查询中的关系数则查询方案比较佳，但生成查询执行方案需要的时间更长。值大于查询中的关系数则返回的执行方案更快，但方案远没有优化。如果设置为0, 系统自动选择合理的值。如果设置为查询中使用的表的最大数加2,优化器转换为MySQL 5.0.0(和以前的版本)中使用的算法并搜索。
·         pid_file
进程ID (PID)文件的路径名。可以用--pid-file选项设置该变量。
·         plugin_dir
插件目录的路径。在MySQL 5.1.2中加入了该变量。
·         port
服务器帧听TCP/IP连接所用端口。可以用--port选项设置该变量。
·         preload_buffer_size
重载索引时分配的缓冲区大小。
·         protocol_version
MySQL服务器使用的客户端/服务器协议的版本。
·         query_alloc_block_size
为查询分析和执行过程中创建的对象分配的内存块大小。如果内存分段过程中遇到问题，将该变量增加一位会有帮助。
·         query_cache_limit
不要缓存大于该值的结果。默认值是1048576(1MB)。
·         query_cache_min_res_unit
查询缓存分配的最小块的大小(字节)。 默认值是4096(4KB)。关于该变量的调节信息参见5.13.3节，“查询高速缓冲配置”。
·         query_cache_size
为缓存查询结果分配的内存的数量。默认值是0，即禁用查询缓存。请注意即使query_cache_type设置为0也将分配此数量的内存。详细信息参见5.13.3节，“查询高速缓冲配置”。
·         query_cache_type
设置查询缓存类型。设置GLOBAL值可以设置后面的所有客户端连接的类型。客户端可以设置SESSION值以影响他们自己对查询缓存的使用。下面的表显示了可能的值：
选项
描述
0或OFF
不要缓存或查询结果。请注意这样不会取消分配的查询缓存区。要想取消，你应将query_cache_size设置为0。
1或ON
缓存除了以SELECT SQL_NO_CACHE开头的所有查询结果。
2或DEMAND
只缓存以SELECT SQL_NO_CACHE开头的查询结果。
该变量默认设为ON。
·         query_cache_wlock_invalidate
一般情况，当客户端对MyISAM表进行WRITE锁定时，如果查询结果位于查询缓存中，则其它客户端未被锁定，可以对该表进行查询。将该变量设置为1，则可以对表进行WRITE锁定，使查询缓存内所有对该表进行的查询变得非法。这样当锁定生效时，可以强制其它试图访问表的客户端来等待。
·         query_prealloc_size
用于查询分析和执行的固定缓冲区的大小。在查询之间该缓冲区不释放。如果你执行复杂查询，分配更大的query_prealloc_size值可以帮助提高性能，因为它可以降低查询过程中服务器分配内存的需求。
·         range_alloc_block_size
范围优化时分配的块的大小。
·         read_buffer_size
每个线程连续扫描时为扫描的每个表分配的缓冲区的大小(字节)。如果进行多次连续扫描，可能需要增加该值， 默认值为131072。
·         read_only
当变量对复制从服务器设置为ON时，从服务器不允许更新，除非通过从服务器的线程或用户拥有SUPER权限。可以确保从服务器不接受客户端的更新命令。
·         relay_log_purge
当不再需要中继日志时禁用或启用自动清空中继日志。默认值是1(启用)。
·         read_rnd_buffer_size
当排序后按排序后的顺序读取行时，则通过该缓冲区读取行，避免搜索硬盘。将该变量设置为较大的值可以大大改进ORDER BY的性能。但是，这是为每个客户端分配的缓冲区，因此你不应将全局变量设置为较大的值。相反，只为需要运行大查询的客户端更改会话变量。
·         secure_auth
如果用--secure-auth选项启动了MySQL服务器，它将阻塞有旧格式(4.1之前)密码的所有账户所发起的连接。在这种情况下，该变量的值为ON，否则为OFF。
如果你想要防止使用旧格式的密码(致使网络通信不安全)，你应启用该选项。
如果启用该选项并且授权表为pre-4.1格式，服务器启动失败并且会出现错误。参见A.2.3节，“客户端不支持鉴定协议”。
当用于客户端选项时，如果服务器需要该客户端账户的旧格式的密码，则客户端拒绝连接该服务器。
·         server_id
--server-id选项的值。用于主复制服务器和从复制服务器。
·         shared_memory
(只用于Windows)服务器是否允许共享内存连接。
·         shared_memory_base_name
(只用于Windows)说明服务器是否允许共享内存连接，并为共享内存设置识别符。当在单台机器上运行多个MySQL实例时很有用。
·         skip_external_locking
如果mysqld使用外部锁定，该值为OFF。
·         skip_networking
如果服务器只允许本地(非TCP/IP)连接，该值为ON。在Unix中，本地连接使用Unix套接字文件。在Windows中，本地连接使用命名管道或共享内存。在NetWare中，只支持TCP/IP连接，因此不要将该变量设置为ON。
·         skip_show_database
防止不具有SHOW DATABASES权限的人们使用SHOW DATABASES语句。如果你担心用户能够看见属于其它用户的数据库，这样设置可以提高安全性。其效果取决于SHOW DATABASES权限：如果变量值为ON，只允许具有SHOW DATABASES权限的人们使用SHOW DATABASES 语句，并且该语句将显示所有数据库名。如果值为OFF，允许所有用户执行SHOW DATABASES，但只显示用户具有SHOW DATABASES或其它权限的数据库的名称。
·         slave_compressed_protocol
如果主、从服务器均支持，确定是否使用从/主压缩协议。
·         slave_load_tmpdir
从服务器为复制LOAD DATA INFILE语句创建临时文件的目录名。
·         slave_net_timeout
放弃读操作前等待主/从连接的更多数据的等待秒数。
·         slave_skip_errors
从服务器应跳过(忽视)的复制错误。
·         slave_transaction_retries
如果由于ofInnoDB死锁或超过InnoDB的innodb_lock_wait_timeout或NDBCLUSTER的TransactionDeadlockDetectionTimeout或TransactionInactiveTimeout，复制从服务器SQL线程未能执行事务，在提示错误并停止前它自动重复slave_transaction_retries次。 默认值是10。
·         slow_launch_time
如果创建线程的时间超过该秒数，服务器增加Slow_launch_threads状态变量。
·         socket
Unix平台：用于本地客户端连接的套接字文件。默认为/var/lib/mysql/mysql.sock。
Windows：用于本地客户端连接的命名管道名。默认为mysql。
·         sort_buffer_size
每个排序线程分配的缓冲区的大小。增加该值可以加快ORDER BY或GROUP BY操作。参见A.4.4节，“MySQL将临时文件储存在哪里”。
·         sql_mode
当前的服务器SQL模式，可以动态设置。参见5.3.2节，“SQL服务器模式”。
·         sql_slave_skip_counter
从服务器应跳过的来自主服务器的事件数。
·         storage_engine
该变量是table_typeis的同义词。在MySQL 5.1中,首选storage_engine。
·         sync_binlog
如果为正，当每个sync_binlog'th写入该二进制日志后，MySQL服务器将它的二进制日志同步到硬盘上(fdatasync())。请注意如果在autocommit模式，每执行一个语句向二进制日志写入一次，否则每个事务写入一次。 默认值是0，不与硬盘同步。值为1是最安全的选择，因为崩溃时，你最多丢掉二进制日志中的一个语句/事务；但是，这是最慢的选择(除非硬盘有电池备份缓存，从而使同步工作较快)。
·         sync_frm
如果该变量设为1,当创建非临时表时它的.frm文件被同步到硬盘上(fdatasync())；这样较慢但出现崩溃时较安全。 默认值为1。
·         system_time_zone
服务器系统时区。当 服务器开始执行时，它继承机器默认时区设置值，可以由运行服务器的账户或在启动脚本中进行修改。该值用来设置system_time_zone。典型情况用TZ环境变量来指定时区。还可以用mysqld_safe脚本的--timez选项来指定。
·         table_cache
所有线程打开的表的数目。增大该值可以增加mysqld需要的文件描述符的数量。你可以检查Opened_tables状态变量来检查你是否需要增加表缓存。参见5.3.4节，“服务器状态变量”。如果Opened_tables值较大，并且多次执行FLUSH TABLES(只是强制关闭所有表并重新)，则应增加table_cache变量的值。
关于表缓存的详细信息，参见7.4.9节，“MySQL如何打开和关闭表”。
·         table_type
默认表类型(存储引擎)。要想在服务器启动时设置表类型，使用--default-table-type选项。参见5.3.1节，“mysqld命令行选项”。
·         thread_cache_size
服务器应缓存多少线程以便重新使用。当客户端断开连接时，如果线程少于thread_cache_size，则客户端的线程被放入缓存。当请求线程时如果允许可以从缓存中重新利用线程，并且只有当缓存空了时才会创建新线程。如果新连接很多，可以增加该变量以提高性能。(一般情况，如果线程执行得很好，性能提高不明显)。检查Connections和Threads_created状态变量的差(详见5.3.4节，“服务器状态变量”)，你可以看见线程缓存的效率。
·         thread_concurrency
在Solaris中，mysqld用该值调用thr_setconcurrency()。该函数使应用程序向线程系统提供需要同时运行的期望的线程数目的提示。
·         thread_stack
每个线程的堆栈大小。用crash-me测试检测出的许多限制取决于该值。 默认值足够大，可以满足普通操作。参见7.1.4节，“MySQL基准套件”。
·         time_format
该变量为使用。
·         time_zone
当前的时区。初使值是'SYSTEM'(使用system_time_zone的值)，但可以用--default-time-zone选项在服务器启动时显式指定。
·         tmp_table_size
如果内存内的临时表超过该值，MySQL自动将它转换为硬盘上的MyISAM表。如果你执行许多高级GROUP BY查询并且有大量内存，则可以增加tmp_table_size的值。
·         tmpdir
保存临时文件和临时表的目录。该变量可以设置为几个路径，按round-robin模式使用。在Unix中应该用冒号(‘:’)间隔开路径，在Windows、NetWare和OS/2中用分号(‘；’)。
用来将负荷分散到几个物理硬盘上。如果MySQL服务器为复制从服务器，你不应将tmpdir设置为指向基于内存的文件系统上的目录或当服务器主机重启时声明的目录。复制从服务器需要部分临时文件来在机器重启后仍可用，以便它可以复制临时表或执行LOAD DATA INFILE操作。如果服务器重启时临时文件夹中的文件丢失了，则复制失败。但是，如果你使用MySQL 4.0.0或更新版本，你可以使用 slave_load_tmpdir变量设置从服务器的临时目录。在这种情况下，从服务器不再使用常规tmpdir，说明你可以将tmpdir设置到一个非固定位置。
·         transaction_alloc_block_size
为保存将保存到二进制日志中的事务的查询而分配的内存块的大小(字节)。
·         transaction_prealloc_size
为transaction_alloc_blocks分配的固定缓冲区的大小（字节），在两次查询之间不会释放。使该值足够大，将所有查询固定到一个事务中，可以避免多次malloc()调用。
·         tx_isolation
默认事务隔离级别。默认值为REPEATABLE-READ。
·         updatable_views_with_limit
该变量控制如果更新包含LIMIT子句，是否可以在当前表中使用不包含主关键字的视图进行更新。(通常用GUI工具生成这类更新)。更新指UPDATE或DELETE语句。这儿主关键字指PRIMARY KEY，或一个UNIQUE索引，其中任何列不可以包含NULL。
该变量有两个值：
o        1或YES：只发出警告(没有错误消息)。这是 默认值。
o        0或NO：禁止更新。
·         version
服务器版本号。
·         version_bdb
BDB存储引擎版本。
·         version_comment
configure脚本有一个--with-comment选项，当构建MySQL时可以进行注释。该变量包含注释值。
·         version_compile_machine
MySQL构建的机器或架构的类型。
·         version_compile_os
MySQL构建的操作系统的类型。
·         wait_timeout
服务器关闭非交互连接之前等待活动的秒数。
在线程启动时，根据全局wait_timeout值或全局interactive_timeout值初始化会话wait_timeout值，取决于客户端类型(由mysql_real_connect()的连接选项CLIENT_INTERACTIVE定义)。又见interactive_timeout。
5.3.3.1. 动态系统变量
许多服务器系统变量是动态的，可以使用SET GLOBAL或SET SESSION在运行时设置。你还可以使用SELECT获得它们的值。参见9.4节，“系统变量”。
下面的表列出了所有动态系统变量。最后1列说明每个变量是否适用GLOBAL或SESSION(或二者)。
变量名
值类型
类型
autocommit
boolean
SESSION
big_tables
boolean
SESSION
binlog_cache_size
numeric
GLOBAL
bulk_insert_buffer_size
numeric
GLOBAL | SESSION
character_set_client
string
GLOBAL | SESSION
character_set_connection
string
GLOBAL | SESSION 
character_set_results
string
GLOBAL | SESSION
character_set_server
string
GLOBAL | SESSION
collation_connection
string
GLOBAL | SESSION
collation_server
string
GLOBAL | SESSION
completion_type
numeric
GLOBAL | SESSION
concurrent_insert
boolean
GLOBAL
connect_timeout
numeric
GLOBAL
convert_character_set
string
GLOBAL | SESSION
default_week_format
numeric
GLOBAL | SESSION
delay_key_write
OFF | ON | ALL
GLOBAL
delayed_insert_limit
numeric
GLOBAL
delayed_insert_timeout
numeric
GLOBAL
delayed_queue_size
numeric
GLOBAL
div_precision_increment
numeric
GLOBAL | SESSION
engine_condition_pushdown
boolean
GLOBAL | SESSION
error_count
numeric
SESSION
expire_logs_days
numeric
GLOBAL
flush
boolean
GLOBAL
flush_time
numeric
GLOBAL
foreign_key_checks
boolean
SESSION
ft_boolean_syntax
numeric
GLOBAL
group_concat_max_len
numeric
GLOBAL | SESSION
identity
numeric
SESSION
innodb_autoextend_increment
numeric
GLOBAL
innodb_concurrency_tickets
numeric
GLOBAL
innodb_max_dirty_pages_pct
numeric
GLOBAL
innodb_max_purge_lag
numeric
GLOBAL
innodb_support_xa
boolean
GLOBAL | SESSION
innodb_sync_spin_loops
numeric
GLOBAL
innodb_table_locks
boolean
GLOBAL | SESSION
innodb_thread_concurrency
numeric GLOBAL
 
innodb_thread_sleep_delay
numeric GLOBAL
 
insert_id
boolean
SESSION
interactive_timeout
numeric
GLOBAL | SESSION
join_buffer_size
numeric
GLOBAL | SESSION
key_buffer_size
numeric
GLOBAL
last_insert_id
numeric
SESSION
local_infile
boolean
GLOBAL
log_warnings
numeric
GLOBAL
long_query_time
numeric
GLOBAL | SESSION
low_priority_updates
boolean
GLOBAL | SESSION
max_allowed_packet
numeric
GLOBAL | SESSION
max_binlog_cache_size
numeric
GLOBAL
max_binlog_size
numeric
GLOBAL
max_connect_errors
numeric
GLOBAL
max_connections
numeric
GLOBAL
max_delayed_threads
numeric
GLOBAL
max_error_count
numeric
GLOBAL | SESSION
max_heap_table_size
numeric
GLOBAL | SESSION
max_insert_delayed_threads
numeric
GLOBAL
max_join_size
numeric
GLOBAL | SESSION
max_relay_log_size
numeric
GLOBAL
max_seeks_for_key
numeric
GLOBAL | SESSION
max_sort_length
numeric
GLOBAL | SESSION
max_tmp_tables
numeric
GLOBAL | SESSION
max_user_connections
numeric
GLOBAL
max_write_lock_count
numeric
GLOBAL
myisam_stats_method
enum
GLOBAL | SESSION
multi_read_range
numeric
GLOBAL | SESSION
myisam_data_pointer_size
numeric
GLOBAL
log_bin_trust_routine_creators
boolean
GLOBAL
myisam_max_sort_file_size
numeric
GLOBAL | SESSION
myisam_repair_threads
numeric
GLOBAL | SESSION
myisam_sort_buffer_size
numeric
GLOBAL | SESSION
net_buffer_length
numeric
GLOBAL | SESSION
net_read_timeout
numeric
GLOBAL | SESSION
net_retry_count
numeric
GLOBAL | SESSION
net_write_timeout
numeric
GLOBAL | SESSION
old_passwords
numeric
GLOBAL | SESSION
optimizer_prune_level
numeric
GLOBAL | SESSION
optimizer_search_depth
numeric
GLOBAL | SESSION
preload_buffer_size
numeric
GLOBAL | SESSION
query_alloc_block_size
numeric
GLOBAL | SESSION
query_cache_limit
numeric
GLOBAL
query_cache_size
numeric
GLOBAL
query_cache_type
enumeration
GLOBAL | SESSION
query_cache_wlock_invalidate
boolean
GLOBAL | SESSION
query_prealloc_size
numeric
GLOBAL | SESSION
range_alloc_block_size
numeric
GLOBAL | SESSION
read_buffer_size
numeric
GLOBAL | SESSION
read_only
numeric
GLOBAL
read_rnd_buffer_size
numeric
GLOBAL | SESSION
rpl_recovery_rank
numeric
GLOBAL
safe_show_database
boolean
GLOBAL
secure_auth
boolean
GLOBAL
server_id
numeric
GLOBAL
slave_compressed_protocol
boolean
GLOBAL
slave_net_timeout
numeric
GLOBAL
slave_transaction_retries
numeric
GLOBAL
slow_launch_time
numeric
GLOBAL
sort_buffer_size
numeric
GLOBAL | SESSION
sql_auto_is_null
boolean
SESSION
sql_big_selects
boolean
SESSION
sql_big_tables
boolean
SESSION
sql_buffer_result
boolean
SESSION
sql_log_bin
boolean
SESSION
sql_log_off
boolean
SESSION
sql_log_update
boolean
SESSION
sql_low_priority_updates
boolean
GLOBAL | SESSION
sql_max_join_size
numeric
GLOBAL | SESSION
sql_mode
enumeration
GLOBAL | SESSION
sql_notes
boolean
SESSION
sql_quote_show_create
boolean
SESSION
sql_safe_updates
boolean
SESSION
sql_select_limit
numeric
SESSION
sql_slave_skip_counter
numeric
GLOBAL
updatable_views_with_limit
enumeration
GLOBAL | SESSION
sql_warnings
boolean
SESSION
sync_binlog
numeric
GLOBAL
sync_frm
boolean
GLOBAL
storage_engine
enumeration
GLOBAL | SESSION
table_cache
numeric
GLOBAL
table_type
enumeration
GLOBAL | SESSION
thread_cache_size
numeric
GLOBAL
time_zone
string
GLOBAL | SESSION
timestamp
boolean
SESSION
tmp_table_size
enumeration
GLOBAL | SESSION
transaction_alloc_block_size
numeric
GLOBAL | SESSION
transaction_prealloc_size
numeric
GLOBAL | SESSION
tx_isolation
enumeration
GLOBAL | SESSION
unique_checks
boolean
SESSION
wait_timeout
numeric
GLOBAL | SESSION
warning_count
numeric
SESSION
标记为string的变量采用字符串值。标记为numeric的变量采用数字值。标记为boolean的变量可以设置为0、1、ON或OFF。标记为enumeration的变量一般情况应设置为该变量的某个可用值，但还可以设置为对应期望的枚举值的数字。对于枚举系统变量，第1个枚举值应对应0。这不同于ENUM列，第1个枚举值对应1。
5.3.4. 服务器状态变量
服务器维护许多提供操作相关信息的状态变量。你可以通过SHOW STATUS语句查看这些变量和它们的值：
mysql> SHOW STATUS;
+-----------------------------------+------------+
| Variable_name                     | Value      |
+-----------------------------------+------------+
| Aborted_clients                   | 0          |
| Aborted_connects                  | 0          |
| Bytes_received                    | 155372598  |
| Bytes_sent                        | 1176560426 |
 
…
 
| Connections                       | 30023      |
| Created_tmp_disk_tables           | 0          |
| Created_tmp_files                 | 3          |
| Created_tmp_tables                | 2          |
 
…
 
| Threads_created                   | 217        |
| Threads_running                   | 88         |
| Uptime                            | 1389872    |
+-----------------------------------+------------+
 
用FLUSH STATUS语句可以将许多状态变量重设为0。
状态变量有以下含义。没有指示版本的变量在MySQL 5.1之前已经出现。关于它们的使用历史，参见MySQL 5.0参考手册。
·         Aborted_clients
由于客户端没有正确关闭连接导致客户端终止而中断的连接数。参见A.2.10节，“通信错误和失效连接”。
·         Aborted_connects
试图连接到MySQL服务器而失败的连接数。参见A.2.10节，“通信错误和失效连接”。
·         Binlog_cache_disk_use
使用临时二进制日志缓存但超过binlog_cache_size值并使用临时文件来保存事务中的语句的事务数量。
·         Binlog_cache_use
使用临时二进制日志缓存的事务数量。
·         Bytes_received
从所有客户端接收到的字节数。
·         Bytes_sent
发送给所有客户端的字节数。
·         Com_xxx
Com_xxx 语句计数变量表示每个xxx 语句执行的次数。每类语句有一个状态变量。例如，Com_delete和Com_insert分别统计DELETE 和INSERT语句执行的次数。
Com_stmt_xxx状态变量为：
o        Com_stmt_prepare 
o        Com_stmt_execute 
o        Com_stmt_fetch 
o        Com_stmt_send_long_data 
o        Com_stmt_reset 
o        Com_stmt_close
这些变量代表准备好的语句命令。它们的名字对应网络层使用的COM_xxx 命令系列；换句话说：当准备好的语句API调用如mysql_stmt_prepare()、mysql_stmt_执行()并执行时，它们的值增加。但是，当执行下面的SQL语句时，Com_stmt_prepare, Com_stmt_execute和Com_stmt_close也增加：PREPARE、EXECUTE或DEALLOCATE PREPARE。此外，旧(从MySQL 4.1.3起可用)语句计数变量Com_prepare_sql、Com_execute_sql和Com_dealloc_sql的值也随PREPARE、EXECUTE和DEALLOCATE PREPARE语句增加。Com_stmt_fetch代表通过光标获取的网络round-trips的总数量。
所有Com_stmt_xxx变量将增加，即使语句参数未知或执行过程中出现错误。换句话说，它们的值对应发出的请求数，而不是成功完成的请求数。
·         Connections
试图连接到(不管是否成功)MySQL服务器的连接数。
·         Created_tmp_disk_tables
服务器执行语句时在硬盘上自动创建的临时表的数量。
·         Created_tmp_files
mysqld已经创建的临时文件的数量。
·         Created_tmp_files
服务器执行语句时自动创建的内存中的临时表的数量。如果Created_tmp_disk_tables较大，你可能要增加tmp_table_size值使临时 表基于内存而不基于硬盘。
·         Delayed_errors
用INSERT DELAYED写的出现错误的行数(可能为duplicate key)。
·         Delayed_insert_threads
使用的INSERT DELAYED处理器线程数。
·         Delayed_writes
写入的INSERT DELAYED行数。
·         Flush_commands
执行的FLUSH语句数。
·         Handler_commit
内部提交语句数。
·         Handler_discover
MySQL服务器可以问NDB CLUSTER存储引擎是否知道某一名字的表。这被称作发现。Handler_discover说明通过该方法发现的次数。
·         Handler_delete
行从表中删除的次数。
·         Handler_read_first
索引中第一条被读的次数。如果较高，它建议服务器正执行大量全索引扫描；例如，SELECT col1 FROM foo，假定col1有索引。
·         Handler_read_key
根据键读一行的请求数。如果较高，说明查询和表的索引正确。
·         Handler_read_next
按照键顺序读下一行的请求数。如果你用范围约束或如果执行索引扫描来查询索引列，该值增加。
·         Handler_read_prev
按照键顺序读前一行的请求数。该读方法主要用于优化ORDER BY ... DESC。
·         Handler_read_rnd
根据固定位置读一行的请求数。如果你正执行大量查询并需要对结果进行排序该值较高。你可能使用了大量需要MySQL扫描整个表的查询或你的连接没有正确使用键。
·         Handler_read_rnd_next
在数据文件中读下一行的请求数。如果你正进行大量的表扫描，该值较高。通常说明你的表索引不正确或写入的查询没有利用索引。
·         Handler_rollback
内部ROLLBACK语句的数量。
·         Handler_update
在表内更新一行的请求数。
·         Handler_write
在表内插入一行的请求数。
·         Innodb_buffer_pool_pages_data
包含数据的页数(脏或干净)。
·         Innodb_buffer_pool_pages_dirty
当前的脏页数。
·         Innodb_buffer_pool_pages_flushed
要求清空的缓冲池页数。
·         Innodb_buffer_pool_pages_free
空页数。
·         Innodb_buffer_pool_pages_latched
在InnoDB缓冲池中锁定的页数。这是当前正读或写或由于其它原因不能清空或删除的页数。
·           Innodb_buffer_pool_pages_misc
忙的页数，因为它们已经被分配优先用作管理，例如行锁定或适用的哈希索引。该值还可以计算为Innodb_buffer_pool_pages_total - Innodb_buffer_pool_pages_free - Innodb_buffer_pool_pages_data。
·         Innodb_buffer_pool_pages_total
缓冲池总大小（页数）。
·         Innodb_buffer_pool_read_ahead_rnd
InnoDB初始化的“随机”read-aheads数。当查询以随机顺序扫描表的一大部分时发生。
·         Innodb_buffer_pool_read_ahead_seq
InnoDB初始化的顺序read-aheads数。当InnoDB执行顺序全表扫描时发生。
·         Innodb_buffer_pool_read_requests
InnoDB已经完成的逻辑读请求数。
·         Innodb_buffer_pool_reads
不能满足InnoDB必须单页读取的缓冲池中的逻辑读数量。
·         Innodb_buffer_pool_wait_free
一般情况，通过后台向InnoDB缓冲池写。但是，如果需要读或创建页，并且没有干净的页可用，则它还需要先等待页面清空。该计数器对等待实例进行记数。如果已经适当设置缓冲池大小，该值应小。
·         Innodb_buffer_pool_write_requests
向InnoDB缓冲池的写数量。
·         Innodb_data_fsyncs
fsync()操作数。
·         Innodb_data_pending_fsyncs
当前挂起的fsync()操作数。
·         Innodb_data_pending_reads
当前挂起的读数。
·         Innodb_data_pending_writes
当前挂起的写数。
·         Innodb_data_read
至此已经读取的数据数量（字节）。
·         Innodb_data_reads
数据读总数量。
·         Innodb_data_writes
数据写总数量。
·         Innodb_data_written
至此已经写入的数据量（字节）。
·         Innodb_dblwr_writes, Innodb_dblwr_pages_written
已经执行的双写操作数量和为此目的已经写好的页数。参见15.2.14.1节，“磁盘I/O”。
·         Innodb_log_waits
我们必须等待的时间，因为日志缓冲区太小，我们在继续前必须先等待对它清空。
·         Innodb_log_write_requests
日志写请求数。
·         Innodb_log_writes
向日志文件的物理写数量。
·         Innodb_os_log_fsyncs
向日志文件完成的fsync()写数量。
·         Innodb_os_log_pending_fsyncs
挂起的日志文件fsync()操作数量。
·         Innodb_os_log_pending_writes
挂起的日志文件写操作。
·         Innodb_os_log_written
写入日志文件的字节数。
·         Innodb_page_size
编译的InnoDB页大小(默认16KB)。许多值用页来记数；页的大小很容易转换为字节。
·         Innodb_pages_created
创建的页数。
·         Innodb_pages_read
读取的页数。
·         Innodb_pages_written
写入的页数。
·         Innodb_row_lock_current_waits
当前等待的待锁定的行数。
·         Innodb_row_lock_time
行锁定花费的总时间，单位毫秒。
·         Innodb_row_lock_time_avg
行锁定的平均时间，单位毫秒。
·         Innodb_row_lock_time_max
行锁定的最长时间，单位毫秒。
·         Innodb_row_lock_waits
一行锁定必须等待的时间数。
·         Innodb_rows_deleted
从InnoDB表删除的行数。
·         Innodb_rows_inserted
插入到InnoDB表的行数。
·         Innodb_rows_read
从InnoDB表读取的行数。
·         Innodb_rows_updated
InnoDB表内更新的行数。
·         Key_blocks_not_flushed
键缓存内已经更改但还没有清空到硬盘上的键的数据块数量。
·         Key_blocks_unused
键缓存内未使用的块数量。你可以使用该值来确定使用了多少键缓存；参见5.3.3节，“服务器系统变量”中Key_buffer_size的讨论。
·         Key_blocks_used
键缓存内使用的块数量。该值为高水平线标记，说明已经同时最多使用了多少块。
·         Key_read_requests
从缓存读键的数据块的请求数。
·         Key_reads
从硬盘读取键的数据块的次数。如果Key_reads较大，则Key_buffer_size值可能太小。可以用Key_reads/Key_read_requests计算缓存损失率。
·         Key_write_requests
将键的数据块写入缓存的请求数。
·         Key_writes
向硬盘写入将键的数据块的物理写操作的次数。
·         Last_query_cost
用查询优化器计算的最后编译的查询的总成本。用于对比同一查询的不同查询方案的成本。默认值0表示还没有编译查询。 默认值是0。Last_query_cost具有会话范围。
·         Max_used_connections
服务器启动后已经同时使用的连接的最大数量。
·         Not_flushed_delayed_rows
等待写入INSERT DELAY队列的行数。
·         Open_files
打开的文件的数目。
·         Open_streams
打开的流的数量(主要用于记录)。
·         Open_tables
当前打开的表的数量。
·         Opened_tables
已经打开的表的数量。如果Opened_tables较大，table_cache 值可能太小。
·         QCACHE_free_blocks
查询缓存内自由内存块的数量。
·         QCACHE_free_memory
用于查询缓存的自由内存的数量。
·         QCACHE_hits
查询缓存被访问的次数。
·         QCACHE_inserts
加入到缓存的查询数量。
·         QCACHE_lowmem_prunes
由于内存较少从缓存删除的查询数量。
·         QCACHE_not_cached
非缓存查询数(不可缓存，或由于query_cache_type设定值未缓存)。
·         Qcache_queries_in_cache
登记到缓存内的查询的数量。
·         Qcache_total_blocks
查询缓存内的总块数。
·         Questions
已经发送给服务器的查询的个数。
·         Rpl_status
失败安全复制状态(还未使用)。
·         Select_full_join
没有使用索引的联接的数量。如果该值不为0,你应仔细检查表的索引。
·         Select_full_range_join
在引用的表中使用范围搜索的联接的数量。
·         Select_range
在第一个表中使用范围的联接的数量。一般情况不是关键问题，即使该值相当大。
·         Select_range_check
在每一行数据后对键值进行检查的不带键值的联接的数量。如果不为0，你应仔细检查表的索引。
·         Select_scan
对第一个表进行完全扫描的联接的数量。
·         Slave_open_temp_tables
当前由从SQL线程打开的临时表的数量。
·         Slave_running
如果该服务器是连接到主服务器的从服务器，则该值为ON。
·         Slave_retried_transactions
启动后复制从服务器SQL线程尝试事务的总次数。
·         Slow_launch_threads
创建时间超过slow_launch_time秒的线程数。
·         Slow_queries
查询时间超过long_query_time秒的查询的个数。参见5.11.4节，“慢速查询日志”。
·         Sort_merge_passes
排序算法已经执行的合并的数量。如果这个变量值较大，应考虑增加sort_buffer_size系统变量的值。
·         Sort_range
在范围内执行的排序的数量。
·         Sort_rows
已经排序的行数。
·         Sort_scan
通过扫描表完成的排序的数量。
·         Ssl_xxx
用于SSL连接的变量。
·         Table_locks_immediate
立即获得的表的锁的次数。
·         Table_locks_waited
不能立即获得的表的锁的次数。如果该值较高，并且有性能问题，你应首先优化查询，然后拆分表或使用复制。
·         Threads_cached
线程缓存内的线程的数量。
·         Threads_connected
当前打开的连接的数量。
·         Threads_created
创建用来处理连接的线程数。如果Threads_created较大，你可能要增加thread_cache_size值。缓存访问率的计算方法Threads_created/Connections。
·           Threads_running
激活的（非睡眠状态）线程数。
·         Uptime
服务器已经运行的时间（以秒为单位）。
5.4. mysql_fix_privilege_tables：升级MySQL系统表
一些MySQL发布对mysql数据库中的系统表的结构进行了更改，添加了新权限或特性。当你更新到新版本MySQL，你应同时更新系统表，以确保它们的结构最新。首先备份mysql数据库，然后按照下面的程序操作。 
在Unix或Unix类系统中，运行mysql_fix_privilege_tables脚本来更新系统表：
shell> mysql_fix_privilege_tables
你必须在服务器运行时执行该脚本。它试图连接本机上用root运行的服务器。如果root账户需要密码，在命令行中按下述方法给出密码：
shell> mysql_fix_privilege_tables--password=root_password
mysql_fix_privilege_tables脚本可以执行将系统表转换为当前格式的任何动作。运行时你可能会看见一些Duplicate column name警告；你可以忽略它们。
运行完脚本后，停止服务器并重启。
在Windows系统中，MySQL分发包括mysql_fix_privilege_tables.sql SQL脚本，你可以用mysql客户端来运行。例如，如果MySQL安装到C:\Program Files\MySQL\MySQL Server 5.1，命令应为：
C:\> C:\Program Files\MySQL\MySQL Server 5.1\bin\mysql -u root -p mysql
mysql> SOURCE C:/Program Files/MySQL/MySQL Server 5.1/scripts/mysql_fix_privilege_tables.sql
如果安装到其它目录，相应地更改路径名。
mysql命令将提示输入root密码；按照提示输入密码。
在Unix中，当mysql处理mysql_fix_privilege_tables.sql script脚本中的语句时，你可能会看见一些Duplicate column name警告；你可以忽略它们。
运行完脚本后，停止服务器并重启。
5.5. MySQL服务器关机进程
1.  服务器关闭进程可以概括为： 
1.    启动关闭进程
2.    服务器根据需要创建关闭线程
3.    服务器停止接收新连接
4.    服务器终止当前的活动
5.    存储引擎被停掉或关闭
6.    服务器退出
下面是更详细的描述：
1.    启动关闭进程。
可以用多种方法启动服务器的关闭。例如，拥有SHUTDOWN权限的用户可以执行mysqladmin shutdown命令。mysqladmin可以用于所有支持MySQL的平台上。其它操作系统相关的关闭开始方法还可能有：在Unix中，当接收到SIGTERM信号后，服务器关闭。对于在Windows中作为服务运行的服务器，当服务管理器让它关闭时，则关闭。
2.    服务器根据需要创建关闭线程。
根据开始关闭的方式，服务器可以创建线程来处理关闭进程。如果客户端需要关闭，则创建关闭线程。如果收到SIGTERM信号后关闭，信号线程可以自己关闭，或者创建单独的线程来完成。如果服务器尝试创建关闭线程而不能创建(例如，如果内存被耗尽)，它在错误日志中给出诊断消息：
Error: Can't create thread to kill server
3.    服务器停止接收新连接。
在关闭过程中要想防止启动新活动，服务器停止接收新的客户端连接。它将关闭它帧听的网络连接：TCP/IP端口、Unix套接字文件、Windows命名管道和在Windows中的共享内存。
4.    服务器终止当前的活动。
对于每个与客户端连接相关的线程，与客户端的连接被中断，线程被标记为“杀掉的”。当线程注意到此类标记后则线程终止。空闲连接的线程很快终止。当前正处理查询的线程定期检查它们的状态，终止的时间较长。关于线程终止的详细信息，参见13.5.5.3节，“KILL语法”，特别是关于对MyISAM表的杀掉的REPAIR TABLE或OPTIMIZE TABLE操作。
对于有打开事务的线程，事务被回滚。请注意如果某个线程正在更新非事务表，多行UPDATE或INSERT等操作会使表部分更新，因为操作在完成前会终止。
如果服务器是主复制服务器，与当前连接的从服务器相关的线程的处理方式同其它客户端线程。即每个线程被标记为杀掉的，在下次检查他的状态后会退出。
如果服务器是从复制服务器，在客户端线程标记为杀掉的之前，激活的I/O和SQL线程被停止。SQL线程允许先结束它当前的语句(以避免造成复制问题)然后停止。如果此时SQL线程正位于事务中部，事务则 回滚。
5.    存储引擎被停掉或关闭。
在该阶段，表缓存被清空，所有打开的表被关闭。
每个存储引擎执行它管理的表需要的任何动作。例如，MyISAM清空任何挂起的表索引写操作。InnoDB将它的缓冲池清空到硬盘上（除非innodb_fast_shutdown为2），将当前的LSN写入表内，并终止自己的内部线程。
6.    服务器退出。
5.6. 一般安全问题
5.6.1. 通用安全指南 
5.6.2. 使MySQL在攻击者面前保持安全 
5.6.3. Mysqld安全相关启动选项 
5.6.4. LOAD DATA LOCAL安全问题
本节描述一些常见的需要注意的安全问题，以及一些可以使你的MySQL安装更加安全以防止黑客和误用的措施。关于MySQL用于设置用户账户并检查数据库访问的访问控制系统的具体信息，参见5.7节，“MySQL访问权限系统”。
5.6.1. 通用安全指南
任何在与Internet联网的计算机上使用MySQL的用户都应仔细阅读本节，以避免最常见的安全问题。
讨论安全时，我们强调必须完全保护整个服务器主机的安全(而不只是MySQL服务器)防范各种类型的可能的攻击：偷听、修改、重放和拒绝服务。我们在这里不能覆盖各方面的内容和措施。
MySQL根据访问控制列表(ACL)对所有连接、查询和其它用户尝试执行的操作进行安全管理。MySQL客户端和服务器之间还支持SSL-加密连接。这儿讨论的许多概念并不是MySQL专有的；该思想几乎同样适合所有应用程序。
运行MySQL时，应尽量遵从下面的指导：
·         不要让任何人(除了MySQL root账户)访问mysql数据库中的user表！这很关键。加密的密码才是MySQL中的真正的密码。知道user表中所列的密码并且能访问该账户客访问的主机的人可以很容易地用该用户登录。
·         学习MySQL访问权限系统。用GRANT和REVOKE语句来控制对MySQL的访问。不要授予超过需求的权限。决不能为所有主机授权。
检查清单：
o        试试mysql -u root。如果你能够成功连接服务器而没有要任何密码，则说明有问题。任何人可以作为MySQLroot用户用它的全部权限来连接MySQL服务器！查阅MySQL安装说明，应特别注意关于设置root密码的信息。参见2.9.3节，“使初始MySQL账户安全”。
o        通过SHOW GRANTS语句检查查看谁已经访问了什么。然后使用REVOKE语句删除不再需要的权限。
·         不要将纯文本密码保存到数据库中。如果你的计算机有安全危险，入侵者可以获得所有的密码并使用它们。相反，应使用MD5()、SHA1()或单向哈希函数。
·         不要从词典中选择密码。有专门的程序可以破解它们。即使象“xfish98”这样的密码也很差。而“duag98”要好得多，虽然包含了相同的字“fish”，但从标准QWERTY键盘向左输入。另一种方法是使用“Mhall”，来自句子“Mary had a little lamb.”中每个字的第一个字符。这样很容易记住并输入，但是不知道的人很难猜出来。
·         购买防火墙。这样可以保护你防范各种软件中至少50%的各种类型的攻击。把MySQL放到防火墙后或隔离区(DMZ)。
检查清单：
o        试试从Internet使用nmap工具扫描端口。MySQL默认使用端口3306。不应从不可信任主机访问该端口。另一种检查是否MySQL端口打开的简单方式是从远程机器试试下面的命令，其中server_host是MySQL服务器运行的主机：
o                     shell> telnet server_host 3306
如果得到连接并得到一些垃圾字符，则端口打开着，则应从防火墙或路由器上关闭，除非你有合理的理由让它开着。如果telnet挂起或连接被拒绝，则端口被阻塞，这是你所希望的。
不要信任应用程序的用户输入的任何数据。它们可以用Web形式、URL或构建的应用程序输入特殊或逃溢字符序列来尝试欺骗你的代码。如果某个用户输入“; DROP DATABASE mysql;”等内容，应确保你的应用程序保持安全。这是特例，但当黑客使用类似技术时，如果你没有做好准备，结果可能会出现大的安全漏洞和数据丢失。
一个常见的错误是只保护字符串数据值。一定要记住还应检查数字数据。如果当用户输入值234时，应用程序生成查询SELECT * FROM table WHERE ID=234，用户可以输入值234 OR 1=1使应用程序生成查询SELECT * FROM table WHERE ID=234 OR 1=1。结果是服务器查找表内的每个记录。这样会暴露每个记录并造成过多的服务器负载。保护防范这类攻击的最简单的方法是使用单引号将数字常量引起来：SELECT * FROM table WHERE ID='234'。如果用户输入其它信息，均变为字符串的一部分。在数字部分，MySQL自动将字符串转换为数字并剥离字符串包含的附加的非数字字符。
有时候人们会认为如果数据库只包含供公共使用的数据，则不需要保护。这是不正确的。即使允许显示数据库中的任何记录，你仍然应保护防范拒绝服务攻击(例如，基于前面段落中所述的技术的攻击，会使服务器浪费资源)。否则，你的服务器不再响应合法用户。
检查清单：
o        试试用Web形式输入单引号和双引号(‘'’和‘"’)。如果得到任何形式的MySQL错误，立即分析原因。
o        试试修改动态URL，可以在其中添加%22(‘"’)、%23(‘#’)和%27(‘'’)。
o        试试在动态URL中修改数据类型，使用前面示例中的字符，包括数字和字符类型。你的应用程序应足够安全，可以防范此类修改和类似攻击。
o        试试输入字符、空格和特殊符号，不要输入数值字段的数字。你的应用程序应在将它们传递到MySQL之前将它们删除或生成错误。将未经过检查的值传递给MySQL是很危险的！
o        将数据传给MySQL之前先检查其大小。
o        用管理账户之外的用户名将应用程序连接到数据库。不要给应用程序任何不需要的访问权限。
·         许多应用程序编程接口提供了措施逃逸数据值中的特殊字符。如果使用正确，可以防止应用程序用户输入使应用程序生成不期望的效果的语句的数值：
o        MySQL C API：使用mysql_real_escape_string() API调用。
o        MySQL++：查询流使用escape和quote修订符。
o        PHP：使用mysql_escape_string()函数基于MySQL C API中的同名函数。(在PHP 4.0.3之前,使用addslashes()）。在PHP 5中,可以使用mysqli扩展名，它支持改进的MySQL鉴定协议和密码，以及用占位符编写的语句。
o        Perl DBI：使用quote()方法或使用占位符。
o        Java JDBC：使用一个PreparedStatement对象和占位符。
其它编程接口有类似的功能。
·         不要通过Internet传送明文(未加密的)数据。该信息可以被有足够时间和能力来截取它并用于个人目的的任何人访问。相反，应使用加密协议，例如SSL或SSH。MySQL支持内部SSL连接，例如版本 4.0.0。可以使用SSH端口映射为通信创建加密(并压缩)的隧道。
·         学会使用tcpdump和strings工具。在大多数情况下，你可以使用下面的命令检查是否MySQL数据流未加密：
·                shell> tcpdump -l -i eth0 -w - src or dst port 3306 | strings
(该命令在Linux中可以工作，在其它系统中经过小小的修改后应可以工作）。 警告：如果你没有看见明文数据，并不一定说明信息实际上被加密了。如果你需要较高级别的安全，你应咨询安全专家。
5.6.2. 使MySQL在攻击者面前保持安全
当你连接到MySQL服务器时，你应使用一个密码。密码不以明文在上传输。客户端连接序列中的密码处理在MySQL 4.1.1中已经升级，很安全。如果你仍然使用pre-4.1.1-风格的密码，加密算法不如新算法强；通过一些工作，可以窃取客户端和服务器之间的通信的聪明的攻击者可以破解密码。(关于不同的密码处理方法的讨论参见5.7.9节，“MySQL 4.1中的密码哈希处理”）。 如果客户端和服务器之间的连接通过不可信任网络，你应使用SSH隧道来加密通信。
所有其它信息以文本传送，可以被可以看到连接的任何人读取。如果你担心这个，你可以使用压缩协议来使通信更难以解密。要想使连接更加安全，你应使用SSH来获得加密的MySQL服务器和MySQL客户端之间的TCP/IP连接。你可以从http://www.openssh.org/找到开放源码SSH 客户端，并可以从http://www.ssh.com/获得商业SSH客户端。
你还可以使用MySQL内部OpenSSL支持。参见5.8.7节，“使用安全连接”。
为了使MySQL系统安全，强烈要求你考虑下列建议：
·         对所有MySQL用户使用密码。客户端程序不需要知道运行它的人员的身份。对于客户端/服务器应用程序，用户可以指定客户端程序的用户名。例如，如果other_user没有密码，任何人可以简单地用mysql -u other_user db_name冒充他人调用mysql程序进行连接。如果所有用户有密码，使用其它用户的账户进行连接要困难得多。
要想更改用户的密码，应使用SET PASSWORD语句。还可以直接更新mysql数据库中的user表。例如，要更改所有root用户的MySQL账户的密码，应：
shell> mysql -u root
mysql> UPDATE mysql.user SET Password=PASSWORD('newpwd')
    -> WHERE User='root';
mysql> FLUSH PRIVILEGES;
·         绝对不要作为Unix的root用户运行MySQL服务器。这样做非常危险，因为任何具有FILE权限的用户能够用root创建文件(例如，~root/.bashrc)。为了防止，mysqld拒绝用root运行，除非使用--user=root选项明显指定。
应可以(并且应该)用普通非特权用户运行mysqld。你可以创建独立的Unix中的mysql账户来以便使所有内容更加安全。该账户只用于管理MySQL。要想用其它Unix用户启动mysqld，增加user选项指定/etc/my.cnf选项文件或服务器数据目录的my.cnf选项文件中的[mysqld]组的用户名。例如：
[mysqld]
user=mysql
该命令使服务器用指定的用户来启动，无论你手动启动或通过mysqld_safe或mysql.server启动。详细信息参见A.3.2节，“如何以普通用户身份运行MySQL”。
作为其它Unix用户而不用root运行mysqld，你不需要更改user表中的root用户名，因为MySQL账户的用户名与Unix账户的用户名无关。
·         不要允许使用表的符号链接。(可以用--skip-symbolic-links选项禁用）。如果你用root运行mysqld则特别重要，因为任何对服务器的数据目录有写访问权限的人则能够删除系统中的任何文件！参见7.6.1.2节，“在Unix平台上使用表的符号链接”。
·         确保mysqld运行时，只使用对数据库目录具有读或写权限的Unix用户来运行。
·         不要将PROCESS或SUPER权限授给非管理用户。mysqladmin processlist的输出显示出当前执行的查询正文，如果另外的用户发出一个UPDATE user SET password=PASSWORD('not_secure')查询，被允许执行那个命令的任何用户可能看得到。
mysqld为有SUPER权限的用户专门保留一个额外的连接，因此即使所有普通连接被占用，MySQL root用户仍可以登录并检查服务器的活动。
可以使用SUPER权限来终止客户端连接，通过更改系统变量的值更改服务的器操作，并控制复制服务器。
·         不要向非管理用户授予FILE权限。有这权限的任何用户能在拥有mysqld守护进程权限的文件系统那里写一个文件！为了更加安全，由SELECT ... INTO OUTFILE生成的所有文件对每个人是可写的，并且你不能覆盖已经存在的文件。
file权限也可以被用来读取任何作为运行服务器的Unix用户可读取或访问的文件。使用该权限，你可以将任何文件读入数据库表。这可能被滥用，例如，通过使用LOAD DATA装载“/etc/passwd”进一个数据库表，然后能用SELECT显示它。
·         如果你不信任你的DNS，你应该在授权表中使用IP数字而不是主机名。在任何情况下，你应该非常小心地使用包含通配符的主机名来创建 授权表条目！
·         如果你想要限制单个账户允许的连接数量，你可以设置mysqld中的max_user_connections变量来完成。GRANT语句也可以支持 资源控制选项来限制服务器对一个账户允许的使用范围。参见13.5.1.3节，“GRANT和REVOKE语法”。
5.6.3. Mysqld安全相关启动选项
下列mysqld选项影响安全：
·         --allow-suspicious-udfs
该选项控制是否可以载入主函数只有xxx符的用户定义函数。默认情况下，该选项被关闭，并且只能载入至少有辅助符的UDF。这样可以防止从未包含合法UDF的共享对象文件载入函数。参见27.2.3.6节，“用户定义函数安全注意事项”。
·         --local-infile[={0|1}]
如果用--local-infile=0启动服务器，则客户端不能使用LOCAL in LOAD DATA语句。参见5.6.4节，“LOAD DATA LOCAL安全问题”。
·         --old-passwords
强制服务器为新密码生成短(pre-4.1)密码哈希。当服务器必须支持旧版本客户端程序时，为了保证兼容性这很有用。参见5.7.9节，“MySQL 4.1中的密码哈希处理”。
·         (OBSOLETE) --safe-show-database
在以前版本的MySQL中，该选项使SHOW DATABASES语句只显示用户具有部分权限的数据库名。在MySQL 5.1中，该选项不再作为现在的 默认行为使用，有一个SHOW DATABASES权限可以用来控制每个账户对数据库名的访问。参见13.5.1.3节，“GRANT和REVOKE语法”。
·         --safe-user-create
如果启用，用户不能用GRANT语句创建新用户，除非用户有mysql.user表的INSERT权限。如果你想让用户具有授权权限来创建新用户，你应给用户授予下面的权限：
mysql> GRANT INSERT(user) ON mysql.user TO 'user_name'@'host_name';
这样确保用户不能直接更改权限列，必须使用GRANT语句给其它用户授予该权限。
·         --secure-auth
不允许鉴定有旧(pre-4.1)密码的账户。
·         --skip-grant-tables
这个选项导致服务器根本不使用权限系统。这给每个人以完全访问所有的数据库的权力！（通过执行mysqladmin flush-privileges或mysqladmin reload命令，或执行FLUSH PRIVILEGES语句，你能告诉一个正在运行的服务器再次开始使用授权表。）  
·         --skip-name-resolve
主机名不被解析。所有在授权表的Host的列值必须是IP号或localhost。
·         --skip-networking
在网络上不允许TCP/IP连接。所有到mysqld的连接必须经由Unix套接字进行。
·         --skip-show-database
使用该选项，只允许有SHOW DATABASES权限的用户执行SHOW DATABASES语句，该语句显示所有数据库名。不使用该选项，允许所有用户执行SHOW DATABASES，但只显示用户有SHOW DATABASES权限或部分数据库权限的数据库名。请注意全局权限指数据库的权限。
5.6.4. LOAD DATA LOCAL安全问题
LOAD DATA语句可以装载服务器主机上的文件，若指定LOCAL关键字，可以装载客户端文件。
支持LOCAL版本的LOAD DATA语句有两个可能的安全问题：
·         由MySQL服务器启动文件从客户端向服务器主机的传输。理论上，打过补丁的服务器可以告诉客户端程序传输服务器选择的文件，而不是客户用LOAD DATA语句指定的文件。这样服务器可以访问客户端上客户有读访问权限的任何文件。
·         在Web环境中，客户从Web服务器连接，用户可以使用LOAD DATA LOCAL来读取Web服务器进程有读访问权限的任何文件(假定用户可以运行SQL服务器的任何命令)。在这种环境中，MySQL服务器的客户实际上是Web服务器，而不是连接Web服务器的用户运行的程序。
要处理这些问题，我们更改了MySQL 3.23.49和MySQL 4.0.2(Windows中的4.0.13)中的LOAD DATA LOCAL的处理方法：
·         默认情况下，现在所有二进制分中的发MySQL客户端和库是用--enable-local-infile选项编译，以便与MySQL 3.23.48和以前的版本兼容。
·         如果你从源码构建MySQL但没有使用--enable-local-infile选项来进行configure，则客户不能使用LOAD DATA LOCAL，除非显式调用mysql_options (...MYSQL_OPT_本地_INFILE，0)。参见25.2.3.48节，“mysql_options()”。
·         你可以用--local-infile=0选项启动mysqld从服务器端禁用所有LOAD DATA LOCAL命令。
·         对于mysql命令行客户端，可以通过指定--local-infile[=1]选项启用LOAD DATA LOCAL，或通过--local-infile=0选项禁用。类似地，对于mysqlimport，--local or -L选项启用本地数据文件装载。在任何情况下，成功进行本地装载需要服务器启用相关选项。
·         如果你使用LOAD DATA LOCAL Perl脚本或其它读选项文件中的[client]组的程序，你可以在组内添加local-infile=1选项。但是，为了便面不理解local-infile的程序产生问题，则规定使用loose- prefix：
·                [client]
·                loose-local-infile=1
·         如果LOAD DATA LOCAL INFILE在服务器或客户端被禁用，试图执行该语句的客户端将收到下面的错误消息：
ERROR 1148: The used command is not allowed with this MySQL version
5.7. MySQL访问权限系统
5.7.1. 权限系统的作用 
5.7.2. 权限系统工作原理 
5.7.3. MySQL提供的权限 
5.7.4. 与MySQL服务器连接 
5.7.5. 访问控制, 阶段1：连接核实 
5.7.6. 访问控制, 阶段2：请求核实 
5.7.7. 权限更改何时生效 
5.7.8. 拒绝访问错误的原因 
5.7.9. MySQL 4.1中的密码哈希处理
MySQL有先进但非标准的安全/权限系统。本节描述它的工作原理。 
5.7.1. 权限系统的作用
MySQL权限系统的主要功能是证实连接到一台给定主机的用户，并且赋予该用户在数据库上的SELECT、INSERT、UPDATE和DELETE权限。 
附加的功能包括有匿名的用户并对于MySQL特定的功能例如LOAD DATA INFILE进行授权及管理操作的能力。
5.7.2. 权限系统工作原理
MySQL权限系统保证所有的用户只执行允许做的事情。当你连接MySQL服务器时，你的身份由你从那儿连接的主机和你指定的用户名来决定。连接后发出请求后，系统根据你的身份和你想做什么来授予权限。
MySQL在认定身份中考虑你的主机名和用户名字，是因为几乎没有原因假定一个给定的用户在因特网上属于同一个人。例如，从office.com连接的用户joe不一定和从elsewhere.com连接的joe是同一个人。MySQL通过允许你区分在不同的主机上碰巧有同样名字的用户来处理它：你可以对joe从office.com进行的连接授与一个权限集，而为joe从elsewhere.com的连接授予一个不同的权限集。
MySQL存取控制包含2个阶段：
阶段1：服务器检查是否允许你连接。 
阶段2：假定你能连接，服务器检查你发出的每个请求。看你是否有足够的权限实施它。例如，如果你从数据库表中选择(select)行或从数据库删除表，服务器确定你对表有SELECT权限或对数据库有DROP权限。 
如果连接时你的权限被更改了(通过你和其它人)，这些更改不一定立即对你发出的下一个语句生效。详情参见5.7.7节，“权限更改何时生效”。
服务器在mysql数据库的 授权表中保存权限信息(即在mysql数据库中)。当MySQL服务器启动时将这些表的内容读入内存，在5.7.7节，“权限更改何时生效”的环境下重新读取它们。访问控制决策取决于内存中的 授权表的份数。
一般情况，你通过GRANT和REVOKE语句间接来操作 授权表的内容，设置账户并控制个人的权限。参见13.5.1.3节，“GRANT和REVOKE语法”。下面讨论了 授权表的结构以及服务器与客户端交互操作时如何使用其内容。
服务器在存取控制的两个阶段使用mysql数据库中的user、db和host表，这些授权表中的列如下：
表名
user
db
host
列范围
Host
Host
Host
 
User
Db
Db
 
Password
User
 
权限列
Select_priv
Select_priv
Select_priv
 
Insert_priv
Insert_priv
Insert_priv
 
Update_priv
Update_priv
Update_priv
 
Delete_priv
Delete_priv
Delete_priv
 
Index_priv
Index_priv
Index_priv
 
Alter_priv
Alter_priv
Alter_priv
 
Create_priv
Create_priv
Create_priv
 
Drop_priv
Drop_priv
Drop_priv
 
Grant_priv
Grant_priv
Grant_priv
 
Create_view_priv
Create_view_priv
Create_view_priv
 
Show_view_priv
Show_view_priv
Show_view_priv
 
Create_routine_priv
Create_routine_priv
 
 
Alter_routine_priv
Alter_routine_priv
 
 
References_priv
References_priv
References_priv
 
Reload_priv
 
 
 
Shutdown_priv
 
 
 
Process_priv
 
 
 
File_priv
 
 
 
Show_db_priv
 
 
 
Super_priv
 
 
 
Create_tmp_table_priv
Create_tmp_table_priv
Create_tmp_table_priv
 
Lock_tables_priv
Lock_tables_priv
Lock_tables_priv
 
Execute_priv
 
 
 
Repl_slave_priv
 
 
 
Repl_client_priv
 
 
安全列
ssl_type
 
 
 
ssl_cipher
 
 
 
x509_issuer
 
 
 
x509_subject
 
 
资源控制列
max_questions
 
 
 
max_updates
 
 
 
max_connections
 
 
 
max_user_connections
 
 
对存取控制的第二阶段(请求证实)，服务器执行请求验证以确保每个客户端有充分的权限满足各需求。除了user、db和host授权表，如果请求涉及表，服务器可以另外参考tables_priv和columns_priv表。tables_priv和columns_priv表可以对表和列提供更精确的权限控制。这些表的列如下：
表名
tables_priv
columns_priv
范围列
Host
Host
 
Db
Db
 
User
User
 
Table_name
Table_name
 
 
Column_name
权限列
Table_priv
Column_priv
 
Column_priv
 
其它列
Timestamp
Timestamp
 
Grantor
 
Timestamp和Grantor列当前还未使用，这儿不再进一步讨论。
为了对涉及保存程序的请求进行验证，服务器将查阅procs_priv表。该表具有以下列：
表名
procs_priv
范围列
Host
 
Db
 
User
 
Routine_name
 
Routine_type
权限列
Proc_priv
其它列
Timestamp
 
Grantor
Routine_type列为ENUM列，值为'FUNCTION'或'PROCEDURE'，表示行所指的程序类型。该列允许为同名函数和程序单独授权。
Timestamp和Grantor列当前还未使用，这儿不再进一步讨论。
每个授权表包含范围列和权限列：
l        范围列决定表中每个条目（行）的范围，即，行适用的上下文。例如, 一个user表行的Host和User值为'thomas.loc.gov'和'bob'，将被用于证实来自主机thomas.loc.gov的bob对服务器的连接。同样，一个db表行的Host、User和Db列的值是'thomas.loc.gov'、'bob'和'reports'将用在bob从主机thomas.loc.gov联接访问reports数据库的时候。tables_priv和columns_priv表包含范围列，指出每个行适用的表或表/列的组合。procs_priv范围列指出每个行适用的保存程序。
对于检查存取的用途，比较Host值是忽略大小写的。User、Password、Db和Table_name值是区分大小写的。Column_name值在MySQL3.22.12或以后版本是忽略大小写的。
l        权限列指出由一个表行授予的权限，即，可实施什么操作。服务器组合各种的授权表的信息形成一个用户权限的完整描述。为此使用的规则在5.7.6节，“访问控制, 阶段2：请求核实”描述。
范围列包含字符串，如下所述；每个列的默认值是空字符串：
列名
类型
Host
CHAR(60)
User
CHAR(16)
Password
CHAR(16)
Db
CHAR(64)
Table_name
CHAR(64)
Column_name
CHAR(64)
Routine_name
CHAR(64)
为了访问检查目的，Host值的比较对大小写不敏感。User、Password、Db和Table_name值对大小写敏感。Column_name值对大小写不敏感。
在user、db和host表中，所有权限列于单独的列内，被声明为ENUM('N','Y') DEFAULT 'N'。换句话说，每一个权限都可以被禁用和启用，并且 默认是禁用。
在tables_priv、columns_priv和procs_priv表中，权限列被声明为SET列。这些列的值可以包含该表控制的权限的组合：
表名
列名
可能的设置元素
tables_priv
Table_priv
'Select', 'Insert', 'Update', 'Delete', 'Create', 'Drop', 'Grant', 'References', 'Index', 'Alter'
tables_priv
Column_priv
'Select', 'Insert', 'Update', 'References'
columns_priv
Column_priv
'Select', 'Insert', 'Update', 'References'
procs_priv
Proc_priv
'Execute', 'Alter Routine', 'Grant'
简单地说，服务器使用这样的授权表：
·         user表范围列决定是否允许或拒绝到来的连接。对于允许的连接，user表授予的权限指出用户的全局(超级用户)权限。这些权限适用于服务器上的all数据库。
·         db表范围列决定用户能从哪个主机存取哪个数据库。权限列决定允许哪个操作。授予的数据库级别的权限适用于数据库和它的表。
·         当你想要一个给定的db表行应用于若干主机时，db和host表一起使用。例如，如果你想要一个用户能在你的网络从若干主机使用一个数据库，在用户的db表行的Host值设为空值，然后将那些主机的每一个移入host表。这个机制详细描述在5.7.6节，“访问控制, 阶段2：请求核实”。
注释：host表不受GRANT和REVOKE语句的影响。大多数MySQL安装根本不需要使用该表。
·         tables_priv和columns_priv表类似于db表，但是更精致：它们在表和列级应用而非在数据库级。授予表级别的权限适用于表和所有它的列。授予列级别的权限只适用于专用列。
·         procs_priv表适用于保存的程序。授予程序级别的权限只适用于单个程序。
管理权限(例如RELOAD或SHUTDOWN等等)仅在user表中被指定。这是因为管理性操作是服务器本身的操作并且不是特定数据库，因此没有理由在其他授权表中列出这样的权限。事实上，只需要查询user表来决定你是否执行一个管理操作。 
FILE权限也仅在user表中指定。它不是管理性权限，但你在服务器主机上读或写文件的能力与你正在存取的数据库无关。
当mysqld服务器启动时，将授权表的内容读入到内存中。你可以通过FLUSH PRIVILEGES语句或执行mysqladmin flush-privileges或mysqladmin reload命令让它重新读取表。对授权表的更改生效在5.7.7节，“权限更改何时生效”描述。 
当你修改授权表的内容时，确保你按你想要的方式更改权限设置是一个好主意。要检查给定账户的权限，使用SHOW GRANTS语句。例如，要检查Host和User值分别为pc84.example.com和bob的账户所授予的权限，应通过语句：
 
mysql> SHOW GRANTS FOR 'bob'@'pc84.example.com';
一个有用的诊断工具是mysqlaccess脚本，由Carlier Yves 提供给MySQL分发。使用--help选项调用mysqlaccess查明它怎样工作。注意：mysqlaccess仅用user、db和host表检查存取。它不检查tables_priv、columns_priv或procs_priv表中指定的表、列和程序级权限。
对于诊断权限相关的问题的其它帮助，参见5.7.8节，“拒绝访问错误的原因”。对于安全问题常规建议，参见5.6节，“一般安全问题”。
5.7.3. MySQL提供的权限
账户权限信息被存储在mysql数据库的user、db、host、tables_priv、columns_priv和procs_priv表中。在MySQL启动时并在5.7.7节，“权限更改何时生效”所说的情况时，服务器将这些数据库表内容读入内存。
GRANT和REVOKE语句所用的涉及权限的名称显示在下表，还有在授权表中每个权限的表列名称和每个权限有关的上下文。关于每个权限的含义相关的详细信息参见13.5.1.3节，“GRANT和REVOKE语法”。
权限
列
上下文
CREATE
Create_priv
数据库、表或索引
DROP
Drop_priv
数据库或表
GRANT OPTION
Grant_priv
数据库、表或保存的程序
REFERENCES
References_priv
数据库或表
ALTER
Alter_priv
表
DELETE
Delete_priv
表
INDEX
Index_priv
表
INSERT
Insert_priv
表
SELECT
Select_priv
表
UPDATE
Update_priv
表
CREATE VIEW
Create_view_priv
视图
SHOW VIEW
Show_view_priv
视图
ALTER ROUTINE
Alter_routine_priv
保存的程序
CREATE ROUTINE
Create_routine_priv
保存的程序
EXECUTE
Execute_priv
保存的程序
FILE
File_priv
服务器主机上的文件访问
CREATE TEMPORARY TABLES
Create_tmp_table_priv
服务器管理
LOCK TABLES
Lock_tables_priv
服务器管理
CREATE USER
Create_user_priv
服务器管理
PROCESS
Process_priv
服务器管理
RELOAD
Reload_priv
服务器管理
REPLICATION CLIENT
Repl_client_priv
服务器管理
REPLICATION SLAVE
Repl_slave_priv
服务器管理
SHOW DATABASES
Show_db_priv
服务器管理
SHUTDOWN
Shutdown_priv
服务器管理
SUPER
Super_priv
服务器管理
当从早期的没有CREATE VIEW、SHOW VIEW、CREATE ROUTINE、ALTER ROUTINE和EXECUTE权限的版本的MySQL中升级时，要想使用这些权限，你必须使用MySQL分发提供的mysql_fix_privilege_tables脚本升级 授权表。参见2.10.2节，“升级授权表”。
如果启用了二进制记录，要想创建或修改保存的程序，你还需要SUPER权限，详细描述见20.4节，“存储子程序和触发程序的二进制日志功能”。
通过CREATE和DROP权限，你可以创建新数据库和表，或删除(移掉)已有数据库和表。如果你将mysql数据库中的DROP权限授予某用户，用户可以删掉MySQL访问权限保存的数据库。
SELECT、INSERT、UPDATE和DELETE权限允许你在一个数据库现有的表上实施操作。 
SELECT语句只有在他们真正从一个表中检索行时才需要SELECT权限。一些SELECT语句不访问表，甚至没有任何到服务器上的数据库里的存取任何东西的许可。例如，你可使用mysql客户端作为一个简单的计算器来评估未引用表的表达式：
mysql> SELECT 1+1;
mysql> SELECT PI()*2;
INDEX权限允许你创建或删除索引。INDEX适用已有表。如果你具有某个表的CREATE权限，你可以在CREATE TABLE语句中包括索引定义。
通过ALTER权限，你可以使用ALTER TABLE来更改表的结构和重新命名表。
需要CREATE ROUTINE权限来创建保存的程序（函数和程序），ALTER ROUTINE权限来更改和删除保存的程序，EXECUTE来执行保存的程序。
GRANT权限允许你把你自己拥有的那些权限授给其他的用户。可以用于数据库、表和保存的程序。
FILE权限给予你用LOAD DATA INFILE和SELECT ... INTO OUTFILE语句读和写服务器上的文件，任何被授予FILE权限的用户都能读或写MySQL服务器能读或写的任何文件。(说明用户可以读任何数据库目录下的文件，因为服务器可以访问这些文件）。 FILE权限允许用户在MySQL服务器具有写权限的目录下创建新文件。不能覆盖已有文件。
其余的权限用于管理性操作，它使用mysqladmin程序或SQL语句实施。下表显示每个管理性权限允许你执行的mysqladmin命令：
权限
权限拥有者允许执行的命令
RELOAD
flush-hosts, flush-logs, flush-privileges, flush-status, flush-tables, flush-threads, refresh, reload
SHUTDOWN
shutdown
PROCESS
processlist
SUPER
kill
reload命令告诉服务器将授权表重新读入内存。flush-privileges是reload的同义词，refresh命令清空所有表并打开并关闭记录文件，其它flush-xxx命令执行类似refresh的功能，但是范围更有限，并且在某些情况下可能更好用。例如，如果你只是想清空记录文件，flush-logs比refresh是更好的选择。
shutdown命令关掉服务器。只能从mysqladmin发出命令。没有相应的SQL语句。
processlist命令显示在服务器内执行的线程的信息（即其它账户相关的客户端执行的语句）。kill命令杀死服务器线程。你总是能显示或杀死你自己的线程，但是你需要PROCESS权限来显示或杀死其他用户和SUPER权限启动的线程。参见13.5.5.3节，“KILL语法”。
拥有CREATE TEMPORARY TABLES权限便可以使用CREATE TABLE语句中的关键字TEMPORARY。 
拥有LOCK TABLES权限便可以直接使用LOCK TABLES语句来锁定你拥有SELECT权限的表。包括使用写锁定，可以防止他人读锁定的表。
拥有REPLICATION CLIENT权限便可以使用SHOW MASTER STATUS和SHOW SLAVE STATUS。
REPLICATION SLAVE权限应授予从服务器所使用的将当前服务器连接为主服务器的账户。没有这个权限，从服务器不能发出对主服务器上的数据库所发出的更新请求。
拥有SHOW DATABASES权限便允许账户使用SHOW DATABASE语句来查看数据库名。没有该权限的账户只能看到他们具有部分权限的数据库， 如果数据库用--skip-show-database选项启动，则根本不能使用这些语句。请注意全局权限指数据库的权限。
总的说来，只授予权限给需要他们的那些用户是好主意，但是你应该在授予FILE和管理权限时试验特定的警告：
FILE权限可以被滥用于将服务器主机上MySQL能读取的任何文件读入到数据库表中。包括任何人可读的文件和服务器数据目录中的文件。可以使用SELECT访问数据库表，然后将其内容传输到客户端上。 
GRANT权限允许用户将他们的权限给其他用户。有不同的权限并有GRANT权限的2个用户可以合并权限。 
ALTER权限可以用于通过重新命名表来推翻权限系统。 
SHUTDOWN权限通过终止服务器可以被滥用完全拒绝为其他用户服务。 
PROCESS权限能被用来察看当前执行的查询的明文文本，包括设定或改变密码的查询。 
SUPER权限能用来终止其它用户或更改服务器的操作方式。 
授给mysql数据库本身的权限能用来改变密码和其他访问权限信息。密码被加密存储，所以恶意的用户不能简单地读取他们以知道明文密码。然而，具有user表Password列写访问权限的用户可以更改账户的密码，并可以用该账户连接MySQL服务器。 
有一些事情你不能用MySQL权限系统做到：
你不能明显地指定某个给定的用户应该被拒绝访问。即，你不能明显地匹配用户然后拒绝连接。 
你不能指定用户有权创建立或删除数据库中的表，但不能创建或删除数据库本身。 
5.7.4. 与MySQL服务器连接
当你想要访问MySQL服务器时，MySQL客户端程序一般要求你指定参数：
·         MySQL服务器运行的主机名
·         姓名
·         密码
例如，可以从命令行按照下述提示启动MySQL客户端(用shell>表示)：
shell> MySQL -h host_name -u user_name -pyour_pass
-h, -u和-p选项还可以采用形式--host=host_name、--user=user_name和--password=your_pass。请注意在-p或--password=和后面的密码之间没有空格。
如果你使用-p或--password选项但没有指定密码值，客户端程序提示你输入密码。当你输入密码时并不显示密码。这比在在命令行输入密码要安全得多。系统上的任何用户可以通过命令ps auxww在命令行中指定密码。参见5.8.6节，“使你的密码安全”。
如果没有指定连接参数，MySQL客户端程序使用默认值：
默认主机名是localhost。 
默认用户名在Windows中是ODBC，在Unix中是你的Unix登录名。 
·         如果没有-p，则不提供密码。
这样, 对Unix用户joe，下列命令是等价的： 
shell> MySQL -h localhost -u joe
shell> MySQL -h localhost
shell> MySQL -u joe
shell> MySQL
其它MySQL客户端程序类似。
当进行连接时，你可以指定要使用的不同的默认值，这样不必每次在你调用客户端程序是在命令行上输入它们。这可以有很多方法做到：
你可以在选项文件的[client]小节里指定连接参数。文件的相关小节看上去可能像这样： 
·                [client]
·                host=host_name
·                user=user_name
·                password=your_pass
在4.3.2节，“使用选项文件”中详细讨论了选项文件。
你可以用环境变量指定连接参数。主机可用MYSQL_HOST指定，MySQL用户名可用USER指定(仅对Windows和NetWare)，密码可用MYSQL_PWD指定，尽管这不安全；参见5.8.6节，“使你的密码安全”。变量参见附录F：环境变量。 
5.7.5. 访问控制, 阶段1：连接核实
当你试图连接MySQL服务器时，服务器基于你的身份以及你是否能通过供应正确的密码验证身份来接受或拒绝连接。如果不是，服务器完全拒绝你的访问，否则，服务器接受连接，然后进入阶段2并且等待请求。
你的身份基于2个信息：
你从那个主机连接 
你的MySQL用户名 
身份检查使用3个user表(Host, User和Password)范围列执行。服务器只有在user表记录的Host和User列匹配客户端主机名和用户名并且提供了正确的密码时才接受连接。
在user表Host值的指定方法：
Host值可以是主机名或IP号，或'localhost'指出本地主机。 
你可以在Host列值使用通配符字符“%”和“_”。 
Host值'%'匹配任何主机名，空Host值等价于'%'。它们的含义与LIKE操作符的模式匹配操作相同。例如，'%'的Host值与所有主机名匹配，而'%.mysql.com'匹配mysql.com域的所有主机。 
·         对于指定为IP号的Host值，你可以指定一个网络掩码，说明使用多少位地址位来评比网络号。例如：
·                mysql> GRANT ALL PRIVILEGES ON db.*
·                    -> -> TO david@'192.58.197.0/255.255.255.0';
允许david从任何客户端用IP号client_ip来连接，下面的条件为真：
client_ip & netmask = host_ip
That is, for the GRANT statement just shown: 
client_ip & 255.255.255.0 = 192.58.197.0
满足该条件并可以连接MySQL服务器的IP号的范围为192.58.197.0到192.58.197.255。
·         注释：网络掩码只用来告诉服务器使用8、16、24或32位地址，例如：
·                192.0.0.0/255.0.0.0(192 A类网络的任何地址)
·                192.168.0.0/255.255.0.0(192.168 A类网络的任何地址)
·                192.168.1.0/255.255.255.0(192.168.1 C类网络的任何地址)
·                192.168.1.1(只有该IP)
下面的网络掩码(28 位)无效：
192.168.0.1/255.255.255.240
·         db表记录中的空Host值表示它的权限应结合匹配客户端名的host表中的行使用。通过AND(相与)而不是或(联合)操作将权限组合到一起。你可以从5.7.6节，“访问控制, 阶段2：请求核实”找到关于host表的详细信息。
其它grant表的空Host值与'%'相同。
既然你能在Host字段使用IP通配符值(例如，'144.155.166.%'匹配在一个子网上的每台主机)，有可能某人可能企图探究这种能力，通过命名一台主机为144.155.166.somewhere.com。为了阻止这样的企图，MySQL不允许匹配以数字和一个点起始的主机名，这样，如果你用一个命名为类似1.2.foo.com的主机，它的名字决不会匹配授权表中的Host列。只有一个IP数字能匹配IP通配符值。
通配符字符在User列中不允许，但是你能指定空的值，它匹配任何名字。如果user表匹配的连接有一个空用户名，用户被认为是匿名用户(没有名字的用户)，而非客户端实际指定的名字。这意味着一个空的用户名被用于在连接期间的进一步的访问检查(即，在阶段2期间)。
Password列可以是空的。这不是通配符，也不意味着匹配任何密码，它意味着用户必须不指定一个密码进行连接。
user表中的非空Password值代表加密的密码。MySQL不以任何人可以看的明文文本格式存储密码，相反，正在试图联接的用户提供的密码被加密(使用PASSWORD( )函数)，在连接过程中使用加密的密码检查密码是否正确。(加密后的密码未通过连接即可实现）。从MySQL角度，加密的密码是实际密码，因此你不应让其它人访问它！特别是，绝对不要让非管理用户读mysql数据库中的表！
MySQL 5.1使用强鉴定方法(最先在MySQL 4.1中适用)在前面的版本中在连接进程中的密码保护较好。即使TCP/IP包被截取或mysql数据库 被捕获也很安全。5.7.9节，“MySQL 4.1中的密码哈希处理”中详细讨论了密码加密。
下面的例子显示出各种user表中Host和User值的组合如何应用于到来的连接：
Host值
User值
被条目匹配的连接
'thomas.loc.gov' 
'fred' 
fred, 从thomas.loc.gov 连接
'thomas.loc.gov' 
'' 
任何用户, 从thomas.loc.gov连接
'%' 
'fred' 
fred, 从任何主机连接
'%' 
'' 
任何用户, 从任何主机连接
'%.loc.gov' 
'fred' 
fred, 从在loc.gov域的任何主机连接
'x.y.%' 
'fred' 
fred, 从x.y.net、x.y.com,x.y.edu等联接。（这或许无用）
'144.155.166.177' 
'fred' 
fred, 从有144.155.166.177 IP地址的主机连接
'144.155.166.%' 
'fred' 
fred, 从144.155.166 C类子网的任何主机连接
到来的连接中的客户端名和用户名可能与user表中的多行匹配。例如，由fred从thomas.loc.gov的连接匹配多个条目如上所述。
如果有多个匹配，服务器必须选择使用哪个条目。按照下述方法解决问题：
l        服务器在启动时读入user表后进行排序。
l        然后当用户试图连接时，以排序的顺序浏览条目
l        服务器使用与客户端和用户名匹配的第一行。
user表排序工作如下，假定user表看起来像这样：
+-----------+----------+-
| Host      | User     | …
+-----------+----------+-
| %         | root     | …
| %         | jeffrey  | …
| localhost | root     | …
| localhost |          | …
+-----------+----------+-
当服务器读取表时，它首先以最具体的Host值排序。主机名和IP号是最具体的。'%'意味着“任何主机”并且是最不特定的。有相同Host值的条目首先以最具体的User值排序(空User值意味着“任何用户”并且是最不特定的)。最终排序的user表看起来像这样：
+-----------+----------+-
| Host      | User     | …
+-----------+----------+-
| localhost | root     | … ...
| localhost |          | … ...
| %         | jeffrey  | … ...
| %         | root     | … ...
+-----------+----------+-
当客户端试图连接时，服务器浏览排序的条目并使用找到的第一匹配。对于由jeffrey从localhost的连接，表内有两个条目匹配：Host和User值为'localhost'和''的条目，和值为'%'和'jeffrey'的条目。'localhost'条目首先匹配，服务器可以使用。
还有一个例子。假定user表看起来像这样：
+----------------+----------+-
| Host           | User     | …
+----------------+----------+-
| %              | jeffrey  | …
| thomas.loc.gov |          | …
+----------------+----------+-
排序后的表看起来像这样：
+----------------+----------+-
| Host           | User     | …
+----------------+----------+-
| thomas.loc.gov |          | …
| %              | jeffrey  | …
+----------------+----------+-
由jeffrey从thomas.loc.gov的连接与第一行匹配，而由jeffrey从whitehouse.gov的连接被第二个匹配。
普遍的误解是认为，对给定的用户名，当服务器试图对连接寻找匹配时，明确命名那个用户的所有条目将首先被使用。这明显不符合事实。先前的例子说明了这点，在那里由jeffrey从thomas.loc.gov的连接没被包含'jeffrey'作为User列值的行匹配，但是由没有用户名的题目匹配！结果是，jeffrey被鉴定为匿名用户，即使他连接时指定了用户名。
如果你能够连接服务器，但你的权限不是你期望的，你可能被鉴定为其它账户。要想找出服务器用来鉴定你的账户，使用CURRENT_USER()函数。它返回user_name@host_name格式的值，说明User和Host 值匹配user表记录。假定jeffrey连接并发出下面的查询：
mysql> SELECT CURRENT_USER();
+----------------+
| CURRENT_USER() |
+----------------+
| @localhost     |
+----------------+
这儿显示的结果说明user表行有空的User列值。换句话说，服务器将jeffrey视为匿名用户。
诊断鉴定问题的另一个方法是打印出user表并且手动排序它看看第一个匹配在哪儿进行。又见12.9.3节，“信息函数”。
5.7.6. 访问控制, 阶段2：请求核实
一旦你建立了连接，服务器进入访问控制的阶段2。对在此连接上进来的每个请求，服务器检查你想执行什么操作，然后检查是否有足够的权限来执行它。这正是在授权表中的权限列发挥作用的地方。这些权限可以来自user、db、host、tables_priv或columns_priv表。（你会发现参考5.7.2节，“权限系统工作原理”很有帮助，它列出了每个 授权表中呈现的列。）
user表在全局基础上授予赋予你的权限，该权限不管当前的数据库是什么均适用。例如，如果user表授予你DELETE权限， 你可以删除在服务器主机上从任何数据库删除行！换句话说，user表权限是超级用户权限。只把user表的权限授予超级用户如服务器或数据库主管是明智的。对其他用户，你应该把在user表中的权限设成'N'并且仅在特定数据库的基础上授权。你可以为特定的数据库、表或列授权。
db和host表授予数据库特定的权限。在这些表中的范围列的值可以采用以下方式：
通配符字符“%”并“_”可用于两个表的Host和Db列。它们与用LIKE操作符执行的模式匹配操作具有相同的含义。如果授权时你想使用某个字符，必须使用反斜现引用。例如，要想在数据库名中包括下划线(‘_’)，在GRANT语句中用‘\_’来指定。 
在db表的'%'Host值意味着“任何主机”，在db表中空Host值意味着“对进一步的信息咨询host表”（本节后面将描述的一个过程）。 
在host表的'%'或空Host值意味着“任何主机”。 
在两个表中的'%'或空Db值意味着“任何数据库”。 
在两个表中的空User值匹配匿名用户。 
db和host表在服务器启动时被读取并排序(同时它读user表)。db表在Host、Db和User范围列上排序，并且host表在Host和Db范围列上排序。对于user表，首先根据最具体的值最后根据最不具体的值排序，并且当服务器寻找匹配条目时，它使用它找到的第一匹配。
tables_priv和columns_priv表授予表和列特定的权限。这些表的范围列的值可以如下被指定：
通配符“%”并“_”可用在使用在两个表的Host列。 
在两个表中的'%'或空Host意味着“任何主机”。 
在两个表中的Db、Table_name和Column_name列不能包含通配符或空。 
tables_priv和columns_priv表根据Host、Db和User列被排序。这类似于db表的排序，因为只有Host列可以包含通配符，排序更简单。
请求证实进程在下面描述。（如果你熟悉访问检查的源码，你会注意到这里的描述与在代码使用的算法略有不同。描述等价于代码实际做的东西；不同处只是使解释更简单。）
对需要管理权限的请求(SHUTDOWN、RELOAD等等)，服务器仅检查user表条目，因为那是唯一指定管理权限的表。如果行许可请求的操作，访问被授权，否则拒绝。例如，如果你想要执行mysqladmin shutdown，但是由于user表行没有为你授予HUTDOWN权限，甚至不用检查db或host表就拒绝你的访问。（因为它们不包含hutdown_priv行列，没有这样做的必要。）
对数据库有关的请求(INSERT、UPDATE等等)，服务器首先通过查找user表行来检查用户的全局(超级用户)权限。如果行允许请求的操作，访问被授权。如果在user表中全局权限不够，服务器通过检查db和host表确定特定的用户数据库权限：
1. 服务器在db表的Host、Db和User列上查找匹配。Host和User对应连接用户的主机名和MySQL用户名。Db列对应用户想要访问的数据库。如果没有Host和User的行，访问被拒绝。 
2. 如果db表中有匹配的行而且它的Host列不是空的，该行定义用户的数据库特定的权限。 
3. 如果匹配的db表的行的Host列是空的，它表示host表列举被允许访问数据库的主机。在这种情况下，在host表中作进一步查找以发现Host和Db列上的匹配。如果没有host表行匹配，访问被拒绝。如果有匹配，用户数据库特定的权限以在db和host表的行的权限，即在两个行都是'Y'的权限的交集(而不是并集！)计算。（这样你可以授予在db表行中的一般权限，然后用host表行按主机主机为基础有选择地限制它们。） 
在确定了由db和host表行授予的数据库特定的权限后，服务器把他们加到由user表授予的全局权限中。如果结果允许请求的操作，访问被授权。否则，服务器检查在tables_priv和columns_priv表中的用户的表和列权限并把它们加到用户权限中。基于此结果允许或拒绝访问。
用布尔术语表示，前面关于用户权限如何计算的描述可以这样总结：
global privileges
OR (database privileges AND host privileges)
OR table privileges
OR column privileges
它可能不明显，为什么呢，如果全局user行的权限最初发现对请求的操作不够，服务器以后把这些权限加到数据库、表并列的特定权限。原因是请求可能要求超过一种类型的权限。例如，如果你执行INSERT INTO ... SELECT语句，你就需要INSERT和SELECT权限。你的权限必须是user表行授予一个权限而db表行授予另一个权限。在这种情况下，你有必要的权限执行请求，但是服务器不能自己把两个表区别开来；两个行授予的权限必须组合起来。
host表不受GRANT或REVOKE语句的影响，因此在大多数MySQL安装中没有使用。如果你直接修改它，你可以用于某种专门目的，例如用来维护安全服务器列表。例如，在TcX，host表包含在本地网络上所有的机器的表。这些表被授予所有的权限。
你也可以使用host表指定不安全的主机。假定你有一台机器public.your.domain，它位于你认为不安全的公共区域，你可以用下列的host表条目允许除了那台机器外的网络上所有主机的访问：
+--------------------+----+-
| Host               | Db | ...
+--------------------+----+-
| public.your.domain | %  | ... (all privileges set to 'N')
| %.your.domain      | %  | ... (all privileges set to 'Y')
+--------------------+----+-
当然，一定要测试授权表中的行(例如，使用SHOW GRANTS或mysqlaccess)，确保你的访问权限实际按你期望的方式被设置。
5.7.7. 权限更改何时生效
当mysqld启动时，所有授权表的内容被读进内存并且从此时生效。
当服务器注意到授权表被改变了时，现存的客户端连接有如下影响： 
表和列权限在客户端的下一次请求时生效。 
数据库权限改变在下一个USE db_name命令生效。 
·         全局权限的改变和密码改变在下一次客户端连接时生效。
如果用GRANT、REVOKE或SET PASSWORD对授权表进行修改，服务器会注意到并立即重新将授权表载入内存。
如果你手动地修改授权表(使用INSERT、UPDATE或DELETE等等)，你应该执行mysqladmin flush-privileges或mysqladmin reload告诉服务器再装载授权表，否则你的更改将不会生效，除非你重启服务器。
如果你直接更改了授权表但忘记重载，重启服务器后你的更改方生效。这样可能让你迷惑为什么你的更改没有什么变化！
5.7.8. 拒绝访问错误的原因
当你试着联接MySQL服务器时，如果碰到问题，下面各项可以帮助你纠正问题：
·         确保服务器在运行。如果服务器没有运行，则你不能连接服务器。如果你视图连接服务器并看到下述消息，可能是服务器没有运行：
·                shell> mysql
·                ERROR 2003: Can't connect to MySQL server on 'host_name' (111)
·                shell> mysql
·                ERROR 2002: Can't connect to local MySQL server through socket
·                '/tmp/mysql.sock' (111)
也可能服务器正在运行，但你可能使用与服务器上侦听的不一样的TCP/IP端口、命名管道或Unix套接字文件。你可以调用客户端程序，指定端口选项来指示正确的端口或套接字选项来指示正确的命名管道或Unix套接字文件。要找出套接字文件的地点，应：
shell> netstat -ln | grep mysql
必须正确设置授权表，以便服务器可以使用它们进行访问控制。对于某些分发版类型(例如Windows中的二进制分发版或Linux中的RPM分发版),安装过程初始化包含 授权表的mysql数据库。如果分发版没有这样做，你必须运行mysql_install_db脚本来手动初始化授权表。详细内容参见2.9.2节，“Unix下安装后的过程”。 
确定是否要初始化授权表的一个方法是寻找数据目录下的mysql目录（数据目录名通常为data或var，位于MySQL安装目录下）。应保证MySQL数据库目录有文件“user.MYD”。否则，执行mysql_install_db脚本。运行并重启服务器后，执行该命令来测试初始权限：
shell> mysql -u root test
服务器应该让你无误地连接。
在新的安装以后，你应该连接服务器并且设置你的用户及其访问许可： 
·                shell> mysql -u root mysql
服务器应该让你连接，因为MySQL root用户初始时没有密码。那也是安全风险，当你正在设置其他MySQL用户时，也应设定root密码是一件重要的事请。关于设置初始密码的说明，参见2.9.3节，“使初始MySQL账户安全”。
如果你将一个现存的MySQL安装升级到较新的版本，运行了mysql_fix_privilege_tables脚本吗？如果没有，运行它。增加新功能后，授权表的结构可能会改变，因此更新后应确保表的结构随之更新。相关说明参见2.10.2节，“升级授权表”。 
·         如果客户端程序试图连接时收到以下错误信息，说明服务器需要新格式的密码，而客户端不能生成：
·                shell> mysql
·                Client does not support authentication protocol requested
·                by server; consider upgrading MySQL client
关于如何处理的详细信息，参见5.7.9节，“MySQL 4.1中的密码哈希处理”和A.2.3节，“客户端不支持鉴定协议”。
如果你作为root试试连接并且得到这个错误，这意味着，你没有行在user表中的User列值为'root'并且mysqld不能为你的客户端解析主机名： 
Access denied for user ''@'unknown' to database mysql 
在这种情况下，你必须用--skip-grant-tables选项重启服务器并且编辑“/etc/hosts”或“\windows\hosts”文件为你的主机增加行。
如果你从3.22.11以前的版本更新现存的MySQL安装到3.22.11版或以后版本，你运行了mysql_fix_privilege_tables脚本吗？如果没有，运行它。在GRANT语句变得能工作时，授权表的结构用MySQL 3.22.11修改 。 
·         记住客户端程序使用选项文件或环境变量中指定的连接参数。如果客户端程序发送不正确的默认连接参数，而你没有在命令行中指定，检查环境变量和适用的选项文件。例如，当你不用任何选项运行客户端程序，得到Access denied错误，确保你没有在选项文件中指定旧密码！
你可以通过使用--no-defaults选项调用客户端程序来禁用选项文件。例如：
shell> mysqladmin --no-defaults -u root version
客户端使用的选项文件见4.3.2节，“使用选项文件”。环境变量列于附录F：环境变量。
·         如果遇到下述错误，说明root密码错误：
·                shell> mysqladmin -u root -pxxxx ver
·                Access denied for user 'root'@'localhost' (using password: YES)
如果你未指定密码时出现前面的错误，说明某个选项文件中的密码不正确。试试前面所说的--no-defaults选项。
关于密码更改的信息参见5.8.5节，“设置账户密码”。
如果你丢失或忘记root密码，你可以用--skip-grant-tables重启 mysqld来更改密码。参见A.4.1节，“如何复位根用户密码”. 
·         如果你使用SET PASSWORD、INSERT或UPDATE更改密码，你必须使用  PASSWORD()函数加密密码。如果你不使用PASSWORD()函数，密码不工作。例如，下面的语句设置密码，但没能加密，因此用户后面不能连接：
·                mysql> SET PASSWORD FOR 'abe'@'host_name' = 'eagle';
相反，应这样设置密码：
mysql> SET PASSWORD FOR 'abe'@'host_name' = PASSWORD('eagle');
当你使用GRANT或CREATE USER语句或mysqladmin password命令指定密码时，不需要PASSWORD()函数，它们会自动使用PASSWORD()来加密密码。参见5.8.5节，“设置账户密码”和13.5.1.1节，“CREATE USER语法”。
·         localhost是你本地主机名的一个同义词，并且也是如果你不明确地指定主机而客户端尝试连接的默认主机。
要想在这种系统上避免该问题，你可以使用--host=127.0.0.1选项来明确命名服务器主机。这样将通过TCP/IP协议来连接本地mysqld服务器。你还可以指定--host选项使用TCP/IP，使用实际的本机主机名。在这种情况下，主机名必须指定为服务器主机上的user表行，即使你在服务器上运行客户端程序。
·         当尝试用mysql -u user_name与数据库连接时，如果你得到一个Access denied错误，可能会遇到与user表有关的问题，通过执行mysql -u root mysql并且执行下面的SQL语句进行检查：
·                mysql> SELECT * FROM user;
结果应该包含一个有Host和User列的行匹配你的计算机主机名和你的MySQL用户名。
Access denied错误消息将告诉你，你正在用哪个用户尝试登录，你正在试图连接哪个主机，是否使用了密码。通常，你应该在user表中有一行，正确地匹配在错误消息给出的主机名和用户名。例如，如果遇到包含using password: NO的错误信息，说明你登录时没有密码。 
·         如果当你试着从一个不是MySQL服务器正在运行的主机上连接时，遇到下列错误，那么在user表中没有匹配那台主机的行：
·                Host ... is not allowed to connect to this MySQL server
可以通过组合你正在试图连接的用户/主机名设置一个账户来修正它。如果你不知道正连接的机器的IP号或主机名，应该把一个'%'行作为Host列值放在user表中。在试图从客户端器连接以后，通过SELECT USER()查询显示你如何真正进行连接。（然后用在日志文件上面显示出的实际的主机名代替user表中的'%'行。否则，你将得到一个不安全的系统，因为它允许从任何主机上以任何用户名连接。）
在Linux中，发生该错误的另一个原因可能是你正使用于你所使用版本的glibc库不同版本的库编译的二进制MySQL版本。在这种情况下，你应升级操作系统或glibc，或下载MySQL版本的源码分发版并自己编译。源码RPM一般很容易编译并安装，因此不是大问题。
·         如果你连接时指定主机名，但得到错误消息主机名未显示或为IP号，表示当MySQL服务器将IP号解析为客户端来名时遇到错误：
·                shell> mysqladmin -u root -pxxxx -h some-hostname ver
·                Access denied for user 'root'@'' (using password: YES)
这表示DNS问题。要想修复，执行mysqladmin flush-hosts来重设内部 DNS主机名缓存。参见7.5.6节，“MySQL如何使用DNS”。
一些常用的解决方案包括：
o        试试找出DNS服务器的错误并修复。
o        在MySQL授权表中指定IP号而不是主机名。
o        在/etc/hosts中放入客户端名。
o        用--skip-name-resolve选项启动mysqld。
o        用--skip-host-cache选项启动mysqld。
o        在Unix中，如果你在同一台机器上运行服务器和客户端，连接到localhost。连接到的localhost的Unix连接使用Unix套接字文件而不是TCP/IP。
o        在Windows中，你在同一台机器上运行服务器和客户端并且服务器支持命名管道连接，连接主机名(周期)。连接使用命名管道而不是TCP/IP。
如果mysql -u root test工作但是mysql -h your_hostname -u root test导致Access denied（your_hostname是本地机的实际主机名），那么在user表中可能没有你的主机的正确名字。这里的一个普遍的问题是在user表行中的Host值指定一个唯一的主机名，但是你系统的名字解析例程返回一个完全正规的域名(或相反)。例如，如果你在user表中有一个主机是'tcx'的行，但是你的DNS告诉MySQL你的主机名是'tcx.subnet.se'，行将不工作。尝试把一个行加到user表中，它包含你主机的IP号作为Host列的值。（另外，你可以把一个行加到user表中，它有包含一个通配符如'tcx.%'的Host值。然而，使用以“%”结尾的主机名是不安全的并且不推荐！） 
如果mysql -u user_name test工作但是mysql -u user_name other_db_name不工作，你没有为给定的用户授予other_db_name数据库的访问权限。 
当在服务器上执行mysql -u user_name时，它工作，但是在其它远程客户端上执mysql -h host_name -u user_name时，它却不工作，你没有为给定的用户授予从远程主机访问服务器的权限。 
如果你不能弄明白你为什么得到Access denied，从user表中删除所有Host包含通配符值的行(包含“%”或“_”的条目)。一个很普遍的错误是用Host='%'和User='some_user'插入一个新行，认为这将允许你指定localhost从同一台机器进行连接。它不工作的原因是 默认权限包括一个有Host='localhost'和User=''的行，因为那个行的Host值'localhost'比'%'更具体，当从localhost连接时，它用于指向新行！正确的步骤是插入Host='localhost'和User='some_user'的第2个行，或删除Host='localhost'和User=''行。删除条目后，记住用FLUSH PRIVILEGES语句重载授权表。 
·         如果你得到下列错误，可以与db或host表有关：
·                Access to database denied
如果从db表中选择了在Host列有空值的条目，保证在host表中有一个或多个相应的条目，指定db表中的条目适用哪些主机。
·         如果你能够连接MySQL服务器，但如果在使用命令SELECT ... INTO OUTFILE或LOAD DATA INFILE语句时，你得到Access denied错误，在user表中的条目可能没有启用FILE权限。
·         如果你直接更改授权表(例如，使用INSERT、UPDATE或DELETE语句)并且你的更改好像被忽略了，记住你必须执行FLUSH PRIVILEGES语句或mysqladmin flush-privileges命令让服务器来重读授权表。否则，直到服务器下次重启，你的更改方有效。记住用UPDATE命令更改root密码后，在清空权限前，你不需要指定新密码，因为服务器还不知道你已经更改了密码！
·         如果你的权限似乎在一个会话过程中改变了，可能是一个超级用户改变了他们。再次装入授权表会影响新客户端连接，但是它也影响现存的连接，如5.7.7节，“权限更改何时生效”小节所述。
·         如果你有Perl、Python或ODBC程序的存取问题，试着用mysql -u user_name db_name或mysql -u user_name -pyour_pass db_name与服务器连接。如果你能用mysql客户端进行连接，这是程序的一个问题而不是访问权限的问题。（注意在-p和密码之间没有空格；也可以使用--password=your_pass语法指定密码。如果使用-p选项，MySQL提示你输入密码。）
·         为了测试，用--skip-grant-tables选项启动mysqld守护进程，然后你可以改变MySQL授权表并且使用mysqlaccess脚本检查你的修改是否有如期的效果。当你对你的改变满意时，执行mysqladmin flush-privileges告诉mysqld服务器开始使用新的 授权表。（再次装入授权表覆盖了--skip-grant-tables选项。这允许你告诉服务器开始使用授权表，而不用停掉并重启它）。
·         如果任何其它事情失败，用调试选项(例如，--debug=d,general,query)启动mysqld服务器。这将打印有关尝试连接的主机和用户信息，和发出的每个命令的信息。请参见E.1.2节，“创建跟踪文件”。
·         如果你有任何与MySQL授权表的其它问题，而且觉得你必须将这个问题发送到邮件表，一定要提供一个MySQL授权表的倾倒副本(dump)。你可用mysqldump mysql命令复制数据库表。象平时一样，用mysqlbug脚本邮寄你的问题。参见1.7.1.3节，“如何通报缺陷和问题”。在一些情况下可以用--skip-grant-tables重启mysqld以便能运行mysqldump。
  
5.7.9. MySQL 4.1中的密码哈希处理
5.7.9.1. 更改应用程序密码哈希值的含义 
MySQL用户账户列于mysql数据库中的user表内。每个MySQL账户指定一个密码，尽管保存在user表Password列的密码不是明文，但哈希值是从表中的记录计算的。用PASSWORD()函数来计算密码的哈希值。
MySQL在客户端/服务器通信的两个阶段使用密码：
·         如果客户端试图连接服务器，有一个初始鉴定步骤，客户必须提供一个密码，并且必须与客户想要使用的账户在user表保存的哈希值匹配。
·         客户端连接后，它可以(如果有充分的权限) 设置或更改user表内所列的账户的密码哈希值值。客户端可以通过PASSWORD()函数来生成密码哈希值，或使用GRANT或SET PASSWORD语句。
换句话说，当客户端首次试图连接时，服务器使用哈希值进行鉴定。如果连接的客户端调用PASSWORD()函数或使用GRANT或SET语句来设置或更改密码，则服务器产生哈希值。
在MySQL 4.1中密码哈希算法已经更新，提供了更好的安全性并降低了密码被截取的风险。但是，该新机制只能在MySQL 4.1(和更新版本的)服务器和客户端中使用，会产生一些兼容性问题。4.1或新客户端可以连接4.1之前的服务器，因为客户端可以同时理解旧的和新的密码哈希机制。但是，4.1之前的客户端试图连接4.1版或更新版的服务器时会遇到困难。例如，3.23版mysql客户端试图连接5.1服务器时会失败并出现下面的错误消息：
shell> mysql -h localhost -u root
Client does not support authentication protocol requested
by server; consider upgrading MySQL client
出现该问题的另一个普通例子是在升级到MySQL 4.1或更新版后，试图使用旧版本的PHP mysql扩展名。(参见25.3.1节，“使用MySQL和PHP的常见问题”）。 
下面讨论了新、旧密码机制之间的差别，以及如果你升级了服务器但需要为4.1版以前的客户端保持向后兼容性该怎样做。A.2.3节，“客户端不支持鉴定协议”中有更详细的信息。该信息将MySQL数据库从4.0版本或更低版升级到4.1版或更高版的PHP编程人员特别重要。
注释：该讨论对比了4.1版的行为和4.1前的行为，这儿描述的4.1中的行为实际上从4.1.1开始。MySQL 4.1.0是一个“旧”的发布，因为它的实施机制与4.1.1版和更新版中的稍有不同。在MySQL 5.0 参考手册中详细描述了4.1.0和最新版之间的差别。
在MySQL 4.1之前,用PASSWORD()函数计算的密码哈希值有16个字节长。应为：
mysql> SELECT PASSWORD('mypass');
+--------------------+
| PASSWORD('mypass') |
+--------------------+
| 6f8c114b58f2ce9e   |
+--------------------+
在MySQL 4.1之前，user表的Password列(保存了哈希值)也是16字节长。
在MySQL 4.1中,已经对PASSWORD()函数进行了修改，可以生成41字节的哈希值：
mysql> SELECT PASSWORD('mypass');
+-------------------------------------------+
| PASSWORD('mypass')                        |
+-------------------------------------------+
| *6C8989366EAF75BB670AD8EA7A7FC1176A95CEF4 |
+-------------------------------------------+
同样，user表的Password列必须有41字节长来保存这些值：
·         如果你新安装MySQL 5.1, Password列自动为41字节长。
·         从MySQL 4.1(4.1.1或4.1系列的更新版)升级到MySQL 5.1，应不会出现相关问题，因为两个版本使用相同的密码哈希机制。如果你想要将更早版本的MySQL升级到MySQL5.1,你应先升级到4.1，然后将4.1升级到5.1。
加宽的Password列可以同时保存新、旧格式的密码哈希值。可以有两种方式确定任何给定格式的密码哈希值：
·         明显的不同之处是长度(16字节和41字节)。
·         第2个不同之处是新格式的密码哈希值都以‘*’字符开头，而旧格式的密码绝对不是。
 长密码哈希值具有更好的加密属性，并且客户端根据长哈希值进行鉴定比旧的短哈希值更加安全。
短密码哈希值和长密码哈希值之间的不同之处与服务器如何使用密码进行鉴定以及如何为执行密码更改操作的连接的客户端生成密码哈希值都有关。
服务器使用密码哈希值进行鉴定的方式受Password列的宽度影响：
·         如果列较短，只用短哈希鉴定。
·         如果列较长，可以有短或长哈希值，并且服务器可以使用任何一种格式：
o        4.1之前的客户端可以连接，它们只可以使用旧的哈希机制，它们可以只鉴定有短哈希的账户。
o        4.1及以后版本的客户端可以鉴定有短哈希或长哈希的账户。
对于短哈希账户的鉴定过程，4.1和以后版本的客户端比为旧版本的客户端实际要安全得多。从安全性角度，从最低安全到最安全的梯度为：
·         4.1之前的客户端用短密码哈希值进行鉴定
·         4.1或以后版本的客户端用短密码哈希值进行鉴定
·         4.1或以后版本的客户端用长密码哈希值进行鉴定
服务器为连接的客户端生成密码哈希值的方式受Password列宽度和--old-passwords选项的影响。4.1或更新版本的服务器只有满足某个条件才生成长哈希：Password列必须足够宽以容纳长哈希值并且未给定--old-passwords选项。这些条件适合：
·         Password列必须足够宽以容纳长哈希(41字节)值。如果列没有更新，仍然为4.1之前的16字节宽，当客户端使用PASSWORD()、GRANT或SET PASSWORD执行密码更改操作时，服务器注意到长哈希不适合，只生成短哈希。如果你已经升级到4.1但还没有运行 mysql_fix_privilege_tables脚本来扩宽Password列时会出现这种行为。
·         如果Password列足够宽，则可以保存短或长密码哈希值。在这种情况下，PASSWORD()、GRANT或SET PASSWORD生成长哈希，除非 用--old-passwords选项启动服务器。该选项强制服务器生成短密码哈希值。
--old-passwords选项的目的是当服务器生成长密码哈希值时，允许你维持同4.1之前的客户端的向后兼容性。该选项不影响鉴定(4.1和以后版本的客户端仍然可以使用有长密码哈希值的账户)，但它防止在密码更改操作中在user表中创建长密码哈希值。在这种情况下，该账户不能再用于4.1之前的客户端。没有--old-passwords选项，可能会出现下面的不期望的情况：
·         旧客户端连接有短密码哈希值的账户。
·         客户更改自己的密码。没有--old-passwords，可以为该账户生成长密码哈希值。
·         下次旧客户试图连接账户时不能连接上，因为账户有长密码哈希值，需要新的哈希机制进行鉴定。(一旦账户user表中为长密码哈希值，只有4.1和以后版本的客户端可以鉴定它，因为4.1之前的客户端不理解长哈希）。 
该场景说明，如果你必须支持旧的4.1之前的客户端，不使用--old-passwords选项运行4.1或更新版本的服务器很危险。用--old-passwords运行服务器，密码更改操作不会生成长密码哈希值，这样旧客户端也可以访问账户。(这些客户端不能意外地因更改了密码将自己锁出去，并留下长密码哈希值）。 
--old-passwords选项的不利之处是你创建或更改的密码使用短哈希，甚至对于4.1客户端也如此。这样，你丢失了长密码哈希值提供的安全性。如果你想要创建有长哈希的账户(例如，为4.1客户端)，你必须不使用--old-passwords来运行服务器。
下面的场景可用于运行4.1或以后的服务器，包括MySQL 5.1：
场景1：user表中的短Password列：
·         只有短哈希可以保存到Password列。
·         服务器只使用短哈希进行客户端鉴定。
·         对于连接的客户端，调用PASSWORD()、GRANT或SET PASSWORD的密码哈希生成操作专使用短哈希。对账户的任何更改均会生成短密码哈希值。
·          --old-passwords选项可以使用但是多余，因为Password列较短，服务器只生成短密码哈希值。
场景2：长Password列；没有用--old-passwords选项启动服务器：
·         短或长哈希可以保存到Password列。
·         4.1和以后版本的客户端(包括5.1客户端)可以鉴定有短或长哈希的账户。
·         4.1之前的客户端只能鉴定有短哈希的账户。
·         对于连接的客户端，调用PASSWORD()、GRANT或SET PASSWORD的密码哈希生成操作专使用短哈希。对账户的任何更改均会生成短密码哈希值。
如前面所示，该场景的危险性在于4.1之前的客户端可能不能访问有短密码哈希值的账户。通过PASSWORD()、GRANT或SET PASSWORDA对这些账户密码的更改会产生长的密码哈希值。从该点看，4.1之前的客户端升级到4.1之前不能鉴定该账户。
要处理该问题，可以用特殊方法更改密码。例如，一般情况你可以使用SET PASSWORD按照下面的方法更改账户密码：
mysql> SET PASSWORD FOR 'some_user'@'some_host' = PASSWORD('mypass');
要想更改密码但创建短哈希，使用OLD_PASSWORD()函数：
mysql> SET PASSWORD FOR 'some_user'@'some_host' = OLD_PASSWORD('mypass');
当你想明显生成短哈希时，OLD_PASSWORD()很有用。
场景3：长Password列；用--old-passwords选项启动4.1或新版本的服务器：
·         短或长哈希可以保存到Password列。
·         4.1和以后版本的客户端可以鉴定有短或长哈希的账户(请注意只有不使用--old-passwords选项启动服务器，方可以创建长哈希)。
·         4.1之前的客户端只可以鉴定短哈希账户。
·         对于连接的客户端，调用PASSWORD()、GRANT或SET PASSWORD的密码哈希生成操作专使用短哈希。对账户的任何更改均会生成短密码哈希值。
在该场景中，你不能创建长密码哈希值的账户，因为--old-passwords选项防止生成长哈希。并且，如果你在使用--old-passwords选项前创建长哈希账户，当--old-passwords有时更改账户密码，结果会使账户的密码为短密码，安全性较长哈希要降低。
这些场景的不利之处可以概括为：
在场景1中,你不能利用长哈希提供更安全的鉴定。
在场景2中, 如果你没有显式使用OLD_PASSWORD()来更改密码，则4.1之前的客户端不能再访问短哈希账户。
在场景3中,--old-passwords防止短哈希账户不可访问，但密码更改操作使账户的长哈希转换为短哈希，当--old-passwords有效时不能将它改回长哈希。
5.7.9.1. 更改应用程序密码哈希值的含义
升级到MySQL4.1或更新版本后，使用PASSWORD()为自己的目的生成密码的应用程序会出现兼容性问题。应用程序实际不应这样做，因为PASSWORD()只应用来管理MySQL账户的密码。但一些应用程序使用PASSWORD()用于自己的目的。
如果你从MySQL 4.1之前的版本升级到4.1或以后版本，并在生成长密码哈希值的条件下运行服务器，应用程序使用PASSWORD()破解自己的密码。这种情况下推荐的方法是修改应用程序，使用其它函数，例如SHA1()或MD5()，来产生哈希值。如果不行，你可以使用OLD_PASSWORD()函数，该函数用来提供旧格式的短哈希。但是，请注意OLD_PASSWORD()可能有一天不再被支持。
如果服务器运行在生成短哈希的条件下，可以使用 OLD_PASSWORD()但与PASSWORD()等同。
将MySQL数据库从4.0或更低版本移植到4.1或更高版本的PHP编程人员应参阅旧客户端。
5.8. MySQL用户账户管理
5.8.1. MySQL用户名和密码 
5.8.2. 向MySQL增加新用户账户 
5.8.3. 从MySQL删除用户账户 
5.8.4. 限制账户资源 
5.8.5. 设置账户密码 
5.8.6. 使你的密码安全 
5.8.7. 使用安全连接
本节描述如何为MySQL服务器的客户端设置账户。讨论了下面的主题：
·         MySQL使用的账户名和密码的含义，以及如何比较你的操作系统所使用的账户名和密码
·         如何设置新账户并移除已有账户
·         如何更改密码
·         安全使用密码指导
·         如何使用安全SSL连接 
5.8.1. MySQL用户名和密码
用用户名和客户端或主机定义MySQL账户，用户可以根据这些名称来连接服务器。账户也有密码。MySQL和操作系统使用用户名和密码的方式有几处区别：
·         MySQL用于鉴定目的用户名与Windows或Unix使用的用户名(登录名)没有关系。在Unix中，大多数MySQL客户端默认试图使用当前Unix的用户名作为MySQL用户名来登录，但这样只是为了方便。 默认值可以很容易被覆盖，因为客户端程序允许用-u或--user选项来指定用户名。因为这表示任何人可以试图使用任何用户名来连接服务器，除非所有MySQL账户有密码，否则你不能使数据库保持安全。通过为没有密码的账户指定用户名，任何人能够成功连接服务器。
·         MySQL用户名最大客达16字符长。这样可以限制MySQL服务器和客户端之间的硬编码，并且防止通过修改mysql数据库中表的定义来偷窃密码。
注:你应绝对不要以任何方式修改mysql数据库中的任何表，只能运行MySQL分发中专为此目的提供的脚本。将MySQL系统表重新定义为其它方式会导致未定义的(和不支持的!)行为。
操作系统用户名与MySQL用户名完全不相关，甚至最大长度可能不同。例如， Unix用户名限制为8个字符。
·         MySQL密码与登录到你的操作系统的密码没有关系。不需要将你用来登录Windows或Unix机器的密码和你用来访问该机器上的MySQL服务器的密码关联起来。
·         MySQL的加密密码使用自己的算法。该加密算法不同于Unix登录过程使用的算法。MySQL密码加密与PASSWORD()SQL函数的方法相同。Unix密码加密与ENCRYPT()SQL函数的方法相同。PASSWORD()和ENCRYPT()函数的描述参见12.9.2节，“加密函数”。从版本4.1 起，MySQL使用更强的鉴定方法，同以前的版本相比可以在连接过程中提供更好的密码保护。即使TCP/IP包被截取或mysql数据库被捕获也很安全。(在前面的版本中，即使密码以加密形式保存到user表中，仍可以通过加密密码值来连接MySQL服务器）。
当安装MySQL时，授权表装载时有一系列初使账户。这些账户的名称和访问权限见2.9.3节，“使初始MySQL账户安全”，其中还讨论了如何未这些账户赋予密码。因此，你一般应使用GRANT和REVOKE语句来设置、修改和移除MySQL账户。参见13.5.1.3节，“GRANT和REVOKE语法”。
当用命令行客户端连接MySQL服务器时，你应为想要使用的账户指定用户名和密码：
shell> mysql --user=monty --password=guess db_name
如果你想用较短的选项，命令应为：
shell> mysql -u monty -pguess db_name
-p选项和后面的密码值之间绝对不能有空格。参见5.7.4节，“与MySQL服务器连接”。
前面的命令包括命令行中的密码值，会很危险。参见5.8.6节，“使你的密码安全”。要想避免，指定--password或-p选项后面不跟任何密码值：
shell> mysql --user=monty --password db_name
shell> mysql -u monty -p db_name
然后客户端程序输出提示符并等待你输入密码。(在这些示例中，db_name并不为密码，因为用空格将它同前面的密码项隔离开了）。
在一些系统中，MySQL用来提示输入密码的库调用自动将密码限制到8个字符。这是系统库的问题，而不是MySQL的问题。MySQL本身并不限制密码的长度。要解决该问题，将MySQL密码改为8个字符和更少字符的值，或将密码放入选项文件中。
5.8.2. 向MySQL增加新用户账户
可以用两种方式创建MySQL账户：
·         使用GRANT语句
·         直接操作MySQL授权表
最好的方法是使用GRANT语句，因为这样更精确，错误少。从MySQL 3.22.11起提供了GRANT；其语法见13.5.1.3节，“GRANT和REVOKE语法”。
创建账户的其它方法是使用MySQL账户管理功能的第三方程序。phpMyAdmin即是一个程序。
下面的示例说明如何使用MySQL客户端程序来设置新用户。假定按照2.9.3节，“使初始MySQL账户安全”描述的 默认值来设置权限。这说明为了更改，你必须以MySQL root用户连接MySQL服务器，并且root账户必须有mysql数据库的INSERT权限和RELOAD管理权限。
首先，使用MySQL程序以MySQL root用户来连接服务器：
shell> MySQL --user=root MySQL
如果你为root账户指定了密码，还需要为该MySQL命令和本节中的其它命令提供--password或-p选项。
以root连接到服务器上后，可以添加新账户。下面的语句使用GRANT来设置四个新账户：
mysql> GRANT ALL PRIVILEGES ON *.* TO 'monty'@'localhost'
    ->     IDENTIFIED BY 'some_pass' WITH GRANT OPTION;
mysql> GRANT ALL PRIVILEGES ON *.* TO 'monty'@'%'
    ->     IDENTIFIED BY 'some_pass' WITH GRANT OPTION;
mysql> GRANT RELOAD,PROCESS ON *.* TO 'admin'@'localhost';
mysql> GRANT USAGE ON *.* TO 'dummy'@'localhost';
用GRANT语句创建的账户有下面的属性：
·         其中两个账户有相同的用户名monty和密码some_pass。两个账户均为超级用户账户，具有完全的权限可以做任何事情。一个账户 ('monty'@'localhost')只用于从本机连接时。另一个账户('monty'@'%')可用于从其它主机连接。请注意monty的两个账户必须能从任何主机以monty连接。没有localhost账户，当monty从本机连接时，mysql_install_db创建的localhost的匿名用户账户将占先。结果是，monty将被视为匿名用户。原因是匿名用户账户的Host列值比'monty'@'%'账户更具体，这样在user表排序顺序中排在前面。(user表排序的讨论参见5.7.5节，“访问控制, 阶段1：连接核实”）。 
·         一个账户有用户名admin，没有密码。该账户只用于从本机连接。授予了RELOAD和PROCESS管理权限。这些权限允许admin用户执行mysqladmin reload、mysqladmin refresh和mysqladmin flush-xxx命令，以及mysqladmin processlist。未授予访问数据库的权限。你可以通过GRANT语句添加此类权限。
·         一个账户有用户名dummy，没有密码。该账户只用于从本机连接。未授予权限。通过GRANT语句中的USAGE权限，你可以创建账户而不授予任何权限。它可以将所有全局权限设为'N'。假定你将在以后将具体权限授予该账户。
除了GRANT，你可以直接用INSERT语句创建相同的账户，然后使用FLUSH PRIVILEGES告诉服务器重载授权表：
shell> mysql --user=root mysql
mysql> INSERT INTO user
    ->     VALUES('localhost','monty',PASSWORD('some_pass'),
    ->     'Y','Y','Y','Y','Y','Y','Y','Y','Y','Y','Y','Y','Y','Y');
mysql> INSERT INTO user
    ->     VALUES('%','monty',PASSWORD('some_pass'),
    ->     'Y','Y','Y','Y','Y','Y','Y','Y','Y','Y','Y','Y','Y','Y');
mysql> INSERT INTO user SET Host='localhost',User='admin',
    ->     Reload_priv='Y', Process_priv='Y';
mysql> INSERT INTO user (Host,User,Password)
    ->     VALUES('localhost','dummy','');
mysql> FLUSH PRIVILEGES;
当你用INSERT创建账户时使用FLUSH PRIVILEGES的原因是告诉服务器重读授权表。否则，只有重启服务器后更改方会被注意到。使用 GRANT，则不需要使用FLUSH PRIVILEGES。
用INSERT使用PASSWORD()函数是为了加密密码。GRANT语句为你加密密码，因此不需要PASSWORD()。
'Y'值启用账户权限。对于admin账户，还可以使用更加可读的INSERT扩充的语法（使用SET）。
在为dummy账户的INSERT语句中，只有user表中的Host、User和Password列记录为指定的值。没有一个权限列为显式设置，因此MySQL将它们均指定为 默认值'N'。这样等同于GRANT USAGE的操作。
请注意要设置超级用户账户，只需要创建一个权限列设置为'Y'的user表条目。user表权限为全局权限，因此其它 授权表不再需要条目。
下面的例子创建3个账户，允许它们访问专用数据库。每个账户的用户名为custom，密码为obscure。
要想用GRANT创建账户，使用下面的语句：
shell> MySQL --user=root MySQL
shell> mysql --user=root mysql
mysql> GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP
    ->     ON bankaccount.*
    ->     TO 'custom'@'localhost'
    ->     IDENTIFIED BY 'obscure';
mysql> GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP
    ->     ON expenses.*
    ->     TO 'custom'@'whitehouse.gov'
    ->     IDENTIFIED BY 'obscure';
mysql> GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP
    ->     ON customer.*
    ->     TO 'custom'@'server.domain'
    ->     IDENTIFIED BY 'obscure';
这3个账户可以用于：
·         第1个账户可以访问bankaccount数据库，但只能从本机访问。
·         第2个账户可以访问expenses数据库，但只能从主机whitehouse.gov访问。
·         第3个账户可以访问customer数据库，但只能从主机server.domain访问。
要想不用GRANT设置custom账户，使用INSERT语句直接修改 授权表：
shell> mysql --user=root mysql
mysql> INSERT INTO user (Host,User,Password)
    ->     VALUES('localhost','custom',PASSWORD('obscure'));
mysql> INSERT INTO user (Host,User,Password)
    ->     VALUES('whitehouse.gov','custom',PASSWORD('obscure'));
mysql> INSERT INTO user (Host,User,Password)
    ->     VALUES('server.domain','custom',PASSWORD('obscure'));
mysql> INSERT INTO db
    ->     (Host,Db,User,Select_priv,Insert_priv,
    ->     Update_priv,Delete_priv,Create_priv,Drop_priv)
    ->     VALUES('localhost','bankaccount','custom',
    ->     'Y','Y','Y','Y','Y','Y');
mysql> INSERT INTO db
    ->     (Host,Db,User,Select_priv,Insert_priv,
    ->     Update_priv,Delete_priv,Create_priv,Drop_priv)
    ->     VALUES('whitehouse.gov','expenses','custom',
    ->     'Y','Y','Y','Y','Y','Y');
mysql> INSERT INTO db
    ->     (Host,Db,User,Select_priv,Insert_priv,
    ->     Update_priv,Delete_priv,Create_priv,Drop_priv)
    ->     VALUES('server.domain','customer','custom',
    ->     'Y','Y','Y','Y','Y','Y');
mysql> FLUSH PRIVILEGES;
 
前3个INSERT语句在user表中加入条目，允许用户custom从各种主机用给定的密码进行连接，但不授予全局权限(所有权限设置为 默认值'N')。后面3个INSERT语句在user表中加入条目，为custom授予bankaccount、expenses和customer数据库权限，但只能从合适的主机访问。通常若直接修改 授权表，则应告诉服务器用FLUSH PRIVILEGES重载授权表，使权限更改生效。
如果你想要让某个用户从给定域的所有机器访问(例如，mydomain.com)，你可以在账户名的主机部分使用含‘%’通配符的GRANT语句：
mysql> GRANT ...
    ->     ON *.*
    ->     TO 'myname'@'%.mydomain.com'
    ->     IDENTIFIED BY 'mypass';
要想通过直接修改授权表来实现：
mysql> INSERT INTO user (Host,User,Password,...)
    ->     VALUES('%.mydomain.com','myname',PASSWORD('mypass'),...);
mysql> FLUSH PRIVILEGES;
5.8.3. 从MySQL删除用户账户
要想移除账户，应使用DROP USER语句，请参见13.5.1.2节，“DROP USER语法”。
5.8.4. 限制账户资源
限制MySQL服务器资源使用的一个方法是将max_user_connections系统变量设置为非零值。但是，该方法严格限于全局，不允许管理具体账户。并且，它只限制使用单一账户同时连接的数量，而不是客户端连接后的操作。许多MySQL管理员对两种类型的控制均感兴趣，特别是Internet服务提供者。
在MySQL 5.1中,你可以为具体账户限制下面的服务器资源：
·         账户每小时可以发出的查询数
·         账户每小时可以发出的更新数
·         账户每小时可以连接服务器的次数
客户端可以执行的语句根据查询限制来记数。只有修改数据库或表的语句根据更新限制来记数。
还可以限制每个账户的同时连接服务器的连接数。
本文中的账户为user表中的单个记录。根据User和Host列值唯一识别每个账户。
做为使用该特性的先决条件，mysql数据库的user表必须包含资源相关的列。资源限制保存在max_questions、max_updates、max_connections和max_user_connections列内。如果user表没有这些列，必须对它进行升级；参见2.10.2节，“升级授权表”。
要想用GRANT语句设置资源限制，使WITH子句来命名每个要限制的资源和根据每小时记数的限制值。例如，要想只以限制方式创建可以访问customer数据库的新账户，执行该语句：
mysql> GRANT ALL ON customer.* TO 'francis'@'localhost'
    ->     IDENTIFIED BY 'frank'
    ->     WITH MAX_QUERIES_PER_HOUR 20
    ->          MAX_UPDATES_PER_HOUR 10
    ->          MAX_CONNECTIONS_PER_HOUR 5
    ->          MAX_USER_CONNECTIONS 2;
限制类型不需要全部在WITH子句中命名，但已经命名的可以按任何顺序。每个每小时限制值均应为整数，代表每小时的记数。如果GRANT语句没有WITH子句，则每个限制值设置为 默认值零(即没有限制)。对于MAX_USER_CONNECTIONS，限制为整数，表示账户一次可以同时连接的最大连接数。如果限制设置为 默认值零，则根据MAX_USER_CONNECTIONS系统变量确定该账户可以同时连接的数量。
要想设置或更改已有账户的限制，在全局级别使用GRANT USAGE语句(在*.*)。下面的语句可以将francis的查询限制更改为100：
mysql> GRANT USAGE ON *.* TO 'francis'@'localhost'
    ->     WITH MAX_QUERIES_PER_HOUR 100;
该语句没有改变账户的已有权限，只修改了指定的限制值。
要想取消已有限制，将该值设置为零。例如，要想取消francis每小时可以连接的次数的限制，使用该语句：
mysql> GRANT USAGE ON *.* TO 'francis'@'localhost'
    ->     WITH MAX_CONNECTIONS_PER_HOUR 0;
当账户使用资源时如果有非零限制，则对资源使用进行记数。
服务器运行时，它统计每个账户使用资源的次数。如果账户在最后一个小时的连接次数达到限制，该账户的进一步的连接被拒绝。类似地，如果账户达到查询或更新次数的限制，进一步的查询或更新被拒绝。在这种情况下，会给出相关错误消息。
根据每个账户进行资源计算，而不是根据每个客户端。例如，如果你的账户的查询限制为50,你不能通过两个客户端同时连接服务器将限制增加到100。两个连接的查询被计算到一起。
可以为所有账户从全局重设当前的每小时资源使用记数，或单独重设给定的账户：
·         要想将所有账户当前的记数重设为零，可以执行FLUSH USER_RESOURCES语句。还可以通过重载授权表来重设记数(例如，使用FLUSH PRIVILEGES语句或mysqladmin reload命令)。
·         将具体账户的限制重新授予任何值，可以将它设置为零。要想实现，按照前面所述使用GRANT USAGE，并将限制值指定为该账户当前的限制值。
计数器重设不影响MAX_USER_CONNECTIONS限制。
当服务器启动时所有记数从零开始。
5.8.5. 设置账户密码
可以用mysqladmin命令在命令行指定密码：
shell> mysqladmin -u user_name -h host_name password "newpwd"
该命令重设密码的账户为user表内匹配User列的user_name和Host列你发起连接的客户端的记录。
为账户赋予密码的另一种方法是执行SET PASSWORD语句：
mysql> SET PASSWORD FOR 'jeffrey'@'%' = PASSWORD('biscuit');
只有root等可以更新mysql数据库的用户可以更改其它用户的密码。如果你没有以匿名用户连接，省略FOR子句便可以更改自己的密码：
mysql> SET PASSWORD = PASSWORD('biscuit');
你还可以在全局级别使用GRANT USAGE语句(在*.*)来指定某个账户的密码而不影响账户当前的权限：
mysql> GRANT USAGE ON *.* TO 'jeffrey'@'%' IDENTIFIED BY 'biscuit';
一般情况下最好使用上述方法来指定密码，你还可以直接修改user表：
·         要想在创建新账户时建立密码，在Password列提供一个值：
·                shell> mysql -u root mysql
·                mysql> INSERT INTO user (Host,User,Password)
·                     -> VALUES('%','jeffrey',PASSWORD('biscuit'));
·                mysql> FLUSH PRIVILEGES;
·                 
·         要想更改已有账户的密码，使用UPDATE来设置Password列值：
·                shell> mysql -u root mysql
·                 mysql> UPDATE user SET Password = PASSWORD('bagel')
·                       -> WHERE Host = '%' AND User = 'francis';
·                mysql> FLUSH PRIVILEGES;
当你使用SET PASSWORD、INSERT或UPDATE指定账户的密码时，必须用PASSWORD()函数对它进行加密。(唯一的特例是如果密码为空，你不需要使用PASSWORD())。需要使用PASSWORD()是因为user表以加密方式保存密码，而不是明文。如果你忘记了，你可能会象这样设置密码：
shell> mysql -u root mysql
mysql> INSERT INTO user (Host,User,Password)
    -> VALUES('%','jeffrey','biscuit');
mysql> FLUSH PRIVILEGES;
 
结果是密码'biscuit'保存到user表后没有加密。当jeffrey使用该密码连接服务器时，值被加密并同保存在user表中的进行比较。但是，保存的值为字符串'biscuit'，因此比较将失败，服务器拒绝连接：
shell> mysql -u jeffrey -pbiscuit test
Access denied
如果你使用GRANT ... IDENTIFIED BY语句或mysqladmin password命令设置密码，它们均会加密密码。在这种情况下，不需要使用 PASSWORD()函数。
注释：PASSWORD()加密不同于Unix密码加密。参见5.8.1节，“MySQL用户名和密码”。
5.8.6. 使你的密码安全
在管理级别，你决不能将mysql.user表的访问权限授予任何非管理账户。
当你运行客户端程序连接MySQL服务器时，以一种暴露的可被其他用户发现的方式指定你的密码是不妥当的。当你运行客户端程序时，你可以使用下列方法指定你的密码，还有每个方法的风险评估：
·         使用一个在命令行上-pyour_pass或--password=your_pass的选项。例如：
·                shell> mysql -u francis -pfrank db_name
这很方便但是不安全，因为你的密码对系统状态程序(例如ps)变得可见，它可以被其他的用户调用来显示命令行。一般MySQL客户在他们的初始化顺序期间用零覆盖命令行参数，但是仍然有一个短暂间隔时间内参数值可见的。
·         使用一个-p或--password选项(没有指定密码)。在这种情况下，客户端程序请求来自终端的密码：
·                shell> mysql -u francis -p db_name
·                Enter password: ********
 “*”字符指示输入密码的地方。输入密码时密码看不见。
因为它对其他用户不可见，与在命令行上指定它相比，这样进入你的密码更安全。然而，这个输入一个密码的方法仅仅为你交互式运行程序是合适的。如果你想要从非交互式运行的一个脚本调用一个客户端，就没有从终端输入入密码的机会。在某些系统中，你甚至会发现脚本的第一行被（错误地）读并解释为你的密码！
·         在一个配置文件中存储你的密码。例如，在Unix中，你可在主目录的“.my.cnf”文件中的[client]节列出你的密码：
·                [client]
·                password=your_pass
如果你在“.my.cnf”里面存储密码，除了你本人其它人不能访问该文件。保证文件的访问模式是400或600。例如：
shell> chmod 600 .my.cnf
关于选项文件的详细讨论参见4.3.2节，“使用选项文件”。
·         你可在MYSQL_PWD环境变量中存储密码。但是这种指定MySQL密码的方法是极不安全的，不应该使用。ps的某些版本包括显示运行进程的环境的选项；如果你设定MYSQL_PWD，你的密码将被运行ps的所有人看见，甚至在没有这样一个版本的ps的系统上，没有其它方法观察到进程环境的假设是不明智的。参见附录F：环境变量。
总之，最安全的方法是让客户端程序提示输入密码或在适当保护的选项文件中指定密码。
5.8.7. 使用安全连接
5.8.7.1. SSL基本概念 
5.8.7.2. 需求(OpenSSL) 
5.8.7.3. 使用yaSSL 
5.8.7.4. 为MySQL设置SSL证书 
5.8.7.5. SSL GRANT 选项 
5.8.7.6. SSL命令行选项 
5.8.7.7. 用SSH以远程方式从Windows连接到MySQL
MySQL支持MySQL客户端和服务器之间的安全(加密的)连接所使用的安全套接字层(SSL)协议。本节讨论如何使用SSL连接。还描述了在Windows中设置SSH的方法。 
MySQL的标准配置倾向于尽可能快，因此默认情况不使用加密连接。使用该协议会使客户端/服务器协议慢得多。对数据进行加密非常耗CPU，需要计算机多做许多工作，会延迟MySQL的其它任务。对于需要通过加密连接提供安全的应用程序，可以保证额外的计算。
MySQL允许在连接前启用加密。你可以根据具体应用程序的需求选择普通未加密连接或安全加密SSL连接。
5.8.7.1. SSL基本概念
要想理解MySQL如何使用SSL，需要解释一些基本SSL和X509概念。熟悉的人们可以跳过该部分。 
默认情况下，MySQL在客户端和服务器之间使用未加密的连接。这说明可以访问网络的部分人可以看到你的通信，并看到发送和接收的数据。他们甚至可以更改在客户端和服务器之间传递的数据。要想提高安全性，当调用客户端程序时，你可以通过--compress选项压缩客户端/服务器之间的通信。但是，这样并不能阻挡住顽固的攻击者。
当你需要以安全方式在网络中传递信息时，未加密的连接是不可接受的。加密是使任何数据不可读的方法。事实上，今天的许多惯例需要加密算法提供更加安全的要素。它们应能抵抗各种已知的攻击，例如更改加密消息的顺序或两次重放数据。
SSL是一种使用不同的加密算法确保从公用网接收到的数据是可信的协议。它具有检测数据更改、丢失或重放的机制。SSL还包括使用 X509标准提供身份认证的算法。
使用X509，可以识别Internet上的某些人。通常用于电子商务应用程序中。按照基本概念，应有某种称之为“认证机构”(或CA)的机构，可以向请求者分发电子证书。证书依赖非对称加密算法，有两个加密密钥(公共密钥和私人密钥)。认证持有者可以向其它方出示证书来证明身份。证书包括持有者的公共密钥。只能使用对应的私人密钥对含该公共密钥的加密数据进行解密，私人密钥由证书持有者拥有。
如果你需要关于SSL、X509、或加密的详细信息，使用Internet搜索引擎来搜索你感兴趣的关键字。
5.8.7.2. 需求(OpenSSL)
要想在MySQL服务器和客户端程序之间使用SSL连接，系统必须能够支持OpenSSL。如果用支持内嵌式yaSSL的MySQL版本，不要读该节，但应阅读5.8.7.3节，“使用yaSSL”。
要想获得安全的MySQL连接，必须：
1.    安装OpenSSL库。我们已经测试了带OpenSSL 0.9.6的MySQL。如果你需要OpenSSL，请访问http://www.openssl.org。
2.    配置MySQL，用--with-vio和--with-openssl选项运行configure脚本。
3.    确保升级了授权表，使mysql.user表内包含SSL相关列。如果 授权表是从MySQL 4.0.0之前的版本升级，这很重要。升级过程见2.10.2节，“升级授权表”。
4.    要想检查是否运行的mysqld服务器支持OpenSSL，应检查have_openssl系统变量的值：
5.            mysql> SHOW VARIABLES LIKE 'have_openssl';
6.            +---------------+-------+
7.            | Variable_name | Value |
8.            +---------------+-------+
9.            | have_openssl  | YES   |
10.        +---------------+-------+
如果值为YES，服务器支持OpenSSL连接。
5.8.7.3. 使用yaSSL
使用MySQL的内嵌式yaSSL支持，可以很容易地使用安全连接。不需要安装OpenSSL和执行5.8.7.2节，“需求(OpenSSL)”中的步骤。并且，MySQL和yaSSL使用相同的许可模型。
当前，在以下平台上支持yaSSL：
·         Linux/x86-64 Red Hat Enterprise 3.0 
·         Linux RHAS21 Itanium-2，带gcc，静态链接
·         Linux Itanium-2，带gcc
·         Windows
当从源码构建MySQL时如果你想要启用yaSSL，应这样配置MySQL：
./configure --with-yassl=yes
要想启动MySQL服务器支持yaSSL，使用支持OpenSSL的相同的选项，并识别建立安全连接需要的证书：
shell> mysqld --ssl-ca=cacert.pem \
       --ssl-cert=server-cert.pem \
       --ssl-key=server-key.pem
·         --ssl-ca识别认证机构证书。
·         --ssl-cert识别服务器证书。
·         --ssl-key识别客户证书。
要想用yaSSL支持建立与MySQL服务器的安全连接，应这样启动客户端：
shell> mysql --ssl-ca=cacert.pem \
       --ssl-cert=server-cert.pem \
       --ssl-key=server-key.pem
换句话说，选项与服务器的相同，并且认证机构证书必须相同。
要想从应用程序建立安全连接，调用mysql_real_connect()之前，应使用mysql_ssl_set()API函数来设置相应认证选项。参见25.2.3.64节，“mysql_ssl_set()”。
5.8.7.4. 为MySQL设置SSL证书
下面是一个为MySQ设置SSL证书的例子：
DIR=`pwd`/openssl
PRIV=$DIR/private
 
mkdir $DIR $PRIV $DIR/newcerts
cp /usr/share/ssl/openssl.cnf $DIR
replace ./demoCA $DIR -- $DIR/openssl.cnf
 
# Create necessary files: $database, $serial and $new_certs_dir
# directory (optional)
 
touch $DIR/index.txt
echo "01" > $DIR/serial
 
#
# Generation of Certificate Authority(CA)
#
 
openssl req -new -x509 -keyout $PRIV/cakey.pem -out $DIR/cacert.pem \
    -config $DIR/openssl.cnf
 
# Sample output:
# Using configuration from /home/monty/openssl/openssl.cnf
# Generating a 1024 bit RSA private key
# ................++++++
# .........++++++
# writing new private key to '/home/monty/openssl/private/cakey.pem'
# Enter PEM pass phrase:
# Verifying password - Enter PEM pass phrase:
# -----
# You are about to be asked to enter information that will be
# incorporated into your certificate request.
# What you are about to enter is what is called a Distinguished Name
# or a DN.
# There are quite a few fields but you can leave some blank
# For some fields there will be a default value,
# If you enter '.', the field will be left blank.
# -----
# Country Name (2 letter code) [AU]:FI
# State or Province Name (full name) [Some-State]:.
# Locality Name (eg, city) []:
# Organization Name (eg, company) [Internet Widgits Pty Ltd]:MySQL AB
# Organizational Unit Name (eg, section) []:
# Common Name (eg, YOUR name) []:MySQL admin
# Email Address []:
 
#
# Create server request and key
#
openssl req -new -keyout $DIR/server-key.pem -out \
    $DIR/server-req.pem -days 3600 -config $DIR/openssl.cnf
 
# Sample output:
# Using configuration from /home/monty/openssl/openssl.cnf
# Generating a 1024 bit RSA private key
# ..++++++
# ..........++++++
# writing new private key to '/home/monty/openssl/server-key.pem'
# Enter PEM pass phrase:
# Verifying password - Enter PEM pass phrase:
# -----
# You are about to be asked to enter information that will be
# incorporated into your certificate request.
# What you are about to enter is what is called a Distinguished Name
# or a DN.
# There are quite a few fields but you can leave some blank
# For some fields there will be a default value,
# If you enter '.', the field will be left blank.
# -----
# Country Name (2 letter code) [AU]:FI
# State or Province Name (full name) [Some-State]:.
# Locality Name (eg, city) []:
# Organization Name (eg, company) [Internet Widgits Pty Ltd]:MySQL AB
# Organizational Unit Name (eg, section) []:
# Common Name (eg, YOUR name) []:MySQL server
# Email Address []:
#
# Please enter the following 'extra' attributes
# to be sent with your certificate request
# A challenge password []:
# An optional company name []:
 
#
# Remove the passphrase from the key (optional)
#
 
openssl rsa -in $DIR/server-key.pem -out $DIR/server-key.pem
 
#
# Sign server cert
#
openssl ca  -policy policy_anything -out $DIR/server-cert.pem \
    -config $DIR/openssl.cnf -infiles $DIR/server-req.pem
 
# Sample output:
# Using configuration from /home/monty/openssl/openssl.cnf
# Enter PEM pass phrase:
# Check that the request matches the signature
# Signature ok
# The Subjects Distinguished Name is as follows
# countryName           :PRINTABLE:'FI'
# organizationName      :PRINTABLE:'MySQL AB'
# commonName            :PRINTABLE:'MySQL admin'
# Certificate is to be certified until Sep 13 14:22:46 2003 GMT
# (365 days)
# Sign the certificate? [y/n]:y
#
#
# 1 out of 1 certificate requests certified, commit? [y/n]y
# Write out database with 1 new entries
# Data Base Updated
 
#
# Create client request and key
#
openssl req -new -keyout $DIR/client-key.pem -out \
    $DIR/client-req.pem -days 3600 -config $DIR/openssl.cnf
 
# Sample output:
# Using configuration from /home/monty/openssl/openssl.cnf
# Generating a 1024 bit RSA private key
# .....................................++++++
# .............................................++++++
# writing new private key to '/home/monty/openssl/client-key.pem'
# Enter PEM pass phrase:
# Verifying password - Enter PEM pass phrase:
# -----
# You are about to be asked to enter information that will be
# incorporated into your certificate request.
# What you are about to enter is what is called a Distinguished Name
# or a DN.
# There are quite a few fields but you can leave some blank
# For some fields there will be a default value,
# If you enter '.', the field will be left blank.
# -----
# Country Name (2 letter code) [AU]:FI
# State or Province Name (full name) [Some-State]:.
# Locality Name (eg, city) []:
# Organization Name (eg, company) [Internet Widgits Pty Ltd]:MySQL AB
# Organizational Unit Name (eg, section) []:
# Common Name (eg, YOUR name) []:MySQL user
# Email Address []:
#
# Please enter the following 'extra' attributes
# to be sent with your certificate request
# A challenge password []:
# An optional company name []:
 
#
# Remove a passphrase from the key (optional)
#
openssl rsa -in $DIR/client-key.pem -out $DIR/client-key.pem
 
#
# Sign client cert
#
 
openssl ca  -policy policy_anything -out $DIR/client-cert.pem \
    -config $DIR/openssl.cnf -infiles $DIR/client-req.pem
 
# Sample output:
# Using configuration from /home/monty/openssl/openssl.cnf
# Enter PEM pass phrase:
# Check that the request matches the signature
# Signature ok
# The Subjects Distinguished Name is as follows
# countryName           :PRINTABLE:'FI'
# organizationName      :PRINTABLE:'MySQL AB'
# commonName            :PRINTABLE:'MySQL user'
# Certificate is to be certified until Sep 13 16:45:17 2003 GMT
# (365 days)
# Sign the certificate? [y/n]:y
#
#
# 1 out of 1 certificate requests certified, commit? [y/n]y
# Write out database with 1 new entries
# Data Base Updated
 
#
# Create a my.cnf file that you can use to test the certificates
#
 
cnf=""
cnf="$cnf [client]"
cnf="$cnf ssl-ca=$DIR/cacert.pem"
cnf="$cnf ssl-cert=$DIR/client-cert.pem"
cnf="$cnf ssl-key=$DIR/client-key.pem"
cnf="$cnf [mysqld]"
cnf="$cnf ssl-ca=$DIR/cacert.pem"
cnf="$cnf ssl-cert=$DIR/server-cert.pem"
cnf="$cnf ssl-key=$DIR/server-key.pem"
echo $cnf | replace " " '
' > $DIR/my.cnf
 
要想测试SSL连接，按下面方法启动服务器，其中$DIR是示例my.cnf选项文件安装的路径名：
shell> MySQLd --defaults-file=$DIR/my.cnf &
然后使用相同的选项文件调用客户端程序：
shell> MySQL --defaults-file=$DIR/my.cnf
如果你有MySQL源码分发版，还可以修改前面的my.cnf文件来指向SSL目录中的示范证书和密钥文件来测试你的设置。
5.8.7.5. SSL GRANT 选项
MySQL可以检查X509证书的属性和基于用户名和密码的通用鉴定方法。要想为MySQL账户指定SSL相关选项，使用GRANT语句的REQUIRE子句。参见13.5.1.3节，“GRANT和REVOKE语法”。
有多种可能来限制一个账户的连接类型：
·         如果账户没有SSL或X509需求，如果用户名和密码合法，允许未加密的连接。但是，如果客户有正确的证书和密钥文件，在客户选项中可以使用加密连接。
·         REQUIRE SSL选项限制服务器只允许该账户的SSL加密连接。请注意如果有ACL记录允许非SSL连接，该选项会被忽略。
·                  mysql> GRANT ALL PRIVILEGES ON test.* TO 'root'@'localhost'
·                     -> IDENTIFIED BY 'goodsecret' REQUIRE SSL;
·         REQUIRE X509表示客户必须有合法证书但确切的证书、分发者和主体不重要。唯一的需求是应可以被某个CA认证机构验证它的签名。
·                mysql> GRANT ALL PRIVILEGES ON test.* TO 'root'@'localhost'
·                    -> IDENTIFIED BY 'goodsecret' REQUIRE X509;
·         REQUIRE ISSUER 'issuer'限制连接企图，即客户必须出示CA 'issuer'签发的合法X509证书。如果客户出示了一个合法证书，但是是由不同的分发者签发，服务器拒绝连接。使用X509证书表示要加密，因此不需要SSL选项。
·                mysql> GRANT ALL PRIVILEGES ON test.* TO 'root'@'localhost'
·                    -> IDENTIFIED BY 'goodsecret'
·                    -> REQUIRE ISSUER '/C=FI/ST=Some-State/L=Helsinki/
·                       O=MySQL Finland AB/CN=Tonu Samuel/Email=tonu@example.com';
请注意ISSUER值应做为单一字符串输入。
·         REQUIRE SUBJECT 'subject' 限制连接企图，即客户必须出示主题为'subject'的合法X509证书。如果客户出示了一个合法证书，但是有不同的主题，服务器拒绝连接。
·                mysql> GRANT ALL PRIVILEGES ON test.* TO 'root'@'localhost'
·                    -> IDENTIFIED BY 'goodsecret'
·                    -> REQUIRE SUBJECT '/C=EE/ST=Some-State/L=Tallinn/
·                       O=MySQL demo client certificate/
       CN=Tonu Samuel/Email=tonu@example.com';
请注意SUBJECT值应做为单一字符串输入。
·         REQUIRE CIPHER 'cipher'用来确保使用足够强的密码和密钥长度。如果使用旧的短加密密钥算法，SSL本身可能很弱。使用该选项，我们可以索取确切的加密方法来连接。
·                mysql> GRANT ALL PRIVILEGES ON test.* TO 'root'@'localhost'
·                    -> IDENTIFIED BY 'goodsecret'
    -> REQUIRE CIPHER 'EDH-RSA-DES-CBC3-SHA';
在REQUIRE子句中，可以结合使用SUBJECT、ISSUER和CIPHER选项：
mysql> GRANT ALL PRIVILEGES ON test.* TO 'root'@'localhost'
    -> IDENTIFIED BY 'goodsecret'
    -> REQUIRE SUBJECT '/C=EE/ST=Some-State/L=Tallinn/
       O=MySQL demo client certificate/
       CN=Tonu Samuel/Email=tonu@example.com'
    -> AND ISSUER '/C=FI/ST=Some-State/L=Helsinki/
       O=MySQL Finland AB/CN=Tonu Samuel/Email=tonu@example.com'
    -> AND CIPHER 'EDH-RSA-DES-CBC3-SHA';
请注意SUBJECT和ISSUER值应做为单一字符串输入。
在MySQL 5.1中,在REQUIRE选项之间可以选用AND关键字。
选项的顺序不重要，但任何选项不能用两次。
5.8.7.6. SSL命令行选项
下面列出了规定SSL、证书文件和密钥文件使用的选项。它们可以位于命令行中或选项文件中。 
·         --ssl
对于服务器，该选项规定该服务器允许SSL连接。对于客户端程序，它允许客户使用SSL连接服务器。单单该选项不足以使用SSL连接。还必须指定--ssl-ca、--ssl-cert和--ssl-key选项。
通常从反向使用该选项表示不应使用SSL。要想实现，将选项指定为--skip-ssl或--ssl=0。
请注意使用--ssl不需要SSL连接。例如，如果编译的服务器或客户不支持SSL，则使用普通的未加密的连接。
确保使用SSL连接的安全方式是使用含REQUIRE SSL子句的GRANT语句在服务器上创建一个账户。然后使用该账户来连接服务器，服务器和客户端均应启用SSL支持。
·         --ssl-ca=file_name
含可信SSL CA的清单的文件的路径。
·         --ssl-capath=directory_name
包含pem格式的可信SSL CA证书的目录的路径。
·         --ssl-cert=file_name
SSL证书文件名，用于建立安全连接。
·         --ssl-cipher=cipher_list
允许的用于SSL加密的密码的清单。cipher_list的格式与OpenSSL ciphers命令相同。
示例：--ssl-cipher=ALL:-AES:-EXP
·         --ssl-key=file_name
SSL密钥文件名，用于建立安全连接。
5.8.7.7. 用SSH以远程方式从Windows连接到MySQL
本节说明如何用SSH安全连接到远程MySQL服务器(David Carlson <dcarlson@mplcomm。com>)： 
1.    在Windows主机上安装SSH客户端。作为用户，我所发现的最好的非免费客户端来自http://www.vandyke.com/的SecureCRT。另一个选则是http://www.f-secure.com/的f-secure。你还可以从http://directory.google.com/Top/Computers/Security/Products_and_Tools/Cryptography/SSH/Clients/Windows/ 的Google找到一些免费客户端。
2.    启动Windows SSH客户端。设置Host_Name = yourmysqlserver_URL_or_IP。设置userid=your_userid以便登录服务器。此userid值可以与你的MySQL账户的用户名不相同。
3.    设置端口映射。可以进行远程映射(设置local_port: 3306, remote_host: yourmysqlservername_or_ip, remote_port: 3306)或本地映射(设置port: 3306, host: localhost, remote port: 3306)。
4.    进行保存，否则下次需要重设。
5.    刚创建的SSH会话登录服务器。
6.    在Windows机器上启动相应ODBC应用程序(例如Access)。
7.    在Windows中创建一个新的文件按照常用方法通过ODBC驱动程序链接MySQL，不同的是要为MySQL服务器输入localhost，而不是yourmysqlservername。
你应有使用SSH加密的ODBC连接到MySQL。
5.9. 备份与恢复
5.9.1. 数据库备份 
5.9.2. 示例用备份与恢复策略 
5.9.3. 自动恢复 
5.9.4. 表维护和崩溃恢复 
5.9.5. myisamchk：MyISAM表维护实用工具 
5.9.6. 建立表维护计划 
5.9.7. 获取关于表的信息
本节讨论如何进行数据库备份(完全备份和增量备份)，以及如何执行表的维护。本节描述的SQL语句语法参见第5章：数据库管理。此处提供的大多数信息主要适合MyISAM表。InnoDB备份程序参见15.2.8节，“InnoDB数据库的备份和恢复”。
5.9.1. 数据库备份
因为MySQL表保存为文件方式，很容易备份。要想保持备份的一致性，对相关表执行LOCK TABLES操作，然后对表执行FLUSH TABLES。参见13.4.5节，“LOCK TABLES和UNLOCK TABLES语法”和13.5.5.2节，“FLUSH语法”。你只需要读锁定；这样当你复制数据库目录中的文件时，允许其它客户继续查询表。需要FLUSH TABLES语句来确保开始备份前将所有激活的索引页写入硬盘。
如果你想要进行SQL级别的表备份，你可以使用SELECT INTO ...OUTFILE或BACKUP TABLE。对于SELECT INTO ...OUTFILE， 输出的文件不能先存在。对于BACKUP TABLE也如此，因为覆盖完整的文件会有安全风险。参见13.2.7节，“SELECT语法”和13.5.2.2节，“BACKUP TABLE语法”。
备份数据库的另一个技术是使用mysqldump程序或mysqlhotcopy脚本。参见8.8节，“mysqldump：数据库备份程序”和8.9节，“mysqlhotcopy：数据库备份程序”。
1.    完全备份数据库：
2.            shell> mysqldump --tab=/path/to/some/dir --opt db_name
或：
shell> mysqlhotcopy db_name /path/to/some/dir
只要服务器不再进行更新，还可以只复制所有表文件(*.frm、*.MYD和*.MYI文件)。mysqlhotcopy脚本使用该方法。(但请注意如果数据库包含InnoDB表，这些方法不工作。InnoDB不将表的内容保存到数据库目录中，mysqlhotcopy只适合MyISAM表）。 
3.    如果mysqld在运行则停止，然后用--log-bin[=file_name]选项来启动。参见5.11.3节，“二进制日志”。二进制日志文件中提供了  执行mysqldump之后对数据库的更改进行复制所需要的信息。
对于InnoDB表，可以进行在线备份，不需要对表进行锁定；参见8.8节，“mysqldump：数据库备份程序”。
MySQL支持增量备份:需要用--log-bin选项来启动服务器以便启用二进制日志；参见5.11.3节，“二进制日志”。当想要进行增量备份时(包含上一次完全备份或增量备份之后的所有更改)，应使用FLUSH LOGS回滚二进制日志。然后，你需要将从最后的完全或增量备份的某个时刻到最后某个点的所有二进制日志复制到备份位置。这些二进制日志为增量备份；恢复时，按照下面的解释应用。下次进行完全备份时，还应使用FLUSH LOGS或mysqlhotcopy --flushlogs回滚二进制日志。参见8.8节，“mysqldump：数据库备份程序”和8.9节，“mysqlhotcopy：数据库备份程序”。
如果MySQL服务器为从复制服务器，则无论选择什么备份方法，当备份从机数据时，还应备份master.info和relay-log.info文件。恢复了从机数据后，需要这些文件来继续复制。如果从机执行复制LOAD DATA INFILE命令，你应还备份用--slave-load-tmpdir选项指定的目录中的SQL_LOAD-*文件。(如果未指定，该位置默认为tmpdir变量值）。从机需要这些文件来继续复制中断的LOAD DATA INFILE操作。
如果必须恢复MyISAM表，先使用REPAIR TABLE或myisamchk -r来恢复。99.9%的情况下该方法可以工作。如果myisamchk失败，试试下面的方法。请注意只有用--log-bin选项启动了MySQL从而启用二进制日志它才工作；参见5.11.3节，“二进制日志”。
1.    恢复原mysqldump备份，或二进制备份。
2.    执行下面的命令重新更新二进制日志：
3.            shell> mysqlbinlog hostname-bin.[0-9]* | mysql
在某些情况下，你可能只想要从某个位置重新运行某些二进制日志。(通常你想要从恢复备份的日期重新运行所有二进制日志，查询不正确时例外)。关于mysqlbinlog工具和如何使用它的详细信息参见8.6节，“mysqlbinlog：用于处理二进制日志文件的实用工具”。
还可以对具体文件进行选择备份：
·         要想复制表，使用SELECT * INTO OUTFILE 'file_name' FROM tbl_name。
·         要想重载表，使用LOAD DATA INFILE 'file_name' REPLACE ...并恢复。要避免复制记录，表必须有PRIMARY KEY或一个UNIQUE索引。当新记录复制唯一键值的旧记录时，REPLACE关键字可以将旧记录替换为新记录。
如果备份时遇到服务器性能问题，可以有帮助的一个策略是在从服务器而不是主服务器上建立复制并执行备份。参见6.1节，“复制介绍”。
如果使用Veritas文件系统，可以这样备份：
1.    从客户端程序执行FLUSH TABLES WITH READ LOCK。
2.    从另一个shell执行mount vxfs snapshot。
3.    从第一个客户端执行UNLOCK TABLES。
4.    从快照复制文件。
5.    卸载快照。
5.9.2. 示例用备份与恢复策略
5.9.2.1. 备份策略 
5.9.2.2. 为恢复进行备份 
5.9.2.3. 备份策略摘要
本节讨论进行备份的程序，在出现崩溃后，可以恢复数据： 
·         操作系统崩溃 
·         电源故障 
·         文件系统崩溃 
·         硬件问题(硬盘、母板等等) 
该命令不包括mysqldump和mysql程序的--user和—password等选项。应包括必要的选项让MySQL服务器允许你连接它。
我们假定数据保存在MySQL的InnoDB存储引擎中，支持事务和自动崩溃恢复。我们假定崩溃时MySQL服务器带负载。如果不带负载，则不需要恢复。
出现操作系统崩溃或电源故障时，我们可以假定重启后硬盘上的MySQLś数据仍可用。由于崩溃，InnoDB数据文件中的数据可能不再保持一致性，但InnoDB读取它的日志并会查到挂起的提交的和未提交的事务清单，它们没有清空到数据文件中。InnoDB自动卷回未提交的事务，并清空到它的数据文件中。通过MySQL错误日志将该恢复过程相关信息传达给用户。下面的例子为日志摘录：
InnoDB: Database was not shut down normally.
InnoDB: Starting recovery from log files...
InnoDB: Starting log scan based on checkpoint at
InnoDB: log sequence number 0 13674004
InnoDB: Doing recovery: scanned up to log sequence number 0 13739520
InnoDB: Doing recovery: scanned up to log sequence number 0 13805056
InnoDB: Doing recovery: scanned up to log sequence number 0 13870592
InnoDB: Doing recovery: scanned up to log sequence number 0 13936128
...
InnoDB: Doing recovery: scanned up to log sequence number 0 20555264
InnoDB: Doing recovery: scanned up to log sequence number 0 20620800
InnoDB: Doing recovery: scanned up to log sequence number 0 20664692
InnoDB: 1 uncommitted transaction(s) which must be rolled back
InnoDB: Starting rollback of uncommitted transactions
InnoDB: Rolling back trx no 16745
InnoDB: Rolling back of trx no 16745 completed
InnoDB: Rollback of uncommitted transactions completed
InnoDB: Starting an apply batch of log records to the database...
InnoDB: Apply batch completed
InnoDB: Started
mysqld: ready for connections
如果文件系统崩溃或出现硬件问题，我们可以假定重启后硬盘上的MySQLś数据不可用。这说明MySQL未能成功启动，因为一些硬盘数据块不再可读。在这种情况下，需要重新格式化硬盘，安装一个新的，或纠正问题。然后需要从备份中恢复MySQL数据，这说明我们必须先做好备份。要想确保，应及时返回并设计备份策略。
5.9.2.1. 备份策略
我们都知道必须按计划定期进行备份。可以用几个工具完全备份(在某个时间点的数据快照)MySQL。例如，InnoDB Hot Backup为InnoDB数据文件提供在线非数据块物理备份，mysqldump提供在线逻辑备份。这里使用mysqldump。
假定我们在星期日下午1点进行了备份，此时负荷较低。下面的命令可以完全备份所有数据库中的所有InnoDB表：
shell> mysqldump --single-transaction --all-databases > backup_sunday_1_PM.sql
这是在线非块备份，不会干扰对表的读写。我们以前假定我们的表为InnoDB表，因此--single-transaction使用一致性地读，并且保证mysqldump所看见的数据不会更改。(其它客户端对InnoDB表进行的更改不会被mysqldump进程看见）。如果我们还有其它类型的表，我们必须假定在备份过程中它们不会更改。例如，对于mysql数据库中的MyISAM表，我们必须假定在备份过程中没有对MySQL账户进行管理更改。
mysqldump命令产生的.sql文件包含一系列SQL INSERT语句，可以用来重载转储的表。
需要进行完全备份，但有时不方便。会产生大的备份文件并需要花时间来生成。从某个角度，完全备份并不理想，因为每个成功的完全备份包括所有数据，甚至自从上一次完全备份以来没有更改的部分。完成了初使完全备份后，进行增量备份会更有效。这样备份文件要小得多，备份时间也较短。不利之处是，恢复时不能只重载完全备份来恢复数据。还必须要用增量备份来恢复增量更改。
要想进行增量备份，我们需要保存增量更改。应使用--log-bin选项启动MySQL服务器，以便更新数据时将这些更改保存到文件中。该选项启用二进制日志，因此服务器写将每个更新数据的SQL语句写入MySQL二进制日志。让我们看看用--log-bin选项启动的已经运行多日的MySQL服务器的数据目录。我们找到以下MySQL二进制日志文件：
-rw-rw---- 1 guilhem  guilhem   1277324 Nov 10 23:59 gbichot2-bin.000001
-rw-rw---- 1 guilhem  guilhem         4 Nov 10 23:59 gbichot2-bin.000002
-rw-rw---- 1 guilhem  guilhem        79 Nov 11 11:06 gbichot2-bin.000003
-rw-rw---- 1 guilhem  guilhem       508 Nov 11 11:08 gbichot2-bin.000004
-rw-rw---- 1 guilhem  guilhem 220047446 Nov 12 16:47 gbichot2-bin.000005
-rw-rw---- 1 guilhem  guilhem    998412 Nov 14 10:08 gbichot2-bin.000006
-rw-rw---- 1 guilhem  guilhem       361 Nov 14 10:07 gbichot2-bin.index
每次重启，MySQL服务器用序列中的下一个编号创建一个新的二进制日志文件。当服务器运行时，你还可以通过执行FLUSH LOGS SQL语句或mysqladmin flush-logs命令，告诉服务器关闭当前的二进制日志文件并创建一个新文件。mysqldump也有一个选项来清空日志。数据目录中的.index文件包含该目录下所有MySQL二进制日志的清单。该文件用于复制。
恢复时MySQL二进制日志很重要，因为它们是增量备份。如果进行完全备份时确保清空了日志，则后面创建的二进制日志文件包含了备份后的所有数据更改。让我们稍稍修改前面的mysqldump命令，让它在完全备份时能够清空 MySQL二进制日志，以便转储文件包含包含新的当前的二进制日志：
shell> mysqldump --single-transaction --flush-logs --master-data=2
           --all-databases > backup_sunday_1_PM.sql
执行该命令后，数据目录则包含新的二进制日志文件，gbichot2-bin.000007。结果.sql文件包含下列行：
-- Position to start replication or point-in-time 恢复时y from
-- CHANGE MASTER TO MASTER_LOG_FILE='gbichot2-bin.000007',MASTER_LOG_POS=4;
因为mysqldump命令可以执行完全备份，这些行表示两件事情：
·         .sql文件包含所有写入gbichot2-bin.000007二进制日志文件或最新的文件之前的更改。
·         备份后所记录的所有数据更改不出现在.sql中，但出现在gbichot2-bin.000007二进制日志文件或最新的文件中。
在星期一下午1点，我们可以清空日志开始新的二进制日志文件来创建增量备份。例如，执行mysqladmin flush-logs命令创建gbichot2-bin.000008。星期日下午1点的完全备份和星期一下午1点之间的所有更改为文件gbichot2-bin.000007。该增量备份很重要，因此最好将它复制到安全的地方。(例如，备份到磁带或DVD上，或复制到另一台机器上）。在星期二下午1点，执行另一个mysqladmin flush-logs命令。星期一下午1点和星期二下午1点之间的所有所有更改为文件gbichot2-bin.000008(也应复制到某个安全的地方)。
MySQL二进制日志占据硬盘空间。要想释放空间，应随时清空。操作方法是删掉不再使用的二进制日志，例如进行完全备份时：
shell> mysqldump --single-transaction --flush-logs --master-data=2
           --all-databases --delete-master-logs > backup_sunday_1_PM.sql
注释：如果你的服务器为复制主服务器，用mysqldump --delete-master-logs删掉MySQL二进制日志很危险，因为从服务器可能还没有完全处理该二进制日志的内容。
PURGE MASTER LOGS语句的描述中解释了为什么在删掉MySQL二进制日志之前应进行确认。参见13.6.1.1节，“PURGE MASTER LOGS语法”。
5.9.2.2. 为恢复进行备份
现在假设在星期三上午8点出现了灾难性崩溃，需要使用备份文件进行恢复。恢复时，我们首先恢复最后的完全备份(从星期日下午1点开始)。完全备份文件是一系列SQL语句，因此恢复它很容易：
shell> mysql < backup_sunday_1_PM.sql
在该点，数据恢复到星期日下午1点的状态。要想恢复从那时起的更改，我们必须使用增量备份，也就是，gbichot2-bin.000007和gbichot2-bin.000008二进制日志文件。根据需要从备份处取过这些文件，然后按下述方式处理：
shell> mysqlbinlog gbichot2-bin.000007 gbichot2-bin.000008 | mysql
我们现在将数据恢复到星期二下午1点的状态，但是从该时刻到崩溃之间的数据仍然有丢失。要想恢复，我们需要MySQL服务器将MySQL二进制日志保存到安全的位置(RAID disks, SAN, ...)，应为与数据文件的保存位置不同的地方，保证这些日志不在毁坏的硬盘上。(也就是，我们可以用--log-bin选项启动服务器，指定一个其它物理设备上的与数据目录不同的位置。这样，即使包含该目录的设备丢失，日志也不会丢失）。如果我们执行了这些操作，我们手头上会有gbichot2-bin.000009文件，我们可以用它来恢复大部分最新的数据更改，而不会丢失到崩溃时的数据。
5.9.2.3. 备份策略摘要
出现操作系统崩溃或电源故障时，InnoDB自己可以完成所有数据恢复工作。但为了确保你可以睡好觉，应遵从下面的指导：
·         一定用--log-bin或甚至--log-bin=log_name选项运行MySQL服务器，其中日志文件名位于某个安全媒介上，不同于数据目录所在驱动器。如果你有这样的安全媒介，最好进行硬盘负载均衡(这样能够提高性能)。
·         定期进行完全备份，使用mysqldump命令进行在线非块备份。
·         用FLUSH LOGS或mysqladmin flush-logs清空日志进行定期增量备份。
5.9.3. 自动恢复
5.9.3.1. 指定恢复时间 
5.9.3.2. 指定恢复位置
如果MySQL服务器启用了二进制日志，你可以使用mysqlbinlog工具来恢复从指定的时间点开始 (例如，从你最后一次备份)直到现在或另一个指定的时间点的数据。关于启用二进制日志的信息，参见5.11.3节，“二进制日志”。对于mysqlbinlog的详细信息，参见8.6节，“mysqlbinlog：用于处理二进制日志文件的实用工具”。
要想从二进制日志恢复数据，你需要知道当前二进制日志文件的路径和文件名。一般可以从选项文件(即my.cnf or my.ini，取决于你的系统)中找到路径。如果未包含在选项文件中，当服务器启动时，可以在命令行中以选项的形式给出。启用二进制日志的选项为--log-bin。要想确定当前的二进制日志文件的文件名，输入下面的MySQL语句：
SHOW BINLOG EVENTS \G
你还可以从命令行输入下面的内容：
mysql --user=root -pmy_pwd -e 'SHOW BINLOG EVENTS \G'
将密码my_pwd替换为服务器的root密码。
5.9.3.1. 指定恢复时间
对于MySQL 4.1.4，可以在mysqlbinlog语句中通过--start-date和--stop-date选项指定DATETIME格式的起止时间。举例说明，假设在今天上午10:00(今天是2005年4月20日)，执行SQL语句来删除一个大表。要想恢复表和数据，你可以恢复前晚上的备份，并输入：
mysqlbinlog --stop-date="2005-04-20 9:59:59" /var/log/mysql/bin.123456 \
     | mysql -u root -pmypwd
该命令将恢复截止到在--stop-date选项中以DATETIME格式给出的日期和时间的所有数据。如果你没有检测到几个小时后输入的错误的SQL语句，可能你想要恢复后面发生的活动。根据这些，你可以用起使日期和时间再次运行mysqlbinlog：
mysqlbinlog --start-date="2005-04-20 10:01:00" /var/log/mysql/bin.123456 \
     | mysql -u root -pmypwd \
在该行中，从上午10:01登录的SQL语句将运行。组合执行前夜的转储文件和mysqlbinlog的两行可以将所有数据恢复到上午10:00前一秒钟。你应检查日志以确保时间确切。下一节介绍如何实现。
5.9.3.2. 指定恢复位置
也可以不指定日期和时间，而使用mysqlbinlog的选项--start-position和--stop-position来指定日志位置。它们的作用与起止日选项相同，不同的是给出了从日志起的位置号。使用日志位置是更准确的恢复方法，特别是当由于破坏性SQL语句同时发生许多事务的时候。要想确定位置号，可以运行mysqlbinlog寻找执行了不期望的事务的时间范围，但应将结果重新指向文本文件以便进行检查。操作方法为：
mysqlbinlog --start-date="2005-04-20 9:55:00" --stop-date="2005-04-20 10:05:00" \
      /var/log/mysql/bin.123456 > /tmp/mysql_restore.sql
该命令将在/tmp目录创建小的文本文件，将显示执行了错误的SQL语句时的SQL语句。你可以用文本编辑器打开该文件，寻找你不要想重复的语句。如果二进制日志中的位置号用于停止和继续恢复操作，应进行注释。用log_pos加一个数字来标记位置。使用位置号恢复了以前的备份文件后，你应从命令行输入下面内容：
mysqlbinlog --stop-position="368312" /var/log/mysql/bin.123456 \
    | mysql -u root -pmypwd 
 
mysqlbinlog --start-position="368315" /var/log/mysql/bin.123456 \
    | mysql -u root -pmypwd \ 
上面的第1行将恢复到停止位置为止的所有事务。下一行将恢复从给定的起始位置直到二进制日志结束的所有事务。因为mysqlbinlog的输出包括每个SQL语句记录之前的SET TIMESTAMP语句，恢复的数据和相关MySQL日志将反应事务执行的原时间。
5.9.4. 表维护和崩溃恢复
后面几节讨论如何使用myisamchk来检查或维护MyISAM表(对应.MYI和.MYD文件的表)。
你可以使用myisamchk实用程序来获得有关你的数据库表的信息或检查、修复、优化他们。下列小节描述如何调用myisamchk（包括它的选项的描述），如何建立表的维护计划，以及如何使用myisamchk执行各种功能。
尽管用myisamchk修复表很安全，在修复(或任何可以大量更改表的维护操作)之前先进行备份也是很好的习惯 
影响索引的myisamchk操作会使ULLTEXT索引用full-text参数重建，不再与MySQL服务器使用的值兼容。要想避免，请阅读5.9.5.1节，“用于myisamchk的一般选项”的说明。
在许多情况下，你会发现使用SQL语句实现MyISAM表的维护比执行myisamchk操作要容易地多：
·         要想检查或维护MyISAM表，使用CHECK TABLE或REPAIR TABLE。
·         要想优化MyISAM表，使用OPTIMIZE TABLE。
·         要想分析MyISAM表，使用ANALYZE TABLE。
可以直接这些语句，或使用mysqlcheck客户端程序，可以提供命令行接口。
这些语句比myisamchk有利的地方是服务器可以做任何工作。使用myisamchk，你必须确保服务器在同一时间不使用表。否则，myisamchk和服务器之间会出现不期望的相互干涉。
5.9.5. myisamchk：MyISAM表维护实用工具
5.9.5.1. 用于myisamchk的一般选项 
5.9.5.2. 用于myisamchk的检查选项 
5.9.5.3. myisamchk的修复选项 
5.9.5.4. 用于myisamchk的其它选项 
5.9.5.5. myisamchk内存使用 
5.9.5.6. 将myisamchk用于崩溃恢复 
5.9.5.7. 如何检查MyISAM表的错误 
5.9.5.8. 如何修复表 
5.9.5.9. 表优化
可以使用myisamchk实用程序来获得有关数据库表的信息或检查、修复、优化他们。myisamchk适用MyISAM表(对应.MYI和.MYD文件的表)。
调用myisamchk的方法：
shell> myisamchk [options] tbl_name ...
options指定你想让myisamchk做什么。在后面描述它们。还可以通过调用myisamchk --help得到选项列表。
tbl_name是你想要检查或修复的数据库表。如果你不在数据库目录的某处运行myisamchk，你必须指定数据库目录的路径，因为myisamchk不知道你的数据库位于哪儿。实际上，myisamchk不在乎你正在操作的文件是否位于一个数据库目录；你可以将对应于数据库表的文件拷贝到别处并且在那里执行恢复操作。
如果你愿意，可以用myisamchk命令行命名几个表。还可以通过命名索引文件(用“ .MYI”后缀)来指定一个表。它允许你通过使用模式“*.MYI”指定在一个目录所有的表。例如，如果你在数据库目录，可以这样在目录下检查所有的MyISAM表：
shell> myisamchk *.MYI
如果你不在数据库目录下，可通过指定到目录的路径检查所有在那里的表：
shell> myisamchk /path/to/database_dir/*.MYI
你甚至可以通过为MySQL数据目录的路径指定一个通配符来检查所有的数据库中的所有表：
shell> myisamchk /path/to/datadir/*/*.MYI
推荐的快速检查所有MyISAM表的方式是：
shell> myisamchk --silent --fast /path/to/datadir/*/*.MYI
如果你想要检查所有MyISAM表并修复任何破坏的表，可以使用下面的命令：
shell> myisamchk --silent --force --fast --update-state \
          -O key_buffer=64M -O sort_buffer=64M \
          -O read_buffer=1M -O write_buffer=1M \
          /path/to/datadir/*/*.MYI
该命令假定你有大于64MB的自由内存。关于用myisamchk分配内存的详细信息，参见5.9.5.5节，“myisamchk内存使用”。
当你运行myisamchk时，必须确保其它程序不使用表。否则，当你运行myisamchk时，会显示下面的错误消息：
warning: clients are using or haven't closed the table properly
这说明你正尝试检查正被另一个还没有关闭文件或已经终止而没有正确地关闭文件的程序(例如mysqld服务器)更新的表。
如果mysqld正在运行，你必须通过FLUSH TABLES强制清空仍然在内存中的任何表修改。当你运行myisamchk时，必须确保其它程序不使用表。避免该问题的最容易的方法是使用CHECK TABLE而不用myisamchk来检查表。
5.9.5.1. 用于myisamchk的一般选项
本节描述的选项可以用于用myisamchk执行的任何类型的表维护操作。本节后面的章节中描述的选项只适合具体操作，例如检查或修复表。
·         --help，-? 
显示帮助消息并退出。
·         --debug=debug_options, -# debug_options
输出调试记录文件。debug_options字符串经常是'd:t:o,filename'。
·         --silent，-s
沉默模式。仅当发生错误时写输出。你能使用-s两次(-ss)使myisamchk沉默。
·         --verbose，-v
冗长模式。打印更多的信息。这能与-d和-e一起使用。为了更冗长，使用-v多次(-vv, -vvv)！
·         --version, -V
显示版本信息并退出。
·         --wait, -w
如果表被锁定，不是提示错误终止，而是在继续前等待到表被解锁。请注意如果用--skip-external-locking选项运行mysqld，只能用另一个myisamchk命令锁定表。
还可以通过--var_name=value选项设置下面的变量：
变量
默认值
decode_bits
9
ft_max_word_len
取决于版本
ft_min_word_len
4
ft_stopword_file
内建列表
key_buffer_size
523264
myisam_block_size
1024
read_buffer_size
262136
sort_buffer_size
2097144
sort_key_blocks
16
stats_method
nulls_unequal
write_buffer_size
262136
可以用myisamchk --help检查myisamchk变量及其 默认值：
当用排序键值修复键值时使用sort_buffer_size，使用--recover时这是很普通的情况。
当用--extend-check检查表或通过一行一行地将键值插入表中(如同普通插入)来修改键值时使用Key_buffer_size。在以下情况通过键值缓冲区进行修复：
·         使用--safe-recover。
·         当直接创建键值文件时，需要对键值排序的临时文件有两倍大。通常是当CHAR、VARCHAR、或TEXT列的键值较大的情况，因为排序操作在处理过程中需要保存全部键值。如果你有大量临时空间，可以通过排序强制使用myisamchk来修复，可以使用--sort-recover选项。
通过键值缓冲区的修复占用的硬盘空间比使用排序么少，但是要慢。
如果想要快速修复，将key_buffer_size和sort_buffer_size变量设置到大约可用内存的25%。可以将两个变量设置为较大的值，因为一个时间只使用一个变量。
myisam_block_size是用于索引块的内存大小。
stats_method影响当给定--analyze选项时，如何为索引统计搜集处理NULL值。它如同myisam_stats_method系统变量。详细信息参见5.3.3节，“服务器系统变量”和7.4.7节，“MyISAM索引统计集合”的myisam_stats_method的描述。
ft_min_word_len和ft_max_word_len表示FULLTEXT索引的最小和最大字长。ft_stopword_file为停止字文件的文件名。需要在以下环境中对其进行设置。
如果你使用myisamchk来修改表索引(例如修复或分析)，使用最小和最大字长和停止字文件的 默认全文参数值（除非你另外指定）重建FULLTEXT索引。这样会导致查询失败。
出现这些问题是因为只有服务器知道这些参数。它们没有保存在MyISAM索引文件中。如果你修改了服务器中的最小或最大字长或停止字文件，要避免该问题，为用于mysqld的myisamchk指定相同的ft_min_word_len，ft_max_word_len和ft_stopword_file值。例如，如果你将最小字长设置为3,可以这样使用myisamchk来修复表：
shell> myisamchk --recover --ft_min_word_len=3 tbl_name.MYI
要想确保myisamchk和服务器使用相同的全文参数值，可以将它们放入选项文件的[mysqld]和[myisamchk]小节：
[mysqld]
ft_min_word_len=3
 
[myisamchk]
ft_min_word_len=3
除了myisamchk，还可以使用REPAIR TABLE、ANALYZE TABLE、OPTIMIZE TABLE或ALTER TABLE。这些语句由服务器执行，知道要使用的正确的全文参数值。
5.9.5.2. 用于myisamchk的检查选项
myisamchk支持下面的表检查操作选项：
·         --check, -c
检查表的错误。如果你不明确指定操作类型选项，这就是默认操作。
·         --check-only-changed, -C
只检查上次检查后有变更的表。
·         --extend-check, -e
非常仔细地检查表。如果表有许多索引将会相当慢。该选项只能用于极端情况。一般情况下，可以使用myisamchk或myisamchk --medium-check来确定表内是否有错误。
如果你使用了--extend-check并且有充分的内存，将key_buffer_size变量设置为较大的值可以使修复操作运行得更快。
·         --fast，-F
只检查没有正确关闭的表。
·         --force, -f
如果myisamchk发现表内有任何错误，则自动进行修复。维护类型与--repair或-r选项指定的相同。
·         --information, -i
打印所检查表的统计信息。
·         --medium-check, -m
比--extend-check更快速地进行检查。只能发现99.99%的错误，在大多数情况下就足够了。
·         --read-only, -T
不要将表标记为已经检查。如果你使用myisamchk来检查正被其它应用程序使用而没有锁定的表很有用，例如当用--skip-external-locking选项运行时运行mysqld。
·         --update-state, -U
将信息保存在.MYI文件中，来表示表检查的时间以及是否表崩溃了。该选项用来充分利用--check-only-changed选项，但如果mysqld服务器正使用表并且正用--skip-external-locking选项运行时不应使用该选项。
5.9.5.3. myisamchk的修复选项
myisamchk支持下面的表修复操作的选项：
·         --backup, -B
将.MYD文件备份为file_name-time.BAK
·         --character-sets-dir=path
字符集安装目录。参见5.10.1节，“数据和排序用字符集”。
·         --correct-checksum
纠正表的校验和信息。
·         --data-file-length=len, -D len
数据文件的最大长度(当重建数据文件且为“满”时)。
·         --extend-check，-e
进行修复，试图从数据文件恢复每一行。一般情况会发现大量的垃圾行。不要使用该选项,除非你不顾后果。
·         --force, -f
覆盖旧的中间文件(文件名类似tbl_name.TMD)，而不是中断。
·         --keys-used=val, -k val
对于myisamchk，该选项值为位值，说明要更新的索引。选项值的每一个二进制位对应表的一个索引，其中第一个索引对应位0。选项值0禁用对所有索引的更新，可以保证快速插入。通过myisamchk -r可以重新激活被禁用的索引。
·         --no-symlinks, -l
不跟随符号连接。通常myisamchk修复一个符号连接所指的表。在MySQL 4.0中该选项不存在，因为从4.0开始的版本在修复过程中不移除符号链接。
·         --parallel-recover, -p
与-r和-n的用法相同，但使用不同的线程并行创建所有键。这是alpha代码。自己承担风险！
·         --quick，-q
不修改数据文件，快速进行修复。出现复制键时，你可以两次指定该项以强制myisamchk修改原数据文件。
·         --recover, -r
可以修复几乎所有一切问题，除非唯一的键不唯一时(对于MyISAM表，这是非常不可能的情况)。如果你想要恢复表，这是首先要尝试的选项。如果myisamchk报告表不能用-r恢复，则只能尝试-o。在不太可能的情况下-r失败，数据文件保持完好）。 
如果你有大量内存，你应增加sort_buffer_size的值。
·         --safe-recover, -o
使用一个老的恢复方法读取，按顺序读取所有行，并根据找到的行更新所有索引树。这比-r慢些，但是能处理-r不能处理的情况。该恢复方法使用的硬盘空间比-r少。一般情况，你应首先用-r维修，如果-r失败则用-o。
如果你有大量内存，你应增加sort_buffer_size的值。
·         (OBSOLETE) --set-character-set=name
在MySQL 5.1中不使用。参见--set-collation。
·         --set-collation=name
更改用来排序表索引的校对规则。校对规则名的第一部分包含字符集名。
·         --sort-recover, -n
强制myisamchk通过排序来解析键值，即使临时文件将可能很大。
·         --tmpdir=path, -t path
用于保存临时文件的目录的路径。如果未设置，myisamchk使用TMPDIR环境变量的值。tmpdir可以设置为一系列目录路径，用于成功地以round-robin模式创建临时文件。在Unix中，目录名之间的间隔字符为冒号(‘:’)，在Windows、NetWare和OS/2中为分号 (‘；’)。
·         --unpack，-u
将用myisampack打包的表解包。
5.9.5.4. 用于myisamchk的其它选项
myisamchk支持以下表检查和修复之外的其它操作的选项： 
·         --analyze，-a
分析键值的分布。这通过让联结优化器更好地选择表应该以什么次序联结和应该使用哪个键来改进联结性能。要想获取分布相关信息，使用myisamchk --description --verbose tbl_name命令或SHOW KEYS FROM tbl_name语句。
·         --description, -d
打印出关于表的描述性信息。
·         --set-auto-increment[=value], -A[value]
强制从给定值开始的新记录使用AUTO_INCREMENT编号(或如果已经有AUTO_INCREMENT值大小的记录，应使用更高值)。如果未指定value，新记录的AUTO_INCREMENT编号应使用当前表的最大值加上1。
·         --sort-index, -S
以从高到低的顺序排序索引树块。这将优化搜寻并且将使按键值的表扫描更快。
·         --sort-records=N, -R N
根据一个具体索引排序记录。这使你的数据更局部化并且可以加快在该键上的SELECT和ORDER BY的范围搜索。（第一次做排序可能很慢！）为了找出一张表的索引编号，使用SHOW INDEX，它以myisamchk看见他们的相同顺序显示一张表的索引。索引从1开始编号。
如果键没有打包(PACK_KEYS=0)，它们的长度相同，因此当myisamchk 排序并移动记录时，只覆盖索引中的记录偏移量。如果键已经打包(PACK_KEYS=1)，myisamchk必须先解开打包的键块，然后重新创建索引并再次将键块打包。(在这种情况下，重新创建索引比更新每个索引的偏移量要快）。 
5.9.5.5. myisamchk内存使用
当你运行myisamchk时内存分配重要.MYIsamchk使用的内存大小不能超过用-O选项指定的。如果你想对每一个大表使用myisamchk，你必须首先确定你想使用多少内存。修复时可以使用的 默认值只有3MB。使用更大的内存，可以让myisamchk工作得更快一些。例如，如果有大于32MB的RAM，可以使用如下所示选项(除了你可以指定的其它选项)：
shell> myisamchk -O sort=16M -O key=16M -O read=1M -O write=1M ...
对于大多数情况，使用-O sort=16M应该足够了。
应记住myisamchk使用TMPDIR中的临时文件。如果TMPDIR指向内存文件系统，你可能很容易得到内存溢出的错误。如果发生，设定TMPDIR指向有更多空间的文件系统目录并且重启myisamchk。
修复时myisamchk也需要大量硬盘空间：
·         将数据文件大小扩大一倍(原文件和复制文件)。如果你用--quick修复则不需要该空间；在这种情况下，只重新创建了索引文件。在文件系统上需要的空间与原数据文件相同！(创建的复制文件位于原文件所在目录）。
·         代替旧索引文件的新索引文件所占空间。修复工作一开始，就对旧索引文件进行了删减，因此你通常会忽略该空间。在文件系统上需要的该空间与原数据文件相同！
·         当使用--recover或---sort-recover(但不使用--safe-recover)时，需要排序缓冲区空间。需要的空间为：
·                (largest_key + row_pointer_length) * number_of_rows * 2
可以用myisamchk -dv tbl_name检查键值和row_pointer_length的长度。在临时目录分配该空间(用TMPDIR或--tmpdir=path指定)。
如果在修复过程中出现硬盘空间问题，可以试试用--safe-recover代替--recover。
5.9.5.6. 将myisamchk用于崩溃恢复
如果用--skip-external-locking运行mysqld(在某些系统上为 默认设置，例如Linux)，当mysqld使用某个表时，你不能可靠地使用myisamchk来检查相同的表。当你运行myisamchk时如果可以确保没有人在通过mysqld访问表，在开始检查表前，你只需要运行mysqladmin flush-tables。如果你不能保证，则你检查表时你必须停止mysqld。如果mysqld更新表时运行myisamchk，你可能会获得表被破坏的警告，即使事实并非如此。
如果不使用--skip-external-locking，可以随时使用myisamchk来检查表。当检查表时，所有尝试更新表的客户端将等待，直到myisamchk准备好可以继续。
如果使用myisamchk来修复或优化表，必须确保mysqld服务器没有在使用该表(如果你正使用--skip-external-locking选项也适用)。如果不关闭mysqld，在运行myisamchk之前至少应执行mysqladmin flush-tables。如果服务器和myisamchk同时访问表，表可能会被破坏。
本节描述如何检查和处理MySQL数据库中的数据破坏。如果表经常被破坏，你应尽力找到原因。参见A.4.2节，“如果MySQL依然崩溃，应作些什么”。
关于MyISAM表怎样会被破坏的解释，参见15.1.4节，“MyISAM表方面的问题”。
在执行崩溃恢复时，理解在一个数据库中的每一个MyISAM表tbl_name对应的在数据库目录中的3个文件是很重要的：
文件
目的
tbl_name.frm
定义(格式)文件
tbl_name.MYD
数据文件
tbl_name.MYI
索引文件
这3类文件的每一类都可能遭受不同形式的损坏，但是问题最常发生在数据文件和索引文件。 
myisamchk通过一行一行地创建一个“.MYD”数据文件的副本来工作，它通过删除旧的“.MYD 文件并且重命名新文件到原来的文件名结束修复阶段。如果你使用--quick，myisamchk不创建一个临时“.MYD”文件，只是假定“.MYD”文件是正确的并且仅创建一个新的索引文件，不接触“.MYD”文件，这是安全的，因为myisamchk自动检测“.MYD”文件是否损坏并且在这种情况下，放弃修复。你也可以给myisamchk两个--quick选项。在这种情况下，myisamchk不会在一些错误上(象重复键)放弃，相反试图通过修改“.MYD”文件解决它们。通常，只有在太少的空闲磁盘空间上实施正常修复，使用两个--quick选项时才有用。在这种情况下，你至少应该在运行myisamchk前做进行备份。
5.9.5.7. 如何检查MyISAM表的错误
要想检查MyISAM表，应使用下面的命令： 
·         myisamchk tbl_name
这样能找出99.99%的错误。它不能找出的是仅仅涉及数据文件的损坏(这很不常见)。如果想要检查一张表，通常应该没有选项地运行myisamchk或用-s或--silent选项的任何一个。
·         myisamchk -m tbl_name
这样能找出99.99%的错误。它首先检查所有索引条目的错误并通读所有行。它还计算行内所有键值的校验和，并确认校验和与索引树内键的校验和相匹配。
·         myisamchk -e tbl_name
可以完全彻底地检查数据(-e意思是“扩展检查”)。它对每一行做每个键的读检查以证实它们确实指向正确的行。这在一个有很多键的大表上可能花很长时间。myisamchk通常将在它发现第一个错误以后停止。如果你想要获得更多的信息，可以增加--verbose(-v)选项。这使得myisamchk继续一直到最多20个错误。
·         myisamchk -e -i tbl_name
象前面的命令一样，但是-i选项告诉myisamchk还打印出一些统计信息。
在一般使用中，一个简单的myisamchk（没有除表名以外的参数）就足够检查表了。
5.9.5.8. 如何修复表
本节描述如何对MyISAM表使用myisamchk(扩展名.MYI和.MYD)。
你还可以(并且应该，如果可能)使用CHECK TABLE和REPAIR TABLE语句来检查和修复MyISAM表。参见13.5.2.3节，“CHECK TABLE语法”和13.5.2.6节，“REPAIR TABLE语法”。
一张损坏的表的症状通常是查询意外中断并且能看到下述错误：
“tbl_name.frm”被锁定不能更改。 
不能找到文件“tbl_name.MYI”（Errcode：nnn）。 
文件意外结束。 
记录文件被毁坏。 
从表处理器得到错误nnn。 
要想得到错误相关的详细信息，你可以运行perror nnn，其中nnn为错误编号。下面的示例显示了如何使用perror来找到最常用错误编号（用表的方式指出问题）的含义：
shell> perror 126 127 132 134 135 136 141 144 145
126 = Index file is crashed / Wrong file format
127 = Record-file is crashed
132 = Old database file
134 = Record was already deleted (or record file crashed)
135 = No more room in record file
136 = No more room in index file
141 = Duplicate unique key or constraint on write or update
144 = Table is crashed and last repair failed
145 = Table was marked as crashed and should be repaired
请注意错误135(记录文件中没有更多的空间)和错误136(索引文件中没有更多的空间)不是可以通过简单修复可以修复的错误。在这种情况下，必须使用ALTER TABLE来增加MAX_ROWS和AVG_ROW_LENGTH表选项值：
ALTER TABLE tbl_name MAX_ROWS=xxx AVG_ROW_LENGTH=yyy;
如果你不知道当前的表的选项值，使用SHOW CREATE TABLE或DESCRIBE来查询。
对于其它的错误，你必须修复表。myisamchk通常可以检测和修复大多数问题。
修复过程包括四个阶段，此处将进行描述。开始修复前，应进入数据库目录并检查表文件的许可。在Unix中，确保它们对于运行mysqld的用户可读(你也应可读，因为你需要访问检查的文件)。如果你需要修改文件，你还必须拥有写访问权限。
用myisamchk修复表的选项的描述参见5.9.5节，“myisamchk：MyISAM表维护实用工具”的前几节。
下面几节列出了上述命令失败或你想要使用myisamchk提供的扩展特性等情况的例子。
如果你要通过命令行来修复表，必须首先停止mysqld服务器。请注意当你在远程服务器上运行mysqladmin shutdown时，mysqladmin返回后，mysqld服务器将仍然运行一会儿，直到停止所有查询并将所有键清空到硬盘上。
阶段1：检查你的表
如果你有很多时间，运行myisamchk *.MYI或myisamchk -e *.MYI。使用-s（沉默）选项禁止不必要的信息。
如果mysqld服务器处于宕机状态，应使用--update-state选项来告诉myisamchk将表标记为'检查过的'。
你必须只修复那些myisamchk报告有错误的表。对这样的表，继续到阶段2。
如果在检查时，你得到奇怪的错误(例如out of memory错误)，或如果myisamchk崩溃，到阶段3。
阶段2：简单安全的修复
注释：如果想更快地进行修复，当运行myisamchk时，你应将sort_buffer_size和Key_buffer_size变量的值设置为可用内存的大约25%。
首先，试试myisamchk -r -q tbl_name(-r -q意味着“快速恢复模式”)。这将试图不接触数据文件来修复索引文件。如果数据文件包含它应有的一切内容和指向数据文件内正确地点的删除连接，这应该管用并且表可被修复。开始修复下一张表。否则，执行下列过程：
1. 在继续前对数据文件进行备份。 
2. 使用myisamchk -r tbl_name(-r意味着“恢复模式”)。这将从数据文件中删除不正确的记录和已被删除的记录并重建索引文件。 
3. 如果前面的步骤失败，使用myisamchk --safe-recover tbl_name。安全恢复模式使用一个老的恢复方法，处理常规恢复模式不行的少数情况(但是更慢)。 
如果在修复时，你得到奇怪的错误(例如out of memory错误)，或如果myisamchk崩溃，到阶段3。
阶段3：困难的修复
只有在索引文件的第一个16K块被破坏，或包含不正确的信息，或如果索引文件丢失，你才应该到这个阶段。在这种情况下，需要创建一个新的索引文件。按如下步骤操做：
1. 把数据文件移到安全的地方。 
2. 使用表描述文件创建新的(空)数据文件和索引文件： 
3. shell> mysql db_name 
4. mysql> SET AUTOCOMMIT=1; 
5. mysql> TRUNCATE TABLE tbl_name; 
6. mysql> quit 
如果你的MySQL版本没有TRUNCATE TABLE，则使用DELETE FROM tbl_name。
7. 将老的数据文件拷贝到新创建的数据文件之中。（不要只是将老文件移回新文件之中；你要保留一个副本以防某些东西出错。） 
回到阶段2。现在myisamchk -r -q应该工作了。（这不应该是一个无限循环）。
你还可以使用REPAIR TABLE tbl_name USE_FRM，将自动执行整个程序。
阶段4：非常困难的修复 
只有.frm描述文件也破坏了，你才应该到达这个阶段。这应该从未发生过，因为在表被创建以后，描述文件就不再改变了。
1. 从一个备份恢复描述文件然后回到阶段3。你也可以恢复索引文件然后回到阶段2。对后者，你应该用myisamchk -r启动。 
2. 如果你没有进行备份但是确切地知道表是怎样创建的，在另一个数据库中创建表的一个拷贝。删除新的数据文件，然后从其他数据库将描述文件和索引文件移到破坏的数据库中。这样提供了新的描述和索引文件，但是让.MYD数据文件独自留下来了。回到阶段2并且尝试重建索引文件。 
5.9.5.9. 表优化
为了组合碎片记录并且消除由于删除或更新记录而浪费的空间，以恢复模式运行myisamchk：
shell> myisamchk -r tbl_name
你可以用SQL的OPTIMIZE TABLE语句使用的相同方式来优化表，OPTIMIZE TABLE可以修复表并对键值进行分析，并且可以对索引树进行排序以便更快地查找键值。实用程序和服务器之间不可能交互操作，因为当你使用OPTIMIZE TABLE时，服务器做所有的工作。参见13.5.2.5节，“OPTIMIZE TABLE语法”。
myisamchk还有很多其它可用来提高表的性能的选项：
·         -S, --sort-index
·         -R index_num, --sort-records=index_num
·         -a, --analyze
关于这些选项的完整的描述，参见5.9.5节，“myisamchk：MyISAM表维护实用工具”。
5.9.6. 建立表维护计划
定期对表进行检查而非等到问题出现后再检查数据库表是一个好主意。检查和修复MyISAM表的一个方式是使用CHECK TABLE和REPAIR TABLE语句。参见13.5.2.3节，“CHECK TABLE语法”和13.5.2.6节，“REPAIR TABLE语法”。
检查表的另一个方法是使用myisamchk。为维护目的，可以使用myisamchk -s检查表。-s选项（简称--silent）使myisamchk以沉默模式运行，只有当错误出现时才打印消息。
在服务器启动时检查表是一个好主意。例如，无论何时机器在更新当中重新启动了，你通常需要检查所有可能受影响的表。（即“预期的破坏了的表”）。要想自动检查MyISAM表，用--myisam-recover选项启动服务器。
一个更好的测试将是检查最后修改时间比“.pid”文件新的表。
你还应该在正常系统操作期间定期检查表。在MySQL AB，我们运行一个cron任务，每周一次检查所有重要的表，使用“crontab”文件中这样的行：
35 0 * * 0 /path/to/myisamchk --fast --silent /path/to/datadir/*/*.MYI
可以打印损坏的表的信息，以便我们在需要时能够检验并且修复它们。
多年了我们还没有发现(的确是真的)都没有任何意外损坏的表时(由于除硬件故障外的其它原因造成损坏的表)，每周一次对我们是足够了。
我们建议现在开始，你对所有最后24小时内被更新了的表每晚都执行myisamchk -s，直到你变得象我们那样信任MySQL。
一般情况，MySQL表很少需要维护。如果你用动态大小的行更改MyISAM表(含VARCHAR、BLOB或TEXT列的表)或有删除了许多行的表，你可能想要不时地（每月一次）整理/组合表的空间。
可以对有问题的表执行OPTIMIZE TABLE来优化。或者是，如果可以停一会mysqld服务器，进入数据目录，当服务器停止时使用该命令：
shell> myisamchk -r -s --sort-index -O sort_buffer_size=16M */*.MYI
5.9.7. 获取关于表的信息
为了获得关于一个表的描述或统计，使用下面的命令：
·         myisamchk -d tbl_name
以“描述模式”运行myisamchk，生成表的描述。如果用--skip-external-locking选项启动MySQL服务器，myisamchk可以报告运行的表被更新的错误。然而，既然在描述模式中myisamchk不更改表，没有任何破坏数据的风险。
·         myisamchk -d -v tbl_name
为了生成更多关于myisamchk正在做什么的信息，加上-v告诉它以冗长模式运行。
·         myisamchk -eis tbl_name
仅显示表的最重要的信息。因为必须读取整个表，该操作很慢。
·         myisamchk -eiv tbl_name
这类似 -eis，只是告诉你正在做什么。
下面为这些命令的输出示例。它们基于含这些数据和索引文件大小的表：
-rw-rw-r--   1 monty    tcx     317235748 Jan 12 17:30 company.MYD
-rw-rw-r--   1 davida   tcx      96482304 Jan 12 18:35 company.MYM
myisamchk -d输出示例：
MyISAM file:     company.MYI
Record format:   Fixed length
Data records:    1403698  Deleted blocks:         0
Recordlength:    226
 
table description:
Key Start Len Index   Type
1   2     8   unique  double
2   15    10  multip. text packed stripped
3   219   8   multip. double
4   63    10  multip. text packed stripped
5   167   2   multip. unsigned short
6   177   4   multip. unsigned long
7   155   4   multip. text
8   138   4   multip. unsigned long
9   177   4   multip. unsigned long
    193   1           text
myisamchk -d -v 输出示例：
MyISAM file:         company
Record format:       Fixed length
File-version:        1
Creation time:       1999-10-30 12:12:51
Recover time:        1999-10-31 19:13:01
Status:              checked
Data records:            1403698  Deleted blocks:              0
Datafile parts:          1403698  Deleted data:                0
Datafile pointer (bytes):      3  Keyfile pointer (bytes):     3
Max datafile length:  3791650815  Max keyfile length: 4294967294
Recordlength:                226
 
table description:
Key Start Len Index   Type                  Rec/key     Root Blocksize
1   2     8   unique  double                      1 15845376      1024
2   15    10  multip. text packed stripped        2 25062400      1024
3   219   8   multip. double                     73 40907776      1024
4   63    10  multip. text packed stripped        5 48097280      1024
5   167   2   multip. unsigned short           4840 55200768      1024
6   177   4   multip. unsigned long            1346 65145856      1024
7   155   4   multip. text                     4995 75090944      1024
8   138   4   multip. unsigned long              87 85036032      1024
9   177   4   multip. unsigned long             178 96481280      1024
    193   1           text
myisamchk -eis 输出示例：
Checking MyISAM file: company
Key:  1:  Keyblocks used:  97%  Packed:    0%  Max levels:  4
Key:  2:  Keyblocks used:  98%  Packed:   50%  Max levels:  4
Key:  3:  Keyblocks used:  97%  Packed:    0%  Max levels:  4
Key:  4:  Keyblocks used:  99%  Packed:   60%  Max levels:  3
Key:  5:  Keyblocks used:  99%  Packed:    0%  Max levels:  3
Key:  6:  Keyblocks used:  99%  Packed:    0%  Max levels:  3
Key:  7:  Keyblocks used:  99%  Packed:    0%  Max levels:  3
Key:  8:  Keyblocks used:  99%  Packed:    0%  Max levels:  3
Key:  9:  Keyblocks used:  98%  Packed:    0%  Max levels:  4
Total:    Keyblocks used:  98%  Packed:   17%
 
Records:          1403698    M.recordlength:     226
Packed:             0%
Recordspace used:     100%   Empty space:          0%
Blocks/Record:   1.00
Record blocks:    1403698    Delete blocks:        0
Recorddata:     317235748    Deleted data:         0
Lost space:             0    Linkdata:             0
 
User time 1626.51, System time 232.36
Maximum resident set size 0, Integral resident set size 0
Non physical pagefaults 0, Physical pagefaults 627, Swaps 0
Blocks in 0 out 0, Messages in 0 out 0, Signals 0
Voluntary context switches 639, Involuntary context switches 28966
myisamchk -eiv 输出示例：
Checking MyISAM file: company
Data records: 1403698   Deleted blocks:       0
- check file-size
- check delete-chain
block_size 1024:
index  1:
index  2:
index  3:
index  4:
index  5:
index  6:
index  7:
index  8:
index  9:
No recordlinks
- check index reference
- check data record references index: 1
Key:  1:  Keyblocks used:  97%  Packed:    0%  Max levels:  4
- check data record references index: 2
Key:  2:  Keyblocks used:  98%  Packed:   50%  Max levels:  4
- check data record references index: 3
Key:  3:  Keyblocks used:  97%  Packed:    0%  Max levels:  4
- check data record references index: 4
Key:  4:  Keyblocks used:  99%  Packed:   60%  Max levels:  3
- check data record references index: 5
Key:  5:  Keyblocks used:  99%  Packed:    0%  Max levels:  3
- check data record references index: 6
Key:  6:  Keyblocks used:  99%  Packed:    0%  Max levels:  3
- check data record references index: 7
Key:  7:  Keyblocks used:  99%  Packed:    0%  Max levels:  3
- check data record references index: 8
Key:  8:  Keyblocks used:  99%  Packed:    0%  Max levels:  3
- check data record references index: 9
Key:  9:  Keyblocks used:  98%  Packed:    0%  Max levels:  4
Total:    Keyblocks used:   9%  Packed:   17%
 
- check records and index references
[LOTS OF ROW NUMBERS DELETED]
 
Records:         1403698   M.recordlength:   226   Packed:           0%
Recordspace used:    100%  Empty space:        0%  Blocks/Record: 1.00
Record blocks:   1403698   Delete blocks:      0
Recorddata:    317235748   Deleted data:       0
Lost space:            0   Linkdata:           0
 
User time 1639.63, System time 251.61
Maximum resident set size 0, Integral resident set size 0
Non physical pagefaults 0, Physical pagefaults 10580, Swaps 0
Blocks in 4 out 0, Messages in 0 out 0, Signals 0
Voluntary context switches 10604, Involuntary context switches 122798
下面解释myisamchk产生的信息的类型。“keyfile”是索引文件。“记录”和“行”是同义词。
·         MyISAM file
ISAM(索引)文件名。
·         File-version
ISAM格式的版本。当前总是2。
·         Creation time
数据文件创建的时间。
·         Recover time
索引/数据文件上次被重建的时间。
·         Data records
在表中有多少记录。
·         Deleted blocks
有多少删除的块仍然保留着空间。你可以优化表以使这个空间减到最小。参见第7章：优化。
·         Datafile parts
对动态记录格式，这指出有多少数据块。对于一个没有碎片的优化过的表，这与Data records相同。
·         Deleted data
不能回收的删除数据有多少字节。你可以优化表以使这个空间减到最小。参见第7章：优化。
·         Datafile pointer
数据文件指针的大小，以字节计。它通常是2、3、4或5个字节。大多数表用2个字节管理，但是目前这还不能从MySQL控制。对固定表，这是一个记录地址。对动态表，这是一个字节地址。
·         Keyfile pointer
索引文件指针的大小，以字节计。它通常是1、2或3个字节。大多数表用 2 个字节管理，但是它自动由MySQL计算。它总是一个块地址。
·         Max datafile length
表的数据文件(.MYD文件)能够有多长，以字节计。
·         Max keyfile length
表的键值文件(.MYI文件)能够有多长，以字节计。
·           Recordlength
每个记录占多少空间，以字节计。
·         Record format
用于存储表行的格式。上面的例子使用Fixed length。其他可能的值是Compressed和Packed。
·         table description
在表中所有键值的列表。对每个键，给出一些底层的信息：
o        Key
该键的编号。
o        Start
该索引部分从记录的哪里开始。
o        Len
该索引部分是多长。对于紧凑的数字，这应该总是列的全长。对字符串，它可以比索引的列的全长短些，因为你可能会索引到字符串列的前缀。
o        Index
unique或multip（multiple)。表明一个值是否能在该索引中存在多次。
o        Type
该索引部分有什么数据类型。这是一个packed、stripped或empty选项的ISAM数据类型。
o        Root
根索引块的地址。
o        Blocksize
每个索引块的大小。默认是1024，但是从源码构建MySQL时，该值可以在编译时改变。
o        Rec/key
这是由优化器使用的统计值。它告诉对该键的每个值有多少条记录。唯一键总是有一个1值。在一个表被装载后(或变更很大)，可以用myisamchk -a更新。如果根本没被更新，给定一个30的默认值。
在上面例子的表中，第9个键有两个table description行。者说明它是有2个部分的多部键。
·         Keyblocks used
键块使用的百分比是什么。当在例子中使用的表刚刚用myisamchk重新组织时，该值非常高(很接近理论上的最大值)。
·         Packed
MySQL试图用一个通用后缀压缩键。这只能被用于CHAR/VARCHAR/DECIMAL列的键。对于左部分类似的长字符串，能显著地减少使用空间。在上面的第3个例子中，第4个键是10个字符长，可以减少60%的空间。
·         Max levels
对于该键的B树有多深。有长键的大表有较高的值。
·         Records
表中有多少行。
·         M.recordlength
平均记录长度。对于有定长记录的表，这是准确的记录长度，因为所有记录的长度相同。
·         Packed
MySQL从字符串的结尾去掉空格。Packed值表明这样做达到的节约的百分比。
·         Recordspace used
数据文件被使用的百分比。
·         Empty space
数据文件未被使用的百分比。
·         Blocks/Record
每个记录的平均块数(即，一个碎片记录由多少个连接组成)。对固定格式表，这总是1。该值应该尽可能保持接近1.0。如果它变得太大，你可以重新组织表。参见第7章：优化。
·         Recordblocks
多少块(链接)被使用。对固定格式，它与记录的个数相同。
·         Deleteblocks
多少块(链接)被删除。
·         Recorddata
在数据文件中使用了多少字节。
·         Deleted data
在数据文件中多少字节被删除(未使用)。
·         Lost space
如果一个记录被更新为更短的长度，就损失了一些空间。这是所有这样的损失之和，以字节计。
·         Linkdata
当使用动态表格式，记录碎片用指针连接(每个4 ～ 7字节)。 Linkdata指这样的指针使用的内存量之和。
如果一张表已经用myisampack压缩了，myisamchk -d打印每个表列的附加信息。对于它的一个例子及其含义的描述，参见8.2节，“myisampack：生成压缩、只读MyISAM表”。
5.10. MySQL本地化和国际应用
5.10.1. 数据和排序用字符集 
5.10.2. 设置错误消息语言 
5.10.3. 添加新的字符集 
5.10.4. 字符定义数组 
5.10.5. 字符串比较支持 
5.10.6. 多字节字符支持 
5.10.7. 字符集问题 
5.10.8. MySQL服务器时区支持
本节描述如何配置服务器来使用不同的字符集。还讨论如何设置服务器的时区并启用各个连接的时区支持。 
5.10.1. 数据和排序用字符集
5.10.1.1. 使用德国字符集
默认情况下，MySQL使用cp1252(Latin1)字符集根据Swedish/Finnish规则进行排序。这些 默认值适合美国和西欧大部分国家。
所有MySQL二进制分发版用--with-extra-charsets=complex编译而成。可以在所有标准程序中添加代码，使它们可以处理latin1和所有多字节二进制字符集。其它字符集根据需要从字符集定义文件载入。
字符集确定在名称中使用什么字符。它还确定如何用SELECT语句的ORDER BY和GROUP BY子句对字符串进行排序。
还可以在启动服务器时用--default-character-set选项更改字符集。字符集可以用--with-charset=charset和--with-extra-charsets=list-of-charsets | complex | all | none选项来configure，字符集配置文件列于SHAREDIR/charsets/Index。参见2.8.2节，“典型配置选项”。
还可以在你启动服务器时用--default-collation选项更改字符集 校对规则。校对规则必须是默认字符集的合法校对规则。(使用SHOW COLLATION语句来确定每个字符集使用哪个校对规则）。 参见2.8.2节，“典型配置选项”。
如果在运行MySQL时更改字符集，还会更改排序顺序。结果是你必须对所有表运行myisamchk -r -q --set-character-set=charset ，或正确地对索引进行排序。
当客户端连接MySQL服务器时，服务器告诉客户端服务器的默认字符集是什么。客户端切换到该字符集进行连接。
当转义SQL查询的字符串时，你应使用mysql_real_escape_string()。mysql_real_escape_string()等价于旧的mysql_escape_string()函数，不同的是它使用MYSQL连接句柄作为第一个参数，以便转义字符时可以使用相应的字符集。
如果客户端的编译路径不是服务器的安装目录，并且配置MySQL时没有包括MySQL二进制中的所有字符集，如果服务器运行时需要使用客户端设置的字符集之外的其它字符集，你必须告诉客户端从哪里找到更多的字符集。
可以指定--character-sets-dir选项来表示动态MySQL字符集所保存目录的路径。例如，可以将下面的行放入选项文件中：
[client]
character-sets-dir=/usr/local/mysql/share/mysql/charsets
你可以强制客户端使用专用字符集：
[client]
default-character-set=charset
但是一般情况不需要。
5.10.1.1. 使用德国字符集
在MySQL 5.1中,分别指定字符集和 校对规则。这说明如果你想使用German排序顺序，你应选择latin1 字符集和latin1_german1_ci或latin1_german2_ci校对规则。例如，要用latin1_german1_ci校对规则启动服务器，应使用--character-set-server=latin1和--collation-server=latin1_german1_ci选项。
关于这两种校对规则的不同之处，参见10.10.2节，“西欧字符集”。
5.10.2. 设置错误消息语言
默认情况下，mysqld用英语给出错误消息，但也可以用以下语言显示：Czech、Danish、Dutch、Estonian、French、German、Greek、Hungarian、Italian、Japanese、Korean、Norwegian、Norwegian-ny、Polish、Portuguese、Romanian、Russian、Slovak、Spanish或 Swedish。 
要想在启动mysqld后用具体语言显示错误消息，使用--language或-L选项。选项值可以为语言名称或错误消息文件的全路径。例如：
shell> mysqld --language=swedish
或：
shell> mysqld --language=/usr/local/share/swedish
语言名应为小写。
语言文件位于(默认情况下)MySQL基本目录的share/LANGUAGE目录下。
要想更改错误消息文件，应编辑errmsg.txt文件，然后执行下面的命令以生成errmsg.sys文件：
shell> comp_err errmsg.txt errmsg.sys
如果你升级到新版本的MySQL，记住使用新的errmsg.txt文件来重新更改。
5.10.3. 添加新的字符集
本节讨论在MySQL中添加新字符集的程序。你必须有一个MySQL源码分发版。
要选择正确的程序，先确定字符集是简单字符集还是复杂字符集：
·         如果字符集不需要使用特殊字符串校对规则程序进行排序，并且不需要多字节字符支持，则为简单字符集。
·         如果需要上述某个特性，则为复杂字符集。
例如，latin1和danish为简单字符集，而big5和czech为复杂字符集。
在下面的程序中，字符集名用MYSET表示。
对于简单字符集，应：
1.    在sql/share/charsets/Index文件最后添加MYSET。并指定唯一的编号。
2.    创建文件sql/share/charsets/MYSET.conf。(你可以使用sql/share/charsets/latin1.conf的备份文件作为该文件的基础）。 
该文件的语法很简单：
·         注释从‘#’字符开始，一直到该行末尾。
·         各字之间用任意数量的空格间隔开。
·         定义字符集时，每个字必须为十六进制格式的数字。
·         ctype数组占据前257个字。to_lower[]、to_upper[]和sort_order[]数组依次占据256个字。
参见5.10.4节，“字符定义数组”。
3.    将字符集名添加到configurE.in的CHARSETS_AVAILABLE和COMPILED_CHARSETS列。
4.    重新配置、编译并测试。
对于复杂字符集，应：
1.    在MySQL源码分发版中创建文件strings/ctype-MYSET.c。
2.    在sql/share/charsets/Index文件最后添加MYSET。并指定唯一的编号。
3.    看看已有的ctype-*.c文件(例如strings/ctype-big5.c)，看看需要定义什么。请注意文件中的数组名必须为ctype_MYSET、to_lower_MYSET等等。对应简单字符集的数组。参见5.10.4节，“字符定义数组”。
4.    在文件顶部，添加注释：
5.            /*
6.            * This comment is parsed by configure to create ctype.c,
7.            * so don't change it unless you know what you are doing.
8.            *
9.            * .configure. number_MYSET=MYNUMBER
10.        * .configure. strxfrm_multiply_MYSET=N
11.        * .configure. mbmaxlen_MYSET=N
12.        */
configure程序使用该注释自动将字符集包括进MySQL库中。
在下面章节中解释strxfrm_multiply和mbmaxlen 行。只有需要字符串比较函数或多字节字符集函数时，才需要单独将它们包括进来。
13.然后你应创建下面的函数：
my_strncoll_MYSET() 
my_strcoll_MYSET() 
my_strxfrm_MYSET() 
my_like_range_MYSET() 
参见5.10.5节，“字符串比较支持”
14.将字符集名添加到configurE.in的CHARSETS_AVAILABLE和COMPILED_CHARSETS列。
15.重新配置、编译并测试。
sql/share/charsets/README文件中包括详细的说明。
如果你想要MySQL分发中的字符集，请向MySQL内部邮件系统发邮件。参见1.7.1.1节，“The MySQL邮件列表”。
5.10.4. 字符定义数组
to_lower[]和to_upper[]是简单数组，含有小写和大写字符，对应字符集的每个成员。例如：
to_lower['A'] should contain 'a'
to_upper['a'] should contain 'A'
sort_order[]是一个映射，表示如何排列字符的顺序，以便进行比较和排序。通常(但非对于所有字符集)与to_upper[]相同，说明排序对大小写敏感。MySQL排序字符基于sort_order[]元素的值。对于更加复杂的排序规则，参见5.10.5节，“字符串比较支持”的字符串 校对规则讨论。
ctype[]是一个位数组，每个字符为一个元素。(请注意字符值索引to_lower[]、to_upper[]和sort_order[]，但用字符值+ 1索引ctype[]。这是传统的转换方法，能够处理EOF）。
m_ctype.h中有下面的位掩码定义：
#define _U      01      /* Uppercase */
#define _L      02      /* Lowercase */
#define _N      04      /* Numeral (digit) */
#define _S      010     /* Spacing character */
#define _P      020     /* Punctuation */
#define _C      040     /* Control character */
#define _B      0100    /* Blank */
#define _X      0200    /* heXadecimal digit */
每个字符的ctype[]条目应为相应的描述字符的位掩码值的联合。例如，'A'是大写字符(_U)以及十六进制整数(_X)，因此ctype['A'+1]应包含 值：
_U + _X = 01 + 0200 = 0201
5.10.5. 字符串比较支持
如果语言的排序规则比较复杂，不能用简单sort_order[]表来处理，需要使用字符串比较函数。 
最好的文档是已有字符集。以big5、czech、gbk、sjis和tis160字符集作为例子。
你必须在文件顶部的特殊注释处指定strxfrm_multiply_MYSET=N值。N应设置为字符串在my_strxfrm_MYSET过程中可能增长的最大比例(必须为正整数)。
5.10.6. 多字节字符支持
如果你想要添加包括多字节字符的新字符集支持，需要使用多字节字符函数。 
最好的文档是已有字符集。以euc_kr、gb2312,gbk、sjis和ujis字符集作为例子。这些字符集位于strings目录的ctype-charset.c文件中。
必须在文件顶部的特殊注释处指定mbmaxlen_MYSET=N值。N应设置为字符集内最长字符的字节数。
5.10.7. 字符集问题
如果你想要使用没有编译为二进制的字符集，可能会遇到下面的问题： 
·         你的程序的字符集保存路径不正确。(默认为/usr/local/mysql/share/mysql/charsets)。可以在运行有问题的程序时通过--character-sets-dir选项来修复。
·         字符集为多字节字符集，不能动态载入。在这种情况下，你必须重新编译程序，以支持字符集。
·         字符集为动态字符集，但你没有对应的配置文件。在这种情况下，你应从新MySQL分发安装该字符集的配置文件。
·         如果Index文件没有包含字符集名，程序将显示下面的错误消息：
·                ERROR 1105: File '/usr/local/share/mysql/charsets/?.conf'
·                not found (Errcode：2)
在这种情况下，你应获得新Index文件或在当前文件中手动添加字符集。
对于MyISAM表，可以用myisamchk -dvv tbl_name检查表的字符集名和编号。
5.10.8. MySQL服务器时区支持
 MySQL服务器有几个时区设置：
·         系统时区。服务器启动时便试图确定主机的时区，用它来设置system_time_zone系统变量。
·         服务器当前的时区。全局系统变量time_zone表示服务器当前使用的时区。初使值为'SYSTEM'，说明服务器时区与系统时区相同。可以用--default-time-zone=timez选项显式指定初使值。如果你有SUPER 权限，可以用下面的语句在运行时设置全局变量值：
·                mysql> SET GLOBAL time_zone = timezone;
·         每个连接的时区。每个客户端连接有自己的时区设置，用会话time_zone变量给出。其初使值与全局变量time_zone相同，但可以用下面的语句重设：
·                mysql> SET time_zone = timezone;
可以用下面的方法查询当前的全局变量值和每个连接的时区：
mysql> SELECT @@global.time_zone, @@session.time_zone;
timezone值为字符串，表示UTC的偏移量，例如'+10:00'或'-6:00'。如果已经创建并装入mysql数据库中的时区相关表，你还可以使用命名的时区，例如'Europe/Helsinki'、'US/Eastern'或'MET'。值'SYSTEM'说明该时区应与系统时区相同。时区名对大小写不敏感。
MySQL安装程序在mysql数据库中创建时区表，但不装载。你必须手动装载。(如果你正从以前的版本升级到MySQL 4.1.3或更新版本，你应通过升级mysql数据库来创建表。参见2.10.2节，“升级授权表”中的说明）。
如果你的系统有自己的时区信息数据库(描述时区的一系列文件)，应使用mysql_tzinfo_to_sql程序来填充时区表。示例系统如Linux、FreeBSD、Sun Solaris和Mac OS X。这些文件的可能位置为/usr/share/zoneinfo目录。如果你的系统没有时区信息数据库，可以使用本节后面描述的下载的软件包。
mysql_tzinfo_to_sql程序用来装载时区表。在命令行中，将时区信息目录路径名传递到mysql_tzinfo_to_sql并输出发送到mysql程序。例如：
shell> mysql_tzinfo_to_sql /usr/share/zoneinfo | mysql -u root mysql
mysql_tzinfo_to_sql读取系统时区文件并生成SQL语句。mysql处理这些语句并装载时区表。
mysql_tzinfo_to_sql还可以用来装载单个时区文件，并生成闰秒信息。
要想装载对应时区tz_name的单个时区文件tz_file，应这样调用mysql_tzinfo_to_sql：
shell> mysql_tzinfo_to_sql tz_file tz_name | mysql -u root mysql
如果你的时区需要计算闰秒，按下面方法初使化闰秒信息，其中tz_file是时区文件名：
shell> mysql_tzinfo_to_sql --leap tz_file | mysql -u root mysql
如果你的系统没有时区信息数据库 (例如，Windows或HP-UX)，你可以从http://dev.mysql.com/downloads/timezones.html下载预构建时区表软件包。该软件包包含MyISAM时区表所用的.frm、.MYD和.MYI文件。这些表应属于mysql数据库，因此应将这些文件放到MySQL服务器数据目录的mysql子目录。操作时应关闭服务器。
警告！如果你的系统有时区信息数据库，请不要使用下载的软件包。而应使用mysql_tzinfo_to_sql实用工具！否则，MySQL和系统上其它应用程序处理日期时间的方法会有所不同。
关于在复制时时区设置相关请查阅6.7节，“复制特性和已知问题”。
5.11. MySQL日志文件
5.11.1. 错误日志 
5.11.2. 通用查询日志 
5.11.3. 二进制日志 
5.11.4. 慢速查询日志 
5.11.5. 日志文件维护
MySQL有几个不同的日志文件，可以帮助你找出mysqld内部发生的事情：
日志文件
记入文件中的信息类型
错误日志
记录启动、运行或停止mysqld时出现的问题。
查询日志
记录建立的客户端连接和执行的语句。
更新日志
记录更改数据的语句。不赞成使用该日志。
二进制日志
记录所有更改数据的语句。还用于复制。
慢日志
记录所有执行时间超过long_query_time秒的所有查询或不使用索引的查询。
默认情况下，所有日志创建于mysqld数据目录中。通过刷新日志，你可以强制 mysqld来关闭和重新打开日志文件（或者在某些情况下切换到一个新的日志）。当你执行一个FLUSH LOGS语句或执行mysqladmin flush-logs或mysqladmin refresh时，出现日志刷新。参见13.5.5.2节，“FLUSH语法”。
如果你正使用MySQL复制功能，从复制服务器将维护更多日志文件，被称为接替日志。相关讨论参见第6章：MySQL中的复制。
5.11.1. 错误日志
错误日志文件包含了当mysqld启动和停止时，以及服务器在运行过程中发生任何严重错误时的相关信息。
如果mysqld莫名其妙地死掉并且mysqld_safe需要重新启动它，mysqld_safe在错误日志中写入一条restarted mysqld消息。如果mysqld注意到需要自动检查或着修复一个表，则错误日志中写入一条消息。
在一些操作系统中，如果mysqld死掉，错误日志包含堆栈跟踪信息。跟踪信息可以用来确定mysqld死掉的地方。参见E.1.4节，“使用堆栈跟踪”。
可以用--log-error[=file_name]选项来指定mysqld保存错误日志文件的位置。如果没有给定file_name值，mysqld使用错误日志名host_name.err 并在数据目录中写入日志文件。如果你执行FLUSH LOGS，错误日志用-old重新命名后缀并且mysqld创建一个新的空日志文件。(如果未给出--log-error选项，则不会重新命名）。
如果不指定--log-error，或者(在Windows中)如果你使用--console选项，错误被写入标准错误输出stderr。通常标准输出为你的终端。
在Windows中，如果未给出--console选项，错误输出总是写入.err文件。
5.11.2. 通用查询日志
如果你想要知道mysqld内部发生了什么，你应该用--log[=file_name]或-l [file_name]选项启动它。如果没有给定file_name的值， 默认名是host_name.log。所有连接和语句被记录到日志文件。当你怀疑在客户端发生了错误并想确切地知道该客户端发送给mysqld的语句时，该日志可能非常有用。 
mysqld按照它接收的顺序记录语句到查询日志。这可能与执行的顺序不同。这与更新日志和二进制日志不同，它们在查询执行后，但是任何一个锁释放之前记录日志。(查询日志还包含所有语句，而二进制日志不包含只查询数据的语句）。 
服务器重新启动和日志刷新不会产生新的一般查询日志文件(尽管刷新关闭并重新打开一般查询日志文件)。在Unix中，你可以通过下面的命令重新命名文件并创建一个新文件：
shell> mv hostname.log hostname-old.log
shell> mysqladmin flush-logs
shell> cp hostname-old.log to-backup-directory
shell> rm hostname-old.log
在Windows中，服务器打开日志文件期间你不能重新命名日志文件。你必须先停止服务器然后重新命名日志文件。然后，重启服务器来创建新的日志文件。
5.11.3. 二进制日志
二进制日志以一种更有效的格式，并且是事务安全的方式包含更新日志中可用的所有信息。
二进制日志包含了所有更新了数据或者已经潜在更新了数据（例如，没有匹配任何行的一个DELETE）的所有语句。语句以“事件”的形式保存，它描述数据更改。
注释：二进制日志已经代替了老的更新日志，更新日志在MySQL 5.1中不再使用。
二进制日志还包含关于每个更新数据库的语句的执行时间信息。它不包含没有修改任何数据的语句。如果你想要记录所有语句（例如，为了识别有问题的查询），你应使用一般查询日志。参见5.11.2节，“通用查询日志”。
二进制日志的主要目的是在恢复使能够最大可能地更新数据库，因为二进制日志包含备份后进行的所有更新。
二进制日志还用于在主复制服务器上记录所有将发送给从服务器的语句。参见第6章：MySQL中的复制。
运行服务器时若启用二进制日志则性能大约慢1%。但是，二进制日志的好处，即用于恢复并允许设置复制超过了这个小小的性能损失。
当用--log-bin[=file_name]选项启动时，mysqld写入包含所有更新数据的SQL命令的日志文件。如果未给出file_name值， 默认名为-bin后面所跟的主机名。如果给出了文件名，但没有包含路径，则文件被写入数据目录。建议指定一个文件名，原因参见A.8.1节，“MySQL中的打开事宜”。
如果你在日志名中提供了扩展名(例如，--log-bin=file_name.extension)，则扩展名被悄悄除掉并忽略。
mysqld在每个二进制日志名后面添加一个数字扩展名。每次你启动服务器或刷新日志时该数字则增加。如果当前的日志大小达到max_binlog_size，还会自动创建新的二进制日志。如果你正使用大的事务，二进制日志还会超过max_binlog_size：事务全写入一个二进制日志中，绝对不要写入不同的二进制日志中。
为了能够知道还使用了哪个不同的二进制日志文件，mysqld还创建一个二进制日志索引文件，包含所有使用的二进制日志文件的文件名。默认情况下与二进制日志文件的文件名相同，扩展名为'.index'。你可以用--log-bin-index[=file_name]选项更改二进制日志索引文件的文件名。当mysqld在运行时，不应手动编辑该文件；如果这样做将会使mysqld变得混乱。
可以用RESET MASTER语句删除所有二进制日志文件，或用PURGE MASTER LOGS只删除部分二进制文件。参见13.5.5.5节，“RESET语法”和13.6.1节，“用于控制主服务器的SQL语句”。
二进制日志格式有一些已知限制，会影响从备份恢复。参见6.7节，“复制特性和已知问题”。
保存程序和触发器的二进制日志的描述参见20.4节，“存储子程序和触发程序的二进制日志功能”。
可以使用下面的mysqld选项来影响记录到二进制日志知的内容。又见选项后面的讨论。
·         --binlog-do-db=db_name
告诉主服务器，如果当前的数据库(即USE选定的数据库)是db_name，应将更新记录到二进制日志中。其它所有没有明显指定的数据库  被忽略。如果使用该选项，你应确保只对当前的数据库进行更新。
对于CREATE DATABASE、ALTER DATABASE和DROP DATABASE语句，有一个例外，即通过操作的数据库来决定是否应记录语句，而不是用当前的数据库。
一个不能按照期望执行的例子：如果用binlog-do-db=sales启动服务器，并且执行USE prices; UPDATE sales.january SET amount=amount+1000；，该语句不写入二进制日志。
·         --binlog-ignore-db=db_name
告诉主服务器，如果当前的数据库(即USE选定的数据库)是db_name，不应将更新保存到二进制日志中。如果你使用该选项，你应确保只对当前的数据库进行更新。
一个不能按照你期望的执行的例子：如果服务器用binlog-ignore-db=sales启动，并且执行USE prices; UPDATE sales.january SET amount=amount+1000；，该语句不写入二进制日志。
类似于--binlog-do-db，对于CREATE DATABASE、ALTER DATABASE和DROP DATABASE语句，有一个例外，即通过操作的数据库来决定是否应记录语句，而不是用当前的数据库。
要想记录或忽视多个数据库，使用多个选项，为每个数据库指定相应的选项。
服务器根据下面的规则对选项进行评估，以便将更新记录到二进制日志中或忽视。请注意对于CREATE/ALTER/DROP DATABASE语句有一个例外。在这些情况下，根据以下规则，所创建、修改或删除的数据库将代替当前的数据库。
1.    是否有binlog-do-db或binlog-ignore-db规则? 
·         没有：将语句写入二进制日志并退出。
·         有：执行下一步。
2.    有一些规则(binlog-do-db或binlog-ignore-db或二者都有)。当前有一个数据库(USE是否选择了数据库?)? 
·         没有：不要写入语句，并退出。
·         有：执行下一步。
3.    有当前的数据库。是否有binlog-do-db规则? 
·         有：当前的数据库是否匹配binlog-do-db规则? 
o        有：写入语句并退出。
o        没有：不要写入语句，退出。
·         No：执行下一步。
4.    有一些binlog-ignore-db规则。当前的数据库是否匹配binlog-ignore-db规则? 
·         有：不要写入语句，并退出。
·         没有：写入查询并退出。
例如，只用binlog-do-db=sales运行的服务器不将当前数据库不为sales的语句写入二进制日志(换句话说，binlog-do-db有时可以表示“忽视其它数据库”)。
如果你正进行复制，应确保没有从服务器在使用旧的二进制日志文件，方可删除它们。一种方法是每天一次执行mysqladmin flush-logs并删除三天前的所有日志。可以手动删除，或最好使用PURGE MASTER LOGS(参见13.6.1节，“用于控制主服务器的SQL语句”)，该语句还会安全地更新二进制日志索引文件(可以采用日期参数)。
具有SUPER权限的客户端可以通过SET SQL_LOG_BIN=0语句禁止将自己的语句记入二进制记录。参见13.5.3节，“SET语法”。
你可以用mysqlbinlog实用工具检查二进制日志文件。如果你想要重新处理日志止的语句，这很有用。例如，可以从二进制日志更新MySQL服务器，方法如下：
shell> mysqlbinlog log-file | mysql -h server_name
关于mysqlbinlog实用工具的详细信息以及如何使用它，参见8.6节，“mysqlbinlog：用于处理二进制日志文件的实用工具”。
如果你正使用事务，必须使用MySQL二进制日志进行备份，而不能使用旧的更新日志。
查询结束后、锁定被释放前或提交完成后则立即记入二进制日志。这样可以确保按执行顺序记入日志。
对非事务表的更新执行完毕后立即保存到二进制日志中。对于事务表，例如BDB或InnoDB表，所有更改表的更新(UPDATE、DELETE或INSERT) 被缓存起来，直到服务器接收到COMMIT语句。在该点，执行完COMMIT之前，mysqld将整个事务写入二进制日志。当处理事务的线程启动时，它为缓冲查询分配binlog_cache_size大小的内存。如果语句大于该值，线程则打开临时文件来保存事务。线程结束后临时文件被删除。
Binlog_cache_use状态变量显示了使用该缓冲区(也可能是临时文件)保存语句的事务的数量。Binlog_cache_disk_use状态变量显示了这些事务中实际上有多少必须使用临时文件。这两个变量可以用于将binlog_cache_size调节到足够大的值，以避免使用临时文件。
max_binlog_cache_size(默认4GB)可以用来限制用来缓存多语句事务的缓冲区总大小。如果某个事务大于该值，将会失败并 回滚。
如果你正使用更新日志或二进制日志，当使用CREATE ... SELECT or INSERT ... SELECT时，并行插入被转换为普通插入。这样通过在备份时使用日志可以确保重新创建表的备份。
请注意MySQL 5.1值的二进制日志格式与以前版本的MySQL不同，因为复制改进了。参见6.5节，“不同MySQL版本之间的复制兼容性”。
默认情况下，并不是每次写入时都将二进制日志与硬盘同步。因此如果操作系统或机器(不仅仅是MySQL服务器)崩溃，有可能二进制日志中最后的语句丢失了。要想防止这种情况，你可以使用sync_binlog全局变量(1是最安全的值，但也是最慢的)，使二进制日志在每N次二进制日志写入后与硬盘同步。参见5.3.3节，“服务器系统变量”。即使sync_binlog设置为1,出现崩溃时，也有可能表内容和二进制日志内容之间存在不一致性。例如，如果使用InnoDB表，MySQL服务器处理COMMIT语句，它将整个事务写入二进制日志并将事务提交到InnoDB中。如果在两次操作之间出现崩溃，重启时，事务被InnoDB回滚，但仍然存在二进制日志中。可以用--innodb-safe-binlog选项解决该问题，可以增加InnoDB表内容和二进制日志之间的一致性。(注释：在MySQL 5.1中不需要--innodb-safe-binlog；由于引入了XA事务支持，该选项作废了）。 
该选项可以提供更大程度的安全，还应对MySQL服务器进行配置，使每个事务的二进制日志(sync_binlog =1)和(默认情况为真)InnoDB日志与硬盘同步。该选项的效果是崩溃后重启时，在滚回事务后，MySQL服务器从二进制日志剪切 回滚的InnoDB事务。这样可以确保二进制日志反馈InnoDB表的确切数据等，并使从服务器保持与主服务器保持同步(不接收 回滚的语句)。
请注意即使MySQL服务器更新其它存储引擎而不是InnoDB，也可以使用--innodb-safe-binlog。在InnoDB崩溃恢复时，只从二进制日志中删除影响InnoDB表的语句/事务。如果崩溃恢复时MySQL服务器发现二进制日志变短了(即至少缺少一个成功提交的InnoDB事务)，如果sync_binlog =1并且硬盘/文件系统的确能根据需要进行同步(有些不需要)则不会发生，则输出错误消息 ("二进制日志<名>比期望的要小")。在这种情况下，二进制日志不准确，复制应从主服务器的数据快照开始。
写入二进制日志文件和二进制日志索引文件的方法与写入MyISAM表相同。参见A.4.3节，“MySQL处理磁盘满的方式”。
5.11.4. 慢速查询日志
用--log-slow-queries[=file_name]选项启动时，mysqld写一个包含所有执行时间超过long_query_time秒的SQL语句的日志文件。获得初使表锁定的时间不算作执行时间。
如果没有给出file_name值， 默认未主机名，后缀为-slow.log。如果给出了文件名，但不是绝对路径名，文件则写入数据目录。
语句执行完并且所有锁释放后记入慢查询日志。记录顺序可以与执行顺序不相同。
慢查询日志可以用来找到执行时间长的查询，可以用于优化。但是，检查又长又慢的查询日志会很困难。要想容易些，你可以使用mysqldumpslow命令获得日志中显示的查询摘要来处理慢查询日志。
在MySQL 5.1的慢查询日志中，不使用索引的慢查询同使用索引的查询一样记录。要想防止不使用索引的慢查询记入慢查询日志，使用--log-short-format选项。参见5.3.1节，“mysqld命令行选项”。
在MySQL 5.1中,通过--log-slow-admin-statements服务器选项，你可以请求将慢管理语句，例如OPTIMIZE TABLE、ANALYZE TABLE和 ALTER TABLE写入慢查询日志。
用查询缓存处理的查询不加到慢查询日志中，因为表有零行或一行而不能从索引中受益的查询也不写入慢查询日志。
5.11.5. 日志文件维护
MySQL服务器可以创建各种不同的日志文件，从而可以很容易地看见所进行的操作。参见5.11节，“MySQL日志文件”。但是，你必须定期清理这些文件，确保日志不会占用太多的硬盘空间。
当启用日志使用MySQL时，你可能想要不时地备份并删除旧的日志文件，并告诉MySQL开始记入新文件。参见5.9.1节，“数据库备份”。
在 Linux (Redhat)的安装上，你可为此使用mysql-log-rotate脚本。如果你从RPM分发安装MySQL，脚本应该自动被安装了。
在其它系统上，你必须自己安装短脚本，你可从cron等入手处理日志文件。
你可以通过mysqladmin flush-logs或SQL语句FLUSH LOGS来强制MySQL开始使用新的日志文件。
日志清空操作做下列事情：
如果使用标准日志(--log)或慢查询日志(--log-slow-queries)，关闭并重新打开日志文件。(默认为mysql.log和`hostname`-slow.log)。 
如果使用更新日志(--log-update)或二进制日志(--log-bin)，关闭日志并且打开有更高序列号的新日志文件。 
如果你只使用更新日志，你只需要重新命名日志文件，然后在备份前清空日志。例如，你可以这样做：
shell> cd mysql-data-directory
shell> mv mysql.log mysql.old
shell> mysqladmin flush-logs
然后做备份并删除“mysql.old”。
5.12. 在同一台机器上运行多个MySQL服务器
5.12.1. 在Windows下运行多个服务器 
5.12.2. 在Unix中运行多个服务器 
5.12.3. 在多服务器环境中使用客户端程序
在一些情况下，你可能想要在同一台机器上运行多个mysqld服务器。你可能想要测试一个新的MySQL发布，同时不影响现有产品的设置。或者，你可能想使不同的用户访问来访问不同的mysqld服务器以便他们自己来管理。(例如，你可能是一个Internet服务提供商，希望为不同的客户来提供独立的MySQL安装）。
要想在一个单独的机器上运行多个服务器，每个服务器必须有唯一的各运行参数值。这些值可以在命令行中设置或在选项文件中设置。参见4.3节，“指定程序选项”。
至少下面的选项对每个服务器必须是不同的：
·         --port=port_num
--port控制着TCP/IP连接的端口号。
·         --socket=path
--socket控制Unix中的Unix套接字文件路径和在Windows中的命名管道名称。在Windows中，只有支持命名管道连接的服务器才需要明确指定管道名称。
·         --shared-memory-base-name=name
该选项当前只在Windows中使用。它指定Windows服务器使用的、允许客户端通过共享内存来连接的共享内存名。
·         --pid-file=path
该选项只在Unix中使用。它指出服务器在其中写入进程ID的文件名。
如果你使用下面的日志文件选项，对于每个服务器来说，它们必须是不同的：
·           --log=path
·         --log-bin=path
·         --log-update=path
·         --log-error=path
·         --bdb-logdir=path
日志文件选项的描述参见5.11.5节，“日志文件维护”。
为了提高性能，你可以为每个服务器指定下面选项的不同的值，以便在物理磁盘之间平均分配负荷：
·         --tmpdir=path
·         --bdb-tmpdir=path
还推荐使用不同的临时目录，以便容易地确定哪个MySQL服务器创建了给定的临时文件。
一般情况，每个服务器应还使用不同的数据目录，可以通过--datadir=path选项来指定。
警告：一般情况，你决不要让两个服务器更新相同数据库中的数据。否则，如果你的操作系统不支持故障排除系统锁定，该可能会导致非常奇怪的结果。如果（不理会该警告）运行的多个服务器使用相同的数据目录并且启用了日志记录，你必须使用适当的选项来为每个服务器指定唯一的日志文件名。否则，服务器尝试用相同的文件来记录日志。请注意这种类型的设置只能在MyISAM和MERGE表上工作，对其它任何存储引擎不起作用。
多个服务器共享一个数据目录的警告也适用于NFS环境。允许多个MySQL服务器通过NFS访问一个共同的数据目录是一个非常不好的主义。
·         主要问题是NFS存在速度瓶颈。它不是用于这种用途。
·         用NFS的另一个冒险是你必须提出一个方法来确保两个或多个服务器不会相互干扰。NFS文件的锁定通常由lockd后台程序处理，但是目前，没有一个运行平台能够在每种情况下100%可靠地进行锁定。
使你更加容易：忘记在服务器之间通过NFS共享数据目录。一个较好的解决方案是使用包含几个CPU并且和使用有效处理多线程的操作系统的机器。
如果在不同的位置有多个MySQL的安装，一般情况可以用--basedir=path选项为每个服务器指定基本安装目录，使每个服务器使用不同的数据目录、日志文件和PID文件。（所有这些值的 默认值相对于根目录来确定）。那样的话， 你唯一需要指定的其它选项是--socket和--port选项。例如，假如使用tar文件二进制分发版安装不同的MySQL版本。这些安装在不同的位置，因此可以使用各个安装服务器相应的根目录中的bin/mysqld_safe命令来启动服务器。mysqld_safe确定正确的--basedir选项传递给mysqld，你仅需要为mysqld_safe指定--socket和--port选项。
正如下面几节所讨论的那样，可以通过设置环境变量或用指定的命令行选项来启动更多的服务器。但是，如果你需要在一个更稳定的基础上运行多个服务器，一个更方便的方法是使用选项文件来为每个服务器指定那些选项值，它对每个服务器必须是唯一的。
5.12.1. 在Windows下运行多个服务器
5.12.1.1. 在命令行中启动多个Windows服务器 
5.12.1.2. 做为服务启动多个Windows服务器
在Windows中，可以从命令行手动启动来运行多个服务器，每个服务器使用合适的操作参数。在基于Windows NT的系统中，安装几个服务器时，你还有将多个服务器安装为Windows服务并运行的选项。关于从命令行运行MySQL服务器或作为服务运行的一般说明在 2.3节，“在Windows上安装MySQL”中给出。本节描述怎样确保你用不同的启动选项值（对于每个服务器必须是唯一的，例如数据目录）启动各个服务器。这些选项的描述见5.12节，“在同一台机器上运行多个MySQL服务器”。
5.12.1.1. 在命令行中启动多个Windows服务器
为了从命令行手动启动多个服务器，可以在命令行中或在选项文件中指定适当的选项。把选项放在选项文件中比较方便，但是需要确保每个服务器可以获得自己的选项。为了实现，为每个创建一个选项文件，并且运行服务时通过--defaults-file选项告诉服务器选项文件名。 
假设你想要在端口3307使用数据目录C:\mydata1运行mysqld，并且想在端口3308使用数据目录C:\mydata1运行mysqld-max。(要想这样做，启动服务器之前要确保，每个数据目录存在并且有自己的mysql数据库拷贝，它包含 授权表）。 
然后创建两个选项文件。例如，创建一个文件名为C:\my-opts1.cnf的配置文件，它看起来象这个样子：
[mysqld]
datadir = C:/mydata1
port = 3307
创建第二个文件名为C:\my-opts1.cnf的配置文件，它看起来象这个样子：
mysqld]
datadir = C:/mydata2
port = 3308
然后，用它们自己的选项文件启动每个服务器：
C:\> C:\mysql\bin\mysqld --defaults-file=C:\my-opts1.cnf
C:\> C:\mysql\bin\mysqld-max --defaults-file=C:\my-opts2.cnf
在NT中，每个服务器在前台启动（服务器退出前，不会显示新的提示符）；需要在两个控制台窗口中执行这两个命令。
要想关闭服务器，必须连接到相应的端口号：
C:\> C:\mysql\bin\mysqladmin --port=3307 shutdown
C:\> C:\mysql\bin\mysqladmin --port=3308 shutdown
如刚才所讨论的，服务器配置允许客户端通过TCP/IP来连接。如果你的Windows版本支持命名管道并且你想允许命名管道连接，使用mysqld-nt或mysqld-max-nt服务器并指定启用命名管道并且指定管道名的选项。支持命名管道连接的每个服务器必须使用一个唯一的管道名。例如，C:\my-opts1.cnf文件可能象这样来书写：
[mysqld]
datadir = C:/mydata1
port = 3307
enable-named-pipe
socket = mypipe1
然后，这样启动服务器：
C:\> C:\mysql\bin\mysqld-nt --defaults-file=C:\my-opts1.cnf
同样修改第2个服务器使用的C:\my-opts2.cnf文件。
5.12.1.2. 做为服务启动多个Windows服务器
在基于NT的系统中，MySQL服务器可以以Windows服务的方式来运行。安装、控制和删除单个MySQL服务的过程描述见2.3.12节，“以Windows服务方式启动MySQL”。
你还可以以服务的方式安装多个MySQL服务器。此时，除了所有参数对每个服务器必须是唯一的，你还必须确保每个服务器使用不同的服务名。
在下面的说明中，假设你想要运行mysqld-nt服务器的两个不同的版本，它们分别安装在C:\mysql-4.1.8和C:\mysql-5.1.2-alpha目录中。(可能存在这种情况，如果你正在运行版本4.1.8作为你的产品服务器，还想使用5.1.2-alpha版本来进行测试）。 
当用--install或--install-manual选项安装一个MySQL服务时，应遵从以下原则：
·         如果你没有指定服务名，服务器使用默认的MySQL服务名，从标准选项文件的[mysqld]组中读取选项。
·         如果你在--install选项后指定了服务名，服务器忽略[mysqld]选项组，从具有相同名的组中读取选项作为服务名。服务器从标准选项文件中读取选项。
·         如果你在服务名后面指定一个--defaults-file选项，服务器忽略标准选项文件，只从命名的文件的[mysqld]组读取选项。
注释：MySQL 4.0.17之前，只有使用默认服务名（MySQL）安装的一个服务器或使用服务名mysqld显式安装的一个服务器从标准选项文件读[mysqld]组。到4.0.17时，如果服务器读标准选项文件，则它们均读[mysqld]组，即使它们安装时使用了另一个服务名。这样允许你为选项使用[mysqld]组，用于所有MySQL服务器，并将根据每个服务器命名的选项组用于该服务器，即使用那个服务名安装的服务器。
根据前面叙述，你可以通过几个方法来设置多个服务器。下面的说明描述了一些示例。在尝试之前，应确保你首先关闭并且卸载了所有已有的MySQL服务器。
·         方法1：在一个标准选项文件中指定所有服务器选项。要想这样做，为每个服务器使用不同的服务名。假设你想使用服务名mysqld1运行4.1.8版的mysqld-nt并使用服务名mysqld2运行5.1.2-alpha版的mysqld-nt。在这种情况下，你可以为4.1.8使用[mysqld1]组，为5.1.2-alpha使用[mysqld2]组。例如，你可以象这样建立 C:\my.cnf文件：
·                # options for mysqld1 service
·                [mysqld1]
·                basedir = C:/mysql-4.1.8
·                port = 3307
·                enable-named-pipe
·                socket = mypipe1
·                 
·                # options for mysqld2 service
·                [mysqld2]
·                basedir = C:/mysql-5.1.2-alpha
·                port = 3308
·                enable-named-pipe
·                socket = mypipe2
如下面所示安装服务器，使用服务器的全路径名来确保Windows为每个服务注册正确的可执行程序：
C:\> C:\mysql-4.1.8\bin\mysqld-nt --install mysqld1
C:\> C:\mysql-5.1.2-alpha\bin\mysqld-nt --install mysqld2
为了启动服务器，使用服务管理器，或用带有适当的服务名的NET START：
C:\> NET START mysqld1
C:\> NET START mysqld2
要想停止服务，使用服务管理器，或用带有适当的服务名的NET STOP：
C:\> NET STOP mysqld1
C:\> NET STOP mysqld2
·         方法2：为每个服务器用不同的文件指定选项，当你安装服务时使用--defaults-file告诉每个服务器使用什么文件。此时，每个文件应用一个[mysqld]组列出选项。
使用这种方法为4.1.8版本的mysqld-nt指定选项，应象这样创建一个C:\my-opts1.cnf文件：
[mysqld]
basedir = C:/mysql-4.1.8
port = 3307
enable-named-pipe
socket = mypipe1
对于5.1.2-alpha版的mysqld-nt，象这样创建一个C:\my-opts2.cnf文件：
[mysqld]
basedir = C:/mysql-5.1.2-alpha port = 3308
enable-named-pipe
socket = mypipe2
安装服务如下（在一个单一行中输入每个命令）：
C:\> C:\mysql-4.1.8\bin\mysqld-nt -- installmysqld1
           --defaults-file=C:\my-opts1.cnf
C:\> C:\mysql-5.1.2-alpha\bin\mysqld-nt -- installmysqld2
           --defaults-file=C:\my-opts2.cnf
当你作为服务安装一个MySQL服务器时，要想使用--defaults-file选项，你必须在此选项之前加服务名。
安装服务后，按照与前面的示例相同的方法启动和停止。
要想卸载多个服务，对每个服务使用mysqld --remove，在--remove选项后指定服务名。如果服务名是 默认的(MySQL)，你可以不指定。
5.12.2. 在Unix中运行多个服务器
在Unix中运行多个服务器最容易的方法是使用不同的TCP/IP端口s和Unix套接字文件编译，因此每个实例在不同的网络接口侦听。另外，每个安装应在不同的基础目录中编译，那将自动为你的每个服务器产生使用不同的编译进来的数据目录、日志文件和PID文件位置。
假设一个现有的4.1.8版本服务器配置为默认TCP/IP端口号(3306)和Unix套接字文件(/tmp/mysql.sock)。要想配置一个新的5.1.2-alpha版的服务器来使用不同的操作参数，使用一个configure命令，大概象这样使用：
shell> ./configure --with-tcp-port=port_number \
             --with-unix-socket-path=file_name \
             --prefix=/usr/local/mysql-5.1.2-alpha
这里，port_number和file_name必须不同于默认TCP/IP端口号和Unix套接字文件路径名，并且--prefix值应指定一个不同于现有MySQL安装目录的安装目录。
如果你有一个MySQL服务器正侦听一个给定的端口号，你可以使用下面的命令来找出针对一些重要配置变量它使用了那些操作参数，包括基础目录和Unix套接字文件名：
shell> mysqladmin --host=host_name --port=port_number variables
通过该命令显示的信息，当配置其它服务器时，你可以告诉服务器该选项没有使用的值。
请注意，如果你指定localhost作为一个主机名，mysqladmin默认使用Unix套接字文件连接，而不是TCP/IP。从 MySQL 4.1开始，通过--protocol= TCP | SOCKET | PIPE | MEMORY}选项，你可以显示地指定连接协议。
如果只是用一个不同的Unix套接字文件和TCP/IP端口号启动，不必编译新的MySQL服务器。还可以在运行时指定这些值。这样做的一个方法是使用命令行选项：
shell> mysqld_safe --socket=file_name --port=port_number
要启动第二个服务器，提供不同的--socket和--port选项值，并且传递一个--datadir=path选项给mysqld_safe，以便服务器使用一个不同的数据目录。
达到相似效果的另一个方法是使用环境变量来设置 Unix套接字文件名和TCP/IP端口号：
shell> MYSQL_UNIX_PORT=/tmp/mysqld-new.sock
shell> MYSQL_TCP_PORT=3307
shell> export MYSQL_UNIX_PORT MYSQL_TCP_PORT
shell> mysql_install_db --user=mysql
shell> mysqld_safe --datadir=/path/to/datadir &
这是一个快速启动第二个服务器以用于测试的方法。该方法的最大好处是环境变量设定值适用于你从相同的shell调用的任何客户端程序。因而，那些客户端连接自动指向第二个服务器！
附录F：环境变量包括你可以使用的影响mysqld的其它环境变量列表。
对于自动服务器启动，对于每个服务器，机器引导时执行的启动脚本应执行下面的命令，每个命令用一个相应的选项文件路径：
mysqld_safe --defaults-file=path
每个选项文件应包含一个给定服务器特定的选项值。
在Unix中，mysqld_multi脚本是启动多个服务器的另一个方法。参见5.1.5节，“mysqld_multi：管理多个MySQL服务器的程序”。
5.12.3. 在多服务器环境中使用客户端程序
当你想要用一个客户端程序连接一个MySQL服务器时，该服务器侦听不同的网络接口，而不是编译到你的客户端的网络接口，你可以使用下面的方法：
·         启动客户端，用--host=host_name --port=port_number通过TCP/IP来连接一个远程服务器，用--host=127.0.0.1 --port=port_number通过TCP/IP来连接一个本地服务器，或者用--host=localhost --socket=file_name通过一个Unix套接字文件或一个Windows命名管道来连接一个本地服务器。
·         从MySQL 4.1起，启动客户端时用--protocol=tcp通过TCP/IP来连接，用--protocol=socket通过一个Unix套接字文件来连接，用--protocol=pipe通过一个命名管道来连接，或用--protocol=memory通过共享内存来连接。对于TCP/IP连接，你可能还需要指定--host和--port选项。对于其它类型的连接，你可能需要指定一个--socket选项来指定一个Unix套接字文件或命名管道名，或者一个--shared-memory-base-name选项来指定共享内存名。共享内存连接仅在Windows中支持。
·         在Unix中，在你启动客户端之前，设置MYSQL_UNIX_PORT和MYSQL_TCP_PORT环境变量来指定Unix套接字文件和TCP/IP端口号。如果你经常使用具体的套接字文件或端口号，你可以在.login文件中放置命令来设置环境变量以便你每次登录时该命令起作用。参见附录F：环境变量。
·         在一个选项文件的[client]组中指定默认Unix套接字文件和TCP/IP端口号。例如，你可以在Windows中使用C:\my.cnf文件，或在Unix中主目录内使用.my.cnf文件。参见4.3.2节，“使用选项文件”。
·         在C程序中，在mysql_real_connect()调用时，你可以指定套接字文件或端口号参数。通过调用mysql_options()，你还可以有程序读选项文件。参见25.2.3节，“C API函数描述”。
·         如果你正在使用Perl DBD::mysql模块，你可以从MySQL选项文件中读取选项。例如：
·                $dsn = "DBI:mysql:test;mysql_read_default_group=client;"
·                        . "mysql_read_default_file=/usr/local/mysql/data/my.cnf";
·                    $dbh = DBI->connect($dsn, $user, $password);
参见25.4节，“MySQL Perl API”。
其它程序接口可以为读选项文件提供相似的功能。
5.13. MySQL查询高速缓冲
5.13.1. 查询高速缓冲如何工作 
5.13.2. 查询高速缓冲SELECT选项 
5.13.3. 查询高速缓冲配置 
5.13.4. 查询高速缓冲状态和维护
查询缓存存储SELECT查询的文本以及发送给客户端的相应结果。如果随后收到一个相同的查询，服务器从查询缓存中重新得到查询结果，而不再需要解析和执行查询。
如果你有一个不经常改变的表并且服务器收到该表的大量相同查询，查询缓存在这样的应用环境中十分有用。对于许多Web服务器来说存在这种典型情况，它根据数据库内容生成大量的动态页面。
注释：查询缓存不返回旧的数据。当表更改后，查询缓存值的相关条目被清空。
注释：如果你有许多mysqld服务器更新相同的MyISAM表，在这种情况下查询缓存不起作用。
注释：查询缓存不适用于服务器方编写的语句。如果正在使用服务器方编写的语句，要考虑到这些语句将不会应用查询缓存。参见 25.2.4节，“C API预处理语句”。
下面是查询缓存的一些性能数据。这些结果是在Linux Alpha 2 x 500MHz系统（2GB RAM，64MB查询缓存）上运行MySQL基准组件产生的。
·         如果执行的所有查询是简单的(如从只有一行数据的表中选取一行)，但查询是不同的，查询不能被缓存，查询缓存激活率是13%。这可以看作是最坏的情形。在实际应用中，查询要复杂得多，因此，查询缓存使用率一般会很低。
·         从只有一行的表中查找一行数据时，使用查询缓存比不使用速度快238%。这可以看作查询使用缓存时速度提高最小的情况。
服务器启动时要禁用查询缓存，设置query_cache_size系统变量为0。禁用查询缓存代码后，没有明显的速度提高。编译MySQL时，通过在configure中使用--without-query-cache选项，可以从服务器中彻底去除查询缓存能力。
5.13.1. 查询高速缓冲如何工作
本节描述查询缓存的工作原理。5.13.3节，“查询高速缓冲配置”描述了怎样控制是否使用查询缓存。
查询解析之前进行比较，因此下面的两个查询被查询缓存认为是不相同的：
SELECT * FROM tbl_name
Select * from tbl_name
查询必须是完全相同的(逐字节相同)才能够被认为是相同的。另外，同样的查询字符串由于其它原因可能认为是不同的。使用不同的数据库、不同的协议版本或者不同 默认字符集的查询被认为是不同的查询并且分别进行缓存。
从查询缓存中提取一个查询之前，MySQL检查用户对所有相关数据库和表的SELECT权限。如果没有权限，不使用缓存结果。
如果从查询缓存中返回一个查询结果，服务器把Qcache_hits状态变量的值加一，而不是Com_select变量。参见5.13.4节，“查询高速缓冲状态和维护”。
如果一个表被更改了，那么使用那个表的所有缓冲查询将不再有效，并且从缓冲区中移出。这包括那些映射到改变了的表的使用MERGE表的查询。一个表可以被许多类型的语句更改，例如INSERT、UPDATE、DELETE、TRUNCATE、ALTER TABLE、DROP TABLE或DROP DATABASE。
COMMIT执行完后，被更改的事务InnoDB表不再有效。
使用InnoDB表时，查询缓存也在事务中工作，使用该表的版本号来检测其内容是否仍旧是当前的。
在MySQL 5.1中，视图产生的查询被缓存。
SELECT SQL_CALC_FOUND_ROWS ...和SELECT FOUND_ROWS() type类型的查询使用查询缓存。即使因创建的行数也被保存在缓冲区内，前面的查询从缓存中提取，FOUND_ROWS()也返回正确的值。
如果一个查询包含下面函数中的任何一个，它不会被缓存：
BENCHMARK()
CONNECTION_ID()
CURDATE()
CURRENT_DATE()
CURRENT_TIME()
CURRENT_TIMESTAMP()
CURTIME()
DATABASE()
带一个参数的ENCRYPT()
FOUND_ROWS()
GET_LOCK()
LAST_INSERT_ID()
LOAD_FILE()
MASTER_POS_WAIT()
NOW()
RAND()
RELEASE_LOCK()
SYSDATE()
不带参数的UNIX_TIMESTAMP()
USER()
 
在下面的这些条件下，查询也不会被缓存：
·         引用自定义函数(UDFs)。
·         引用自定义变量。
·         引用mysql系统数据库中的表。
·         下面方式中的任何一种：
SELECT ...IN SHARE MODE
SELECT ...FOR UPDATE
SELECT ...INTO OUTFILE ...
SELECT ...INTO DUMPFILE ...
SELECT * FROM ...WHERE autoincrement_col IS NULL
最后一种方式不能被缓存是因为它被用作为ODBC工作区来获取最近插入的ID值。参见26.1.14.1节，“如何在ODBC中获取AUTO_INCREMENT列的值”。
·          被作为编写好的语句，即使没有使用占位符。例如，下面使用的查询：
char *my_sql_stmt = "SELECT a，b FROM table_c";
   /* ...*/
mysql_stmt_prepare(stmt，my_sql_stmt，strlen(my_sql_stmt));
不被缓存。参见25.2.4节，“C API预处理语句”。
·         使用TEMPORARY表。
·         不使用任何表。
·         用户有某个表的列级权限。
5.13.2. 查询高速缓冲SELECT选项
可以在SELECT语句中指定查询缓存相关选项： 
·          SQL_CACHE
如果query_cache_type系统变量的值是ON或DEMAND，查询结果被缓存。
·          SQL_NO_CACHE
查询结果不被缓存。
示例：
SELECT SQL_CACHE id, name FROM customer;
SELECT SQL_NO_CACHE id, name FROM customer;
5.13.3. 查询高速缓冲配置
通过have_query_cache服务器系统变量指示查询缓存是否可用：
mysql> SHOW VARIABLES LIKE 'have_query_cache';
+------------------+-------+
| Variable_name    | Value |
+------------------+-------+
| have_query_cache | YES   |
+------------------+-------+
即使禁用查询缓存，当使用标准 MySQL二进制时，这个值总是YES。
其它几个系统变量控制查询缓存操作。当启动mysqld时，这些变量可以在选项文件或者命令行中设置。所有查询缓存系统变量名以query_cache_ 开头。它们的详细描述见5.3.3节，“服务器系统变量”，还给出了额外的配置信息。
为了设置查询缓存大小，设置query_cache_size系统变量。设置为0表示禁用查询缓存。 默认缓存大小设置为0；也就是禁用查询缓存。
当设置query_cache_size变量为非零值时，应记住查询缓存至少大约需要40KB来分配其数据结构。(具体大小取决于系统结构）。如果你把该值设置的太小，将会得到一个警告，如本例所示：
mysql> SET GLOBAL query_cache_size = 40000;
Query OK, 0 rows affected, 1 warning (0.00 sec)
 
mysql> SHOW WARNINGS\G
*************************** 1. row ***************************
  Level: Warning
   Code: 1282
Message: Query cache failed to set size 39936; new query cache size is 0
 
mysql> SET GLOBAL query_cache_size = 41984;
Query OK, 0 rows affected (0.00 sec)
 
mysql> SHOW VARIABLES LIKE 'query_cache_size';
+------------------+-------+
| Variable_name    | Value |
+------------------+-------+
| query_cache_size | 41984 |
+------------------+-------+
如果查询缓存大小设置为大于0，query_cache_type变量影响其工作方式。这个变量可以设置为下面的值：
·         0或OFF将阻止缓存或查询缓存结果。
·         1或ON将允许缓存，以SELECT SQL_NO_CACHE开始的查询语句除外。
·         2或DEMAND，仅对以SELECT SQL_CACHE开始的那些查询语句启用缓存。
设置query_cache_type变量的GLOBAL值将决定更改后所有连接客户端的缓存行为。具体客户端可以通过设置query_cache_type变量的会话值控制它们本身连接的缓存行为。例如，一个客户可以禁用自己的查询缓存，方法如下：
mysql> SET SESSION query_cache_type = OFF;
要控制可以被缓存的具体查询结果的最大值，应设置query_cache_limit变量。 默认值是1MB。
当一个查询结果（返回给客户端的数据）从查询缓冲中提取期间，它在查询缓存中排序。因此，数据通常不在大的数据块中处理。查询缓存根据数据排序要求分配数据块，因此，当一个数据块用完后分配一个新的数据块。因为内存分配操作是昂贵的(费时的)，所以通过query_cache_min_res_unit系统变量给查询缓存分配最小值。当查询执行时，最新的结果数据块根据实际数据大小来确定，因此可以释放不使用的内存。根据你的服务器执行查询的类型，你会发现调整query_cache_min_res_unit变量的值是有用的：
·         query_cache_min_res_unit默认值是4KB。这应该适合大部分情况。
·         如果你有大量返回小结果数据的查询，默认数据块大小可能会导致内存碎片，显示为大量空闲内存块。由于缺少内存，内存碎片会强制查询缓存从缓存内存中修整（删除）查询。这时，你应该减少query_cache_min_res_unit变量的值。空闲块和由于修整而移出的查询的数量通过Qcache_free_blocks和Qcache_lowmem_prunes变量的值给出。
·          如果大量查询返回大结果（检查 Qcache_total_blocks和Qcache_queries_in_cache状态变量），你可以通过增加query_cache_min_res_unit变量的值来提高性能。但是，注意不要使它变得太大（参见前面的条目）。
5.13.4. 查询高速缓冲状态和维护
可以使用下面的语句检查MySQL服务器是否提供查询缓存功能：
mysql> SHOW VARIABLES LIKE 'have_query_cache';
+------------------+-------+
| Variable_name    | Value |
+------------------+-------+
| have_query_cache | YES   |
+------------------+-------+
可以使用FLUSH QUERY CACHE语句来清理查询缓存碎片以提高内存使用性能。该语句不从缓存中移出任何查询。
RESET QUERY CACHE语句从查询缓存中移出所有查询。FLUSH TABLES语句也执行同样的工作。
为了监视查询缓存性能，使用SHOW STATUS查看缓存状态变量：
mysql> SHOW STATUS LIKE 'Qcache%';
+-------------------------+--------+
|变量名                   |值 |
+-------------------------+--------+
| Qcache_free_blocks      | 36     |
| Qcache_free_memory      | 138488 |
| Qcache_hits             | 79570  |
| Qcache_inserts          | 27087  |
| Qcache_lowmem_prunes    | 3114   |
| Qcache_not_cached       | 22989  |
| Qcache_queries_in_cache | 415    |
| Qcache_total_blocks     | 912    |
+-------------------------+--------+
这些变量的描述见5.3.4节，“服务器状态变量”。这里描述它们的一些应用。
SELECT查询的总数量等价于：
Com_select
+ Qcache_hits
+ queries with errors found by parser
Com_select的值等价于：
Qcache_inserts
+ Qcache_not_cached
+ queries with errors found during columns/rights check
查询缓存使用长度可变块，因此Qcache_total_blocks和Qcache_free_blocks可以显示查询缓存内存碎片。执行FLUSH QUERY CACHE后，只保留一个空闲块。
每个缓存查询至少需要两个块（一个块用于查询文本，一个或多个块用于查询结果）。并且，每一个查询使用的每个表需要一个块。但是，如果两个或多个查询使用相同的表，仅需要分配一个块。
Qcache_lowmem_prunes状态变量提供的信息能够帮助你你调整查询缓存的大小。它计算为了缓存新的查询而从查询缓冲区中移出到自由内存中的查询的数目。查询缓冲区使用最近最少使用(LRU)策略来确定哪些查询从缓冲区中移出。调整信息在5.13.3节，“查询高速缓冲配置”中给出。


第6章：MySQL中的复制
目录
6.1. 复制介绍 
6.2. 复制实施概述 
6.3. 复制实施细节 
6.3.1. 复制主线程状态 
6.3.2. 复制从I/O线程状态 
6.3.3. 复制从SQL线程状态 
6.3.4. 复制传递和状态文件
6.4. 如何设置复制 
6.5. 不同MySQL版本之间的复制兼容性 
6.6. 升级复制设置 
6.6.1. 将复制升级到5.0版
6.7. 复制特性和已知问题 
6.8. 复制启动选项 
6.9. 复制FAQ 
6.10. 复制故障诊断与排除 
6.11. 通报复制缺陷 
6.12. 多服务器复制中的Auto-Increment
本章描述了MySQL提供的各种复制特性。引入了复制概念，显示如何设置复制服务器和服务以指导相应的复制选项。还提供了FAQ(以及答案) 列表，以及解决复制问题的排错建议。
关于复制相关的SQL语句的语法描述，参见13.6节，“复制语句”。
我们建议你经常访问我们的网址http://www.mysql.com，并检查对本章的修改。复制在不断地得到改进，我们用最新的信息定期更新本手册。
6.1. 复制介绍
MySQL支持单向、异步复制，复制过程中一个服务器充当主服务器，而一个或多个其它服务器充当从服务器。(这与同步复制可以进行对比，同步复制是MySQL簇的一个特征—参见第17章：MySQL簇）。主服务器将更新写入二进制日志文件，并维护文件的一个索引以跟踪日志循环。这些日志可以记录发送到从服务器的更新。当一个从服务器连接主服务器时，它通知主服务器从服务器在日志中读取的最后一次成功更新的位置。从服务器接收从那时起发生的任何更新，然后封锁并等待主服务器通知新的更新。
如果你想要设置链式复制服务器，从服务器本身也可以充当主服务器。
请注意当你进行复制时，所有对复制中的表的更新必须在主服务器上进行。否则，你必须要小心，以避免用户对主服务器上的表进行的更新与对从服务器上的表所进行的更新之间的冲突。
单向复制有利于健壮性、速度和系统管理：
·         主服务器/从服务器设置增加了健壮性。主服务器出现问题时，你可以切换到从服务器作为备份。
·         通过在主服务器和从服务器之间切分处理客户查询的负荷，可以得到更好的客户响应时间。SELECT查询可以发送到从服务器以降低主服务器的查询处理负荷。但修改数据的语句仍然应发送到主服务器，以便主服务器和从服务器保持同步。如果非更新查询为主，该负载均衡策略很有效，但一般是更新查询。
·         使用复制的另一个好处是可以使用一个从服务器执行备份，而不会干扰主服务器。在备份过程中主服务器可以继续处理更新。参见5.9.1节，“数据库备份”。
6.2. 复制实施概述
MySQL复制基于主服务器在二进制日志中跟踪所有对数据库的更改(更新、删除等等)。因此，要进行复制，必须在主服务器上启用二进制日志。参见5.11.3节，“二进制日志”。
每个从服务器从主服务器接收主服务器已经记录到其二进制日志的保存的更新，以便从服务器可以对其数据拷贝执行相同的更新。
认识到二进制日志只是一个从启用二进制日志的固定时间点开始的记录非常重要。任何设置的从服务器需要主服务器上的在主服务器上启用二进制日志时的数据库拷贝。如果启动从服务器时，其数据库与主服务器上的启动二进制日志时的状态不相同，从服务器很可能失败。
将主服务器的数据拷贝到从服务器的一个途径是使用LOAD DATA FROM MASTER语句。请注意LOAD DATA FROM MASTER目前只在所有表使用MyISAM存储引擎的主服务器上工作。并且，该语句将获得全局读锁定，因此当表正复制到从服务器上时，不可能在主服务器上进行更新。当我们执行表的无锁热备份时，则不再需要全局读锁定。
由于这些限制，我们建议只有主服务器上的数据集相对较小，或者主服务器上延迟读锁定已经被接受，才可以使用LOAD DATA FROM MASTER。而LOAD DATA FROM MASTER的实际速度随系统的不同而不同，对于执行时间，最好的规则是每1MB的数据用1秒钟。这是一个粗略的估计，但你会发现如果主服务器和从服务器的性能上等价于700MHz Pentium CPU，通过100Mbps的网络进行连接，则该估计相当准确。
从服务器设置为复制主服务器的数据后，它连接主服务器并等待更新过程。如果主服务器失败，或者从服务器失去与主服务器之间的连接，从服务器保持定期尝试连接，直到它能够继续帧听更新。由--master-connect-retry选项控制重试间隔。 默认为60秒。
每个从服务器跟踪复制时间。主服务器不知道有多少个从服务器或在某一时刻有哪些被更新了。
6.3. 复制实施细节
6.3.1. 复制主线程状态 
6.3.2. 复制从I/O线程状态 
6.3.3. 复制从SQL线程状态 
6.3.4. 复制传递和状态文件
MySQL使用3个线程来执行复制功能(其中1个在主服务器上，另两个在从服务器上。当发出START SLAVE时，从服务器创建一个I/O线程，以连接主服务器并让它发送记录在其二进制日志中的语句。主服务器创建一个线程将二进制日志中的内容发送到从服务器。该线程可以识别为主服务器上SHOW PROCESSLIST的输出中的Binlog Dump线程。从服务器I/O线程读取主服务器Binlog Dump线程发送的内容并将该数据拷贝到从服务器数据目录中的本地文件中，即中继日志。第3个线程是SQL线程，是从服务器创建用于读取中继日志并执行日志中包含的更新。
在前面的描述中，每个从服务器有3个线程。有多个从服务器的主服务器创建为每个当前连接的从服务器创建一个线程；每个从服务器有自己的I/O和SQL线程。
这样读取和执行语句被分成两个独立的任务。如果语句执行较慢则语句读取任务没有慢下来。例如，如果从服务器有一段时间没有运行了，当从服务器启动时，其I/O线程可以很快地从主服务器索取所有二进制日志内容，即使SQL线程远远滞后。如果从服务器在SQL线程执行完所有索取的语句前停止，I/O 线程至少已经索取了所有内容，以便语句的安全拷贝保存到本地从服务器的中继日志中，供从服务器下次启动时执行。这样允许清空主服务器上的二进制日志，因为不再需要等候从服务器来索取其内容。
SHOW PROCESSLIST语句可以提供在主服务器上和从服务器上发生的关于复制的信息。
下面的例子说明了这3个线程在SHOW PROCESSLIST中的显示。
在主服务器上，SHOW PROCESSLIST的输出看上去应为：
mysql> SHOW PROCESSLIST\G
*************************** 1. row ***************************
     Id: 2
   User: root
   Host: localhost:32931
     db: NULL
Command: Binlog Dump
   Time: 94
  State: Has sent all binlog to slave; waiting for binlog to
         be updated
   Info: NULL
这儿，线程2是一个连接从服务器的复制线程。该信息表示所有主要更新已经被发送到从服务器，主服务器正等待更多的更新出现。
在从服务器上，SHOW PROCESSLIST的输出看上去应为：
mysql> SHOW PROCESSLIST\G
*************************** 1. row ***************************
     Id: 10
   User: system user
   Host:
     db: NULL
Command: Connect
   Time: 11
  State: Waiting for master to send event
   Info: NULL
*************************** 2. row ***************************
     Id: 11
   User: system user
   Host:
     db: NULL
Command: Connect
   Time: 11
  State: Has read all relay log; waiting for the slave I/O
         thread to update it
   Info: NULL
该信息表示线程10是同主服务器通信的I/O线程，线程11是处理保存在中继日志中的更新的SQL线程。SHOW PROCESSLIST运行时，两个线程均空闲，等待其它更新。
请注意Time列的值可以显示从服务器比主服务器滞后多长时间。参见6.9节，“复制FAQ”。
6.3.1. 复制主线程状态
下面列出了主服务器的Binlog Dump线程的State列的最常见的状态。如果你没有在主服务器上看见任何Binlog Dump线程，这说明复制没有在运行—即，目前没有连接任何从服务器。 
·         Sending binlog event to slave
二进制日志由各种事件组成，一个事件通常为一个更新加一些其它信息。线程已经从二进制日志读取了一个事件并且正将它发送到从服务器。
·         Finished reading one binlog; switching to next binlog
线程已经读完二进制日志文件并且正打开下一个要发送到从服务器的日志文件。
·         Has sent all binlog to slave; waiting for binlog to be updated
线程已经从二进制日志读取所有主要的更新并已经发送到了从服务器。线程现在正空闲，等待由主服务器上新的更新导致的出现在二进制日志中的新事件。
·         Waiting to finalize termination
线程停止时发生的一个很简单的状态。
6.3.2. 复制从I/O线程状态
下面列出了从服务器的I/O线程的State列的最常见的状态。该状态也出现在Slave_IO_State列，由SHOW SLAVE STATUS显示。这说明你可以只通过该语句仔细浏览所发生的事情。 
·         Connecting to master
线程正试图连接主服务器。
·         Checking master version
建立同主服务器之间的连接后立即临时出现的状态。
·         Registering slave on master
建立同主服务器之间的连接后立即临时出现的状态。
·         Requesting binlog dump
建立同主服务器之间的连接后立即临时出现的状态。线程向主服务器发送一条请求，索取从请求的二进制日志文件名和位置开始的二进制日志的内容。
·         Waiting to reconnect after a failed binlog dump request
如果二进制日志转储请求失败(由于没有连接)，线程进入睡眠状态，然后定期尝试重新连接。可以使用--master-connect-retry选项指定重试之间的间隔。
·         Reconnecting after a failed binlog dump request
线程正尝试重新连接主服务器。
·         Waiting for master to send event
线程已经连接上主服务器，正等待二进制日志事件到达。如果主服务器正空闲，会持续较长的时间。如果等待持续slave_read_timeout秒，则发生超时。此时，线程认为连接被中断并企图重新连接。
·         Queueing master event to the relay log
线程已经读取一个事件，正将它复制到中继日志供SQL线程来处理。
·         Waiting to reconnect after a failed master event read
读取时(由于没有连接)出现错误。线程企图重新连接前将睡眠master-connect-retry秒。
·         Reconnecting after a failed master event read
线程正尝试重新连接主服务器。当连接重新建立后，状态变为Waiting for master to send event。
·         Waiting for the slave SQL thread to free enough relay log space
正使用一个非零relay_log_space_limit值，中继日志已经增长到其组合大小超过该值。I/O线程正等待直到SQL线程处理中继日志内容并删除部分中继日志文件来释放足够的空间。
·         Waiting for slave mutex on exit
线程停止时发生的一个很简单的状态。
6.3.3. 复制从SQL线程状态
下面列出了从服务器的SQL线程的State列的最常见的状态。 
·         Reading event from the relay log
线程已经从中继日志读取一个事件，可以对事件进行处理了。
·         Has read all relay log; waiting for the slave I/O thread to update it
线程已经处理了中继日志文件中的所有事件，现在正等待I/O线程将新事件写入中继日志。
·         Waiting for slave mutex on exit
线程停止时发生的一个很简单的状态。
I/O线程的State列也可以显示语句的文本。这说明线程已经从中继日志读取了一个事件，从中提取了语句，并且正在执行语句。
6.3.4. 复制传递和状态文件
默认情况，中继日志使用host_name-relay-bin.nnnnnn形式的文件名，其中host_name是从服务器主机名，nnnnnn是序列号。用连续序列号来创建连续中继日志文件，从000001开始。从服务器跟踪索引文件中目前正使用的中继日志。 默认中继日志索引文件名为host_name-relay-bin.index。默认情况，在从服务器的数据目录中创建这些文件。可以用--relay-log和--relay-log-index服务器选项覆盖 默认文件名。参见6.8节，“复制启动选项”。
中继日志与二进制日志的格式相同，并且可以用mysqlbinlog读取。SQL线程执行完中继日志中的所有事件并且不再需要之后，立即自动删除它。没有直接的删除中继日志的机制，因为SQL线程可以负责完成。然而，FLUSH LOGS可以循环中继日志，当SQL线程删除日志时会有影响。
在下面的条件下创建新的中继日志：
·         每次I/O线程启动时创建一个新的中继日志。
·         当日志被刷新时；例如，用FLUSH LOGS或mysqladmin flush-logs。
·         当当前的中继日志文件变得太大时。“太大”含义的确定方法：
o        max_relay_log_size，如果max_relay_log_size > 0
o        max_binlog_size，如果max_relay_log_size = 0
从属复制服务器在数据目录中另外创建两个小文件。这些状态文件默认名为主master.info和relay-log.info。它们包含SHOW SLAVE STATUS语句的输出所显示的信息(关于该语句的描述参见13.6.2节，“用于控制从服务器的SQL语句”)。状态文件保存在硬盘上，从服务器关闭时不会丢失。下次从服务器启动时，读取这些文件以确定它已经从主服务器读取了多少二进制日志，以及处理自己的中继日志的程度。
由I/O线程更新master.info文件。文件中的行和SHOW SLAVE STATUS显示的列的对应关系为：
行
描述
1
文件中的行号
2
Master_Log_File
3
Read_Master_Log_Pos
4
Master_Host
5
Master_User
6
密码(不由SHOW SLAVE STATUS显示)
7
Master_Port
8
Connect_Retry
9
Master_SSL_Allowed
10
Master_SSL_CA_File
11
Master_SSL_CA_Path
12
Master_SSL_Cert
13
Master_SSL_Cipher
14
Master_SSL_Key
由SQL线程更新relay-log.info文件。文件中的行和SHOW SLAVE STATUS显示的列的对应关系为：
行
描述
1
Relay_Log_File
2
Relay_Log_Pos
3
Relay_Master_Log_File
4
Exec_Master_Log_Pos
当备份从服务器的数据时，你还应备份这两个小文件以及中继日志文件。它们用来在恢复从服务器的数据后继续进行复制。如果丢失了中继日志但仍然有relay-log.info文件，你可以通过检查该文件来确定SQL线程已经执行的主服务器中二进制日志的程度。然后可以用Master_Log_File和Master_LOG_POS选项执行CHANGE MASTER TO来告诉从服务器重新从该点读取二进制日志。当然，要求二进制日志仍然在主服务器上。
如果从服务器正复制LOAD DATA INFILE语句，你应也备份该目录内从服务器用于该目的的任何SQL_LOAD-*文件。从服务器需要这些文件继续复制任何中断的LOAD DATA INFILE操作。用--slave-load-tmpdir选项来指定目录的位置。如果未指定， 默认值为tmpdir变量的值。
6.4. 如何设置复制
这里简单描述了如何为你当前的MySQL服务器设置完整的复制。假设你想要复制主服务器上的所有数据库，并且还没有配置的复制。你需要关闭主服务器来完成下面所列的步骤。
下面的程序针对设置一个从服务器，你可以用来设置多个从服务器。
虽然该方法是设置从服务器的最直接的途径，它并不是唯一的一个。例如，如果你有一个主服务器的数据快照，并且主服务器已经设置了服务器ID，启用了二进制日志，不需要关闭主服务器或停止对它的更新也可以设置从服务器。详情请参见6.9节，“复制FAQ”。
如果想要管理MySQL复制设置，我们建议你通读本章，并尝试13.6.1节，“用于控制主服务器的SQL语句”和13.6.2节，“用于控制从服务器的SQL语句”中的所有语句。还应熟悉6.8节，“复制启动选项”中描述的复制启动选项。
注释：该程序和后面章节所示的复制SQL语句需要SUPER权限。
1.    确保在服务器和从服务器上安装的MySQL版本与6.5节，“不同MySQL版本之间的复制兼容性”所示的表兼容。理想情况，应在主服务器和从服务器上使用最近版本的MySQL。
请先证实问题不是出现在最新的MySQL版本中再通报bug。
2.    在主服务器上为服务器设置一个连接账户。该账户必须授予REPLICATION SLAVE权限。如果账户仅用于复制(推荐这样做)，则不需要再授予任何其它权限。(关于设置用户 账户和权限的信息，参见5.8节，“MySQL用户账户管理”）。
假定你的域为mydomain.com,想要创建用户名为repl的一个账户，从服务器可以使用该账户从你的域内的任何主机使用密码slavepass来访问主服务器。要创建该 账户，可使用GRANT语句：
mysql> GRANT REPLICATION SLAVE ON *.*
    -> TO 'repl'@'%.mydomain.com' IDENTIFIED BY 'slavepass';
如果你计划从从属服务器主机使用LOAD TABLE FROM MASTER或LOAD DATA FROM MASTER语句，你需要授予该账户其它权限：
·         授予账户SUPER和RELOAD全局权限。
·         为所有想要装载的表授予SELECT权限。任何该 账户不能SELECT的主服务器上的表被LOAD DATA FROM MASTER忽略掉。
3.    执行FLUSH TABLES WITH READ LOCK语句清空所有表和块写入语句：
4.            mysql> FLUSH TABLES WITH READ LOCK；
对于InnoDB表，请注意：FLUSH TABLES WITH READ LOCK还锁定COMMIT操作。当获得全局读锁定后，可以开始InnoDB表的文件系统快照。快照不能保证内部(在InnoDB存储引擎内部)一致性(因为InnoDB缓存没有刷新)，但并不需要关心该问题，因为InnoDB可以在启动时解决该问题并给出一致的结果。这说明InnoDB在启动快照时可以进行崩溃恢复，而不会破坏。然而，当保证一致的InnoDB表快照时，还没有途径来停止MySQL服务器。
让客户程序保持运行，发出FLUSH TABLES语句让读锁定保持有效。(如果退出客户程序，锁被释放）。然后对主服务器上的数据进行快照。
创建快照最简单的途径是使用归档程序对主服务器上的数据目录中的数据库进行二进制备份。例如，在Unix中使用tar，或者在Windows中使用PowerArchiver、WinRAR、WinZip或者类似的软件。要使用tar来创建包括所有数据库的归档文件，进入主服务器的数据目录，然后执行命令：
shell> tar -cvf /tmp/mysql-snapshot.tar .
如果你想让归档只包括this_db数据库，应使用命令：
shell> tar -cvf /tmp/mysql-snapshot.tar ./this_db
然后将归档文件复制到从服务器主机的/tmp目录。在该机器上，进入从服务器的数据目录，并使用下述命令解压缩归档文件：
shell> tar -xvf /tmp/mysql-snapshot.tar
如果从服务器的用户账户与主服务器的不同，你可能不想复制mysql数据库。在这种情况下，应从归档中排除该数据库。你也不需要在归档中包括任何日志文件或者master.info或relay-log.info文件。
当FLUSH TABLES WITH READ LOCK所置读锁定有效时，读取主服务器上当前的二进制日志名和偏移量值：
mysql > SHOW MASTER STATUS;
+---------------+----------+--------------+------------------+
| File          | Position | Binlog_Do_DB | Binlog_Ignore_DB |
+---------------+----------+--------------+------------------+
| mysql-bin.003 | 73       | test         | manual,mysql     |
+---------------+----------+--------------+------------------+
File列显示日志名，而Position显示偏移量。在该例子中，二进制日志值为mysql-bin.003，偏移量为73。记录该值。以后设置从服务器时需要使用这些值。它们表示复制坐标，从服务器应从该点开始从主服务器上进行新的更新。
取得快照并记录日志名和偏移量后，可以在主服务器上重新启用写活动：
mysql> UNLOCK TABLES；
如果你正使用InnoDB表，理想情况应使用InnoDB Hot Backup工具，使用该工具可以获得一致的快照而不需要在主服务器上进行锁定，并且可以对应从服务器上使用的快照来记录日志名和偏移量。Hot Backup是一个附加的非免费(商业)工具，没有包含在标准 MySQL分发中。详细信息参见http://www.innodb.com/manual.php的InnoDB Hot Backup主页。
不使用Hot Backup工具，最快捷的途径是使用InnoDB表的二进制快照来关闭主服务器并复制InnoDB数据文件、日志文件和表定义文件(.frm文件)。要记录当前的日志文件名和偏移量，关闭服务器之前应发出下面的语句：
mysql> FLUSH TABLES WITH READ LOCK;
mysql> SHOW MASTER STATUS;
然后记录前面所示的SHOW MASTER STATUS的输出中显示的日志名和偏移量。记录日志名和偏移量后，不解锁表关闭服务器以确保  服务器关闭时的快照与当前的日志文件和偏移量相对应：
shell> mysqladmin -u root shutdown
适合MyISAM和InnoDB表的另一个方法是对主服务器上的SQL进行转储而不是对前面讨论的二进制复制进行转储。为了实现，可以在主服务器上使用mysqldump --master-data，以后将SQL转储文件装入从服务器。但是，这样比二进制复制要慢一些。
如果主服务器运行时没有启用--logs-bin，SHOW MASTER STATUS或mysqldump --master-data显示的日志名和位置值为空。在这种情况下，当以后指定从服务器的日志文件和位置时需要使用的值为空字符串('')和4.
5.    确保主服务器主机上my.cnf文件的[mysqld]部分包括一个log-bin选项。该部分还应有一个server-id=Master_id选项，其中master_id必须为1到232–1之间的一个正整数值。例如：
6.            [mysqld]
7.            log-bin=mysql-bin
8.            server-id=1
如果没有提供那些选项，应添加它们并重启服务器。
9.    停止用于从服务器的服务器并在其my.cnf文件中添加下面的行：
10.        [mysqld]
11.        server-id=slave_id
slave_id值同Master_id值一样，必须为1到232–1之间的一个正整数值。并且，从服务器的ID必须与主服务器的ID不相同。例如：
[mysqld]
server-id=2
如果设置多个从服务器，每个从服务器必须有一个唯一的server-id值，必须与主服务器的以及其它从服务器的不相同。可以认为server-id值类似于IP地址：这些ID值能唯一识别复制服务器群集中的每个服务器实例。
如果不指定一个server-id值，如果没有定义master-host，则将它设置为1；否则设置为2。请注意如果server-id太长，主服务器 拒绝所有来自从服务器的连接，并且从服务器拒绝连接到主服务器。这样，省略server-id只适合用二进制日志备份。
12.如果对主服务器的数据进行二进制备份，启动从服务器之前将它复制到从服务器的数据目录中。确保对这些文件和目录的权限正确。服务器 MySQL运行的用户必须能够读写文件，如同在主服务器上一样。
如果使用mysqldum备份，先启动从服务器(看下一步)。
13.启动从服务器。如果前面已经复制了，用--skip-slave-start选项启动从服务器，以便它不立即尝试连接主服务器。你也可能想要用--logs-warnings选项启动从服务器(默认设置启用)，以便在错误日志中显示更多的问题相关的信息(例如，网络或连接问题)。放弃的连接将记入错误日志，除非其值大于1。
14.如果使用mysqldump备份主服务器的数据，将转储文件装载到从服务器：
15.        shell> mysql -u root -p < dump_file.sql
16.        在从服务器上执行下面的语句，用你的系统的实际值替换选项值：
17.        mysql> CHANGE MASTER TO
18.            ->     MASTER_HOST='master_host_name',
19.            ->     MASTER_USER='replication_user_name',
20.            ->     MASTER_PASSWORD='replication_password',
21.            ->     MASTER_LOG_FILE='recorded_log_file_name',
22.            ->     MASTER_LOG_POS=recorded_log_position;
下面的表显示了字符串选项的最大长度：
Master_Host
60
Master_USER
16
Master_PASSWORD
32
Master_Log_File
255
23.启动从服务器线程：
24.        mysql> START SLAVE；
执行这些程序后，从服务器应连接主服务器，并补充自从快照以来发生的任何更新。
如果你忘记设置主服务器的server-id值，从服务器不能连接主服务器。
如果你忘记设置从服务器的server-id值，在从服务器的错误日志中会出现下面的错误：
Warning: You should set server-id to a non-0 value if master_host is set;
we will force server id to 2, but this MySQL server will not act as a slave.
如果由于其它原因不能复制，从服务器的错误日志中也会出现错误消息。
从服务器复制时，会在其数据目录中发现文件dmaster.info和relay-log.info。从服务器使用这两个文件跟踪已经处理了多少主服务器的二进制日志。不要移除或编辑这些文件，除非你确切知你正在做什么并完全理解其意义。即使这样，最好是使用CHANGE MASTER TO语句。
注释：master.info的内容会覆盖命令行或in my.cnf中指定的部分选项。详情参见6.8节，“复制启动选项”。
有了一个快照，你可以用它根据刚刚描述的从服务器部分来设置其它从服务器。你不需要主服务器的另一个快照；每个从服务器可以使用相同的快照。
注释：为了保证事务InnoDB复制设置的最大可能的耐受性和一致性，应在主服务器的my.cnf文件中使用innodb_flush_log_at_trx_commit=1和sync-binlog=1。
6.5. 不同MySQL版本之间的复制兼容性
MySQL 5.1中使用的二进制日志格式与以前的版本中所使用的大大不同，特别是在字符集处理、LOAD DATA INFILE以及时区方面。
注释：你不能从使用新二进制日志格式的主服务器向使用旧二进制日志格式的从服务器复制(例如，从MySQL 5.0到MySQL 4.1）。。这样操作在复制设置升级服务器时后果严重，参见6.6节，“升级复制设置”。
我们推荐使用最近的MySQL版本，因为复制功能在不断地改进中。我们还推荐主服务器和从服务器使用相同的版本。我们建议升级主服务器和从服务器，运行alpha或beta版本到新的(产品)版本。在许多情况下，从新的主服务器向旧的从服务器复制将会失败。一般原则，运行MySQL 5.1.x的从服务器可以与旧的主服务器(可以运行MySQL 3.23、4.0或者4.1)一起使用，但不能反过来。
前面的信息适合协议级复制兼容性。然而，还会有一个约束条件，例如SQL级兼容性问题。例如， 5.1版本的主服务器不能复制到5.0版本的从服务器，如果复制语句使用5.1版本的SQL特性而不是5.0版本。这些问题和其它问题均在6.7节，“复制特性和已知问题”中讨论。
6.6. 升级复制设置
6.6.1. 将复制升级到5.0版
当在复制设置中升级服务器时，升级过程取决于当前的服务器版本和要升级的服务器版本。 
6.6.1. 将复制升级到5.0版
该节适用于将复制从MySQL 3.23、4.0或者4.1升级到5.1。4.0服务器应为4.0.3或更新版。 
当将早期MySQL版本系列主服务器升级到5.1时，应先确保该主服务器的所有从服务器使用了相同的5.1.x版本。如果不是这样，你应先升级从服务器。升级从服务器时，应先关闭从服务器，升级到相应5.1.x版本，然后重启从服务器并重新开始复制。5.1版本的从服务器能够读取升级前写入的旧的中继日志并执行日志中包含的语句。升级后从服务器创建的中继日志为5.1格式。
从服务器升级后，关闭主服务器，将它升级到与从服务器相同的5.1.x版本并重启它。5.1主服务器能够读取升级前写入的旧的二进制日志并将它们发送到5.1从服务器。从服务器可以识别旧的格式并正确处理它。升级后主服务器创建的二进制日志采用5.1格式。这样也可以由5.1从服务器识别。
换句话说，当升级到5.1时没有什么措施，只有将主服务器升级到5.1之前先将从服务器升级到5.1。请注意从5.1降级到旧版本不会如此简单：必须确保已经完全处理所有5.1版本的二进制日志或中继日志，以便在降级前可以移除它们。
6.7. 复制特性和已知问题
一般原则，SQL级复制兼容性要求主服务器和从服务器均支持使用的特性。例如，在MySQL 5.0.0中开始使用TIMESTAMPADD()函数。如果在主服务器上使用该函数，不能复制到MySQL 5.0.0之前的从服务器。如果你计划在5.1和以前版本的MySQL之间进行复制，你应查阅对应以前版本系列的MySQL参考手册，查询该系列复制特征相关信息。
下面列出了关于支持什么和不支持什么的详细信息。关于复制的其它InnoDB具体信息参见15.2.6.5节，“InnoDB和MySQL复制”。
关于保存的程序和触发器的复制问题在20.4节，“存储子程序和触发程序的二进制日志功能”中讨论。
·         用AUTO_INCREMENT、LAST_INSERT_ID()和TIMESTAMP值正确实现复制。
·         USER()、UUID()和LOAD_FILE()函数毫无改变地被，这样不能可靠地在从服务器上工作。
·         下面的限制只适合基于语句的复制，而不是基于行的复制。处理用户级锁定的函数GET_LOCK()、RELEASE_LOCK()、IS_FREE_LOCK()、IS_USED_LOCK()复制时从服务器不知道在主服务器上同时进行的相关文本；因此如果从服务器上的内容不同，这些函数不用来插入到主服务器的表中(例如不执行INSERT INTO mytable VALUES(GET_LOCK(...)))。
·         在MySQL 5.1中FOREIGN_KEY_CHECKS、SQL_MODE、UNIQUE_CHECKS和SQL_AUTO_IS_NULL变量均复制。但TABLE_TYPE，即STORAGE_ENGINE变量 不复制，有利于在不同的存储引擎之间进行复制。
·         即使主服务器和从服务器有不同的全局字符集变量，以及即使有不同的全局时区变量仍可以复制。
·         下面适合使用不同字符集的MySQL服务器之间的复制：
1.    必须在主服务器和从服务器上总是使用相同的全局字符集和校对规则(--default-character-set、--default-collation)。否则，会在从服务器上遇到复制键值错误，因为在主服务器的字符集中被认为是唯一的键值在从服务器的字符集中可能不是唯一的。
2.    如果主服务器早于MySQL 4.1.3，则会话中的字符集不应与其全局值不同(换句话说，不要使用SET NAMES、SET CHARACTER SET等等)，因为从服务器不知道该字符集的更改。如果主服务器和从服务器均为4.1.3或更新版，可以随便将会话的字符集变量设置为本地值(例如NAMES、CHARACTER SET、COLLATION_CLIENT和COLLATION_SERVER)，因为这些设定值被写入二进制日志，因此从服务器知道。然而，禁止更改会话中这些变量的全局值；如前面所述，主服务器和从服务器必须具有唯一的全局字符集值。
3.    如果在主服务器上的数据库的字符集与全局collation_server值不同，则应设计CREATE TABLE语句，以便它们不隐含依赖数据库的默认字符集(Bug #2326)；一个好的解决办法是在CREATE TABLE中明显说明字符集和校对规则。
·         应在主服务器和从服务器上设置相同的系统时区。否则一些语句，例如使用NOW()或FROM_UNIXTIME()函数的语句，将不会正确复制。可以使用脚本mysqld_safe的--timezone=timezone_name选项或通过设置TZ环境变量设置MySQL服务器运行的系统的时区。主服务器和从服务器还应有相同的默认连接时区设置；即主服务器和从服务器应有相同的--default-time-zone参数值。
·         CONVERT_TZ(...,...,@global.time_zone)不能正确复制。只有主服务器和从服务器均为5.0.4或更新版才能正确复制CONVERT_TZ(...,...,@session.time_zone)。
·         会话变量只有在更新表的语句中使用时才能正确复制；例如：SET MAX_JOIN_SIZE=1000；INSERT INTO mytable VALUES(@MAX_JOIN_SIZE)不能将相同的数据插入到主服务器上和从服务器上。不适用于通用的SET TIME_ZONE=...；INSERT INTO mytable VALUES(CONVERT_TZ(...,...,@time_zone))。
·         可以将从服务器上的非事务表复为主服务器上的事务表。例如，可以将主服务器上的InnoDB表复制为从服务器上的MyISAM表。然而，复制过程中，如果从服务器在BEGIN/COMMIT块过程中停止则会产生问题，因为从服务器在BEGIN块开始时会重启。该问题出现在TODO中，不久将会得到修复。
·         在MySQL 5.1中可以正确复制引用用户变量(即@var_name形式的变量)的更新语句；但在4.1以前的版本中却不可能。请注意从MySQL 5.1开始对用户变量名的大小写不再敏感；当在5.1和旧版本之间设置复制时应考虑该问题。
·         从服务器可以使用SSL连接到主服务器。
·         有一个全局系统变量slave_transaction_retries：如果因为某个InnoDB死锁或超过 InnoDB的innodb_lock_wait_timeout或NDB簇的TransactionDeadlockDetectionTimeout或TransactionInactiveTimeout，REPLICATION SLAVESQL线程未能执行某个事务，在给出错误停止前自动重试slave_transaction_retries次。 默认值是10。从MySQL 5.0.4开始，可以从SHOW STATUS的输出中看到重试总次数；参见5.3.4节，“服务器状态变量”。
·         如果在主服务器上的CREATE TABLE语句中使用了DATA DIRECTORY或INDEX DIRECTORY子句，子句也可以在从服务器上使用。如果在从服务器主机文件系统中不存在一致的目录或虽然存在但不能被从服务器访问，则会带来问题。MySQL 5.1支持一个称为NO_DIR_IN_CREATE的sql_mode选项。如果从服务器运行时将SQL模式设置为包括该选项，复制CREATE TABLE语句时将忽略这些子句。结果是在表的数据库目录中创建了MyISAM数据和索引文件。
·         下面的限制只适合基于语句的复制，而不是基于行的复制：如果在查询中数据修改不确定，主服务器和从服务器上的数据可以不同；也就是由查询优化器确定。(这是常用的但不是很好的习惯，即使不是在复制中也不好）。关于该问题的详细解释，参见A.8.1节，“MySQL中的打开事宜”。
·         带READ LOCK的FLUSH LOGS、FLUSH MASTER、FLUSH SLAVE和FLUSH TABLES不记入日志，因为如果复制到从服务器会造成问题。关于语法示例，参见13.5.5.2节，“FLUSH语法”。FLUSH TABLES、ANALYZE TABLE、OPTIMIZE TABLE和REPAIR TABLE语句被写入二进制日志并会复制到从服务器。一般情况不会造成问题，因为这些语句不修改表的数据。但是在某些情况下会带来问题。如果你复制mysql数据库中的授权表并且不使用GRANT直接更新那些表，必须在从服务器上执行FLUSH PRIVILEGES使新的权限生效。并且，如果使用FLUSH TABLES重新命名MERGE表的MyISAM表，必须手动在从服务器上执行FLUSH TABLES。如果不指定NO_WRITE_TO_BINLOG或其别名LOCAL，则这些语句被写入二进制日志。
·         MySQL只支持一个主服务器和多个从服务器。我们计划将来添加一个投票算法，当前的主服务器出现问题时自动切换。我们还计划引入代理过程通过向不同的从服务器发送SELECT查询以帮助进行负载均衡。
·         当服务器关闭、重启时，其MEMORY表将变为空。主服务器按下述方法复制该结果：启动后第1次主服务器使用每个MEMORY表，它通知从服务器需要向表写入DELETE FROM语句来清空二进制日志的表。详细信息参见15.4节，“MEMORY (HEAP)存储引擎”。
·         除了关闭从服务器(而不仅仅是从服务器线程) 临时表都被复制，并且还没有在从服务器上执行的更新所使用的临时表也已经复制。如果关闭从服务器，从服务器重启后更新需要的那些临时表不可再用。为了避免该问题，临时表打开时不要关闭从服务器。而应遵照下面的程序：
1.    执行STOP SLAVE语句。
2.    使用SHOW STATUS检查slave_open_temp_tables变量的值。
3.    如果值为0，使用mysqladmin shutdown命令关闭从服务器。
4.    如果值不为0，用START SLAVE重启从服务器线程。
5.    后面再重复该程序看下次的运气是否好一些。
我们计划在不久的将来修复该问题。
·         可以很安全地连接用--logs-slave-updates选项指定的循环主服务器/从服务器关系中的服务器。但请注意许多语句在这种设置中不能正确工作，除非你的客户代码关注了潜在的在不同的服务器不同顺序的更新中可能发生的这类问题。
这说明你可以象这样创建设置：
A -> B -> C -> A
服务器ID被编码在二进制日志事件中，因此服务器A知道何时自己首次创建它读取的事件并且不执行事件(除非用--replicate-same-server-id选项启动了服务器A，只在很少情况下有意义)。这样，没有无限循环。只有对表执行没有冲突的更新时该类循环设置才能工作。换句话说，如果在A和C中插入数据，绝对不应在A中插入键值可能与插入到C中的行相冲突的一行。如果更新的顺序很重要，还不应更新两个服务器上相同的行。
·         如果从服务器上的某个语句产生错误，则从服务器上的SQL线程终止，并且从服务器向错误日志写入一条消息。此时应手动连接从服务器，修复该问题(例如，一个不存在的表)，然后运行START SLAVE。
·         可以很安全地关闭主服务器并在以后重启。如果某个从服务器丢失与主服务器的连接，从服务器尝试立即重新连接。如果失败，从服务器定期重试。(默认设置是每60秒重试一次。可以通过--master-connect-retry选项更改）。从服务器也能够处理网络连接中断。但是，只有从服务器超过slave_net_timeout秒没有从主服务器收到数据才通知网络中断。如果中断时间短，可以降低slave_net_timeout。参见5.3.3节，“服务器系统变量”。
·         关闭从服务器（净关闭）也很安全，因为它可以跟踪它离开的地点。不纯净的关闭操作会产生问题，特别是系统关闭前硬盘缓存未刷新到硬盘上时。如果有不间断电源，可以大大提高系统容错能力。不纯净的关闭主服务器会造成主服务器上的表和二进制日志内容之间的不一致性；在主服务器上使用InnoDB表和--innodb-safe-binlog选项可以避免该问题。参见5.11.3节，“二进制日志”。(注释：MySQL 5.1中不需要--innodb-safe-binlog，由于引入了XA事务支持已经作废了）。 
·         由于MyISAM表的非事务属性，可以有一个语句只是更新一个表并返回错误代码。例如，多行插入时有一个行超过键值约束，或者如果长的更新语句更新部分行后被杀掉了。如果发生在主服务器上，除非错误代码合法并且语句执行产生相同的错误代码，从服务器线程将退出并等待数据库管理员决定如何做。如果该错误代码验证行为不理想，可以用--slave-skip-errors选项掩盖(忽视)部分或全部错误。
·         如果从BEGIN/COMMIT系列的非事务表更新事务表，如果提交事务前更新非事务表，对二进制日志的更新可能会不同步。这是因为事务提交后才被写入二进制日志。
·         事务混合更新事务表和非事务表时，二进制日志中语句的顺序是正确的，即使在ROLLBACK时，所有需要的语句也会写入二进制日志。但是如果在第1个连接的事务完成前，第2个连接更新非事务表，语句记入日志时会出现顺序错误，因为第2个连接的更新执行完后立即写入日志，而不管第1个连接执行的事务的状态如何。
6.8. 复制启动选项
在主服务器和从服务器上，均必须使用server-id选项为每个服务器建立唯一的复制ID。你应为每个主服务器和从服务器从1到232–1的范围挑一个唯一的正整数。例如：server-id=3
用于主服务器上控制二进制日志的选项的相关描述见5.11.3节，“二进制日志”。
下表描述了可以用于MySQL 5.1从属复制服务器的选项。你可以在命令行中或在选项文件中指定这些选项。
某些从服务器复制选项按特殊方式处理，当从服务器启动时如果master.info文件存在并且包含选项值，它们将被忽略掉。下面的选项按这种方式处理：
·         --master-host
·         --master-user
·         --master-password
·         --master-port
·         --master-connect-retry
·         --master-ssl
·         --master-ssl-ca
·         --master-ssl-capath
·         --master-ssl-cert
·         --master-ssl-cipher
·         --master-ssl-key
5.1中的master.info文件格式包括对应SSL选项的值。并且，文件格式包括文件中的行号，如同第1行。如果你将旧的服务器升级到新的版本，新服务器启动时自动将smaster.info文件升级到新的格式。然而，如果将新服务器降级到旧的版本，首次启动旧版本的服务器之前应删除第1行。
如果从服务器启动时master.info文件不存在，选项采用选项文件或命令行中指定的值。首次将服务器作为从服务器启动时，或者已经运行RESET SLAVE然后已经关闭并重启从服务器时会发生。
如果从服务器启动时master.info文件存在，服务器忽略那些选项。使用master.info文件中发现的值。
如果你使用与master.info文件中相对应的启动选项的不同的值重启从服务器，启动选项的不同的值不会生效，因为服务器继续使用master.info文件。要想使用启动选项的不同的值，必须删除master.info文件并重启从服务器，或(最好是)在从服务器运行时使用CHANGE MASTER TO语句重新设置值。
假定在my.cnf文件中指定该选项：
[mysqld]
master-host=some_host
第1次作为复制从服务器启动服务器时，从my.cnf文件读取并使用选项。服务器然后记录master.info文件中的值。下次启动服务器时，它只从服务器的master.info文件读取主服务器主机值并忽略选项文件中的值。如果你修改my.cnf文件为some_other_host指定其它主服务器主机，更改仍然不会生效。你应使用CHANGE MASTER TO。
因为服务器给已有master.info文件的优先权高于刚刚描述的启动选项，可以选择不使用这些值的启动选项，而是使用CHANGE MASTER TO语句来指定。参见13.6.2.1节，“CHANGE MASTER TO语法”。
下面的例子显示了如何更广泛地使用启动选项来配置从服务器：
[mysqld]
server-id=2
master-host=db-master.mycompany.com
master-port=3306
master-user=pertinax
master-password=freitag
master-connect-retry=60
report-host=db-slave.mycompany.com
下面列出了控制复制的启动选项：许多选项可以在服务器运行时通过CHANGE MASTER TO语句重新进行设置。其它选项，例如--replicate-*选项，只能在从服务器启动时进行设置。我们计划将修复该问题。
·         --logs-slave-updates
通常情况，从服务器从主服务器接收到的更新不记入它的二进制日志。该选项告诉从服务器将其SQL线程执行的更新记入到从服务器自己的二进制日志。为了使该选项生效，还必须用--logs-bin选项启动从服务器以启用二进制日志。如果想要应用链式复制服务器，应使用--logs-slave-updates。例如，可能你想要这样设置：
A -> B -> C
也就是说，A为从服务器B的主服务器，B为从服务器C的主服务器。为了能工作，B必须既为主服务器又为从服务器。你必须用--logs-bin启动A和B以启用二进制日志，并且用--logs-slave-updates选项启动B。
·         --logs-warnings
让从服务器向错误日志输出更详细的关于其执行操作的消息。例如，通知你网络/连接失败后已经成功重新连接，并通知你每个从服务器线程如何启动。该选项默认启用；要想禁用它，使用--skip-logs-warnings。放弃的连接不记入错误日志，除非该值大于1。
请注意该选项的效果不限于复制。可以对服务器的部分动作产生警告。
·         --master-connect-retry=seconds
在主服务器宕机或连接丢失的情况下，从服务器线程重新尝试连接主服务器之前睡眠的秒数。如果主服务器.info文件中的值可以读取则优先使用。如果未设置， 默认值为60。
·         --master-host=host
主复制服务器的主机名或IP地址。如果没有给出该选项，从服务器线程不启动。如果主服务器.info文件中的值可以读取则优先使用。
·         --master-info-file=file_name
从服务器用于记录主服务器的相关信息使用的文件名。默认名为数据目录中的mysql.info。
·         --master-password=password
连接主服务器时从服务器线程用于鉴定的账户的密码。如果主服务器.info文件中的值可以读取则优先使用。如果未设置，假定 密码为空。
·         --master-port=port_number
主服务器正帧听的TCP/IP端口号。如果主服务器.info文件中的值可以读取则优先使用。如果未设置，假定使用编译进来的设定值。如果你未曾用configure选项进行修改，该值应为3306。
·         --master-ssl、--master-ssl-ca=file_name、--master-ssl-capath=directory_name、--master-ssl-cert=file_name、--master-ssl-cipher=cipher_list、--master-ssl-key=file_name
这些选项用于使用SSL设置与主服务器的安全复制连接。它们的含义与5.8.7.6节，“SSL命令行选项”中描述的相应—ssl、--ssl-ca、--ssl-capath、--ssl-cert、--ssl-cipher、--ssl-key选项相同。如果主服务器.info文件中的值可以读取则优先使用。
·         --master-user=username
连接主服务器时从服务器线程用于鉴定的账户的用户名。该账户必须具有REPLICATION SLAVE权限。如果主服务器.info文件中的值可以读取则优先使用。如果未设置主服务器用户，假定使用用户test。
·         --max-relay-logs-size=size
自动循环中继日志。参见5.3.3节，“服务器系统变量”。
·         --read-only
该选项让从服务器只允许来自从服务器线程或具有SUPER权限的用户的更新。可以确保从服务器不接受来自客户的更新。
·         --relay-log=file_name
中继日志名。默认名为host_name-relay-bin.nnnnnn，其中host_name是从服务器主机的名，nnnnnn表示中继日志在编号序列中创建。如果中继日志太大(并且你不想降低max_relay_log_size)，需要将它们放到数据目录之外的其它地方，或者如果想要通过硬盘之间的负载均衡提高速度，可以指定选项创建与主机名无关的中继日志名。
·         --relay-log-index=file_name
中继日志索引文件使用的位置和名称。默认名为host_name-relay-bin.index，其中host_name为从服务器名。
·         --relay-log-info-file=file_name
从服务器用于记录中继日志相关信息的文件名。默认名为数据目录中的relay-log.info。
·         --relay-log-purge={0|1}
禁用或启用不再需要中继日志时是否自动清空它们。默认值为1(启用)。这是一个全局变量，可以用SET GLOBAL Relay_log_purge动态更改。
·         --relay-log-space-limit=size
限制所有中继日志在从服务器上所占用空间的上限(0值表示“无限制”)。从服务器主机硬盘空间有限时很有用。达到限制后，I/O线程停止从主服务器读取二进制日志中的事件，直到SQL线程被闭锁并且删除了部分未使用的中继日志。请注意该限制并不是绝对的：有可能SQL线程删除中继日志前需要更多的事件。在这种情况下，I/O线程将超过限制，直到SQL线程可以删除部分中继日志。(不这样做将会造成死锁）。--relay-log-space-limit的值不能小于--max-relay-logs-size(或如果--max-relay-logs-size为0，选--max-binlog-size)的值的两倍。在这种情况下，有可能I/O线程等待释放空间，因为超过了--relay-log-space-limit，但SQL线程没有要清空的中继日志，不能满足I/O线程的需求。强制I/O线程临时忽视--relay-log-space-limit。
·         --replicate-do-db=db_name
告诉从服务器限制默认数据库(由USE所选择)为db_name的语句的复制。要指定多个数据库，应多次使用该选项，每个数据库使用一次。请注意不复制跨数据库的语句，例如当已经选择了其它数据库或没有数据库时执行UPDATE some_db.some_table SET foo='bar'。如果需要跨数据库进行更新，使用--replicate-wild-do-table=db_name.%。请读取该选项列表后面的注意事项。
一个不能按照期望工作的例子：如果用--replicate-do-db=sales启动从服务器，并且在主服务器上执行下面的语句，UPDATE语句不会复制：
USE prices;
UPDATE sales.january SET amount=amount+1000;
如果需要跨数据库进行更新，应使用--replicate-wild-do-table=db_name.%。
“只检查默认数据库”行为的主要原因是语句自己很难知道它是否应被复制(例如，如果你正使用跨数据库的多表DELETE语句或多表UPDATE语句)。如果不需要，只检查默认数据库比检查所有数据库要快得多。
·         --replicate-do-table=db_name.tbl_name
告诉从服务器线程限制对指定表的复制。要指定多个表，应多次使用该选项，每个表使用一次。同--replicate-do-db对比，允许跨数据库更新。请读取该选项列表后面的注意事项。
·         --replicate-ignore-db=db_name
告诉从服务器不要复制默认数据库(由USE所选择)为db_name的语句。要想忽略多个数据库，应多次使用该选项，每个数据库使用一次。如果正进行跨数据库更新并且不想复制这些更新，不应使用该选项。请读取该选项后面的注意事项。
一个不能按照期望工作的例如：如果用--replicate-ignore-db=sales启动从服务器，并且在主服务器上执行下面的语句，UPDATE语句不会复制：
·                USE prices;
·                UPDATE sales.january SET amount=amount+1000;
如果需要跨数据库更新，应使用--replicate-wild-ignore-table=db_name.%。
·         --replicate-ignore-table=db_name.tbl_name 
告诉从服务器线程不要复制更新指定表的任何语句(即使该语句可能更新其它的表)。要想忽略多个表，应多次使用该选项，每个表使用一次。同--replicate-ignore-db对比，该选项可以跨数据库进行更新。请读取该选项后面的注意事项。
·         --replicate-wild-do-table=db_name.tbl_name
告诉从服务器线程限制复制更新的表匹配指定的数据库和表名模式的语句。模式可以包含‘%’和‘_’通配符，与LIKE模式匹配操作符具有相同的含义。要指定多个表，应多次使用该选项，每个表使用一次。该选项可以跨数据库进行更新。请读取该选项后面的注意事项。
例如：--replicate-wild-do-table=foo%.bar%只复制数据库名以foo开始和表名以bar开始的表的更新。
如果表名模式为%，可匹配任何表名，选项也适合数据库级语句(CREATE DATABASE、DROP DATABASE和ALTER DATABASE)。例如，如果使用--replicate-wild-do-table=foo%.%，如果数据库名匹配模式foo%，则复制数据库级语句。
要想在数据库或表名模式中包括通配符，用反斜线对它们进行转义。例如，要复制名为my_own%db的数据库的所有表，但不复制my1ownAABCdb数据库的表，应这样转义‘_’和‘%’字符：--replicate-wild-do-table=my\_own\%db。如果在命令行中使用选项，可能需要双反斜线或将选项值引起来，取决于命令解释符。例如，用bash外壳则需要输入--replicate-wild-do-table=my\\_own\\%db。
·         --replicate-wild-ignore-table=db_name.tbl_name
告诉从服务器线程不要复制表匹配给出的通配符模式的语句。要想忽略多个表，应多次使用该选项，每个表使用一次。该选项可以跨数据库进行更新。请读取该选项后面的注意事项。
例如：--replicate-wild-ignore-table=foo%.bar%不复制数据库名以foo开始和表名以bar开始的表的更新。
关于匹配如何工作的信息，参见--replicate-wild-do-table选项的描述。在选项值中包括通配符的规则与--replicate-wild-ignore-table相同。
·         --replicate-rewrite-db=from_name->to_name
告诉从服务器如果默认数据库(由USE所选择)为主服务器上的from_name，则翻译为to_name。只影响含有表的语句(不是类似CREATE DATABASE、DROP DATABASE和ALTER DATABASE的语句)，并且只有from_name为主服务器上的默认数据库时。该选项不可以跨数据库进行更新。请注意在测试--replicate-*规则之前翻译数据库名。
如果在命令行中使用该选项， ‘>’字符专用于命令解释符，应将选项值引起来。例如：
shell> mysqld --replicate-rewrite-db="olddb->newdb"
·         --replicate-same-server-id
将用于从服务器上。通常可以默认设置为0以防止循环复制中的无限循环。如果设置为1，该从服务器不跳过有自己的服务器id的事件；通常只在有很少配置的情况下有用。如果使用--logs-slave-updates不能设置为1。请注意默认情况下如果有从服务器的id，服务器I/O线程不将二进制日志事件写入中继日志(该优化可以帮助节省硬盘的使用)。因此如果想要使用--replicate-same-server-id，让从服务器读取自己的SQL线程执行的事件前，一定要用该选项启动。
·         --report-host=slave_name
从服务器注册过程中报告给主服务器的主机名或IP地址。该值出现在主服务器上SHOW SLAVE HOSTS的输出中。如果不想让从服务器自己在主服务器上注册，则不设置该值。请注意从服务器连接后，主服务器仅仅从TCP/IP套接字读取从服务器的IP号是不够的。由于 NAT和其它路由问题，IP可能不合法，不能从主服务器或其它主机连接从服务器。
·         --report-port=slave_port
连接从服务器的TCP/IP端口号，从服务器注册过程中报告给主服务器。只有从服务器帧听非默认端口或如果有一个特殊隧道供主服务器或其它客户连接从服务器时才设置它。如果你不确定，不设置该选项。
·         --skip-slave-start
告诉从服务器当服务器启动时不启动从服务器线程。使用START SLAVE语句在以后启动线程。
·         --slave_compressed_protocol={0|1}
如果该选项设置为 1，如果从服务器和主服务器均支持，使用压缩从服务器/主服务器协议。
·         --slave-load-tmpdir=file_name
从服务器创建临时文件的目录名。该选项默认等于tmpdir系统变量的值。当从服务器SQL线程复制LOAD DATA INFILE语句时，从中继日志将待装载的文件提取到临时文件，然后将这些文件装入到表中。如果装载到主服务器上的文件很大，从服务器上的临时文件也很大。因此，建议使用该选项告诉从服务器将临时文件放到文件系统中有大量可用空间的目录下。在这种情况下，也可以使用--relay-log选项将中继日志放到该文件系统中，因为中继日志也很大。--slave-load-tmpdir应指向基于硬盘的文件系统，而非基于内存的文件系统：从服务器需要用临时文件在机器重启时用于复制LOAD DATA INFILE。系统启动过程中操作系统也不能清除该目录。
·         --slave-net-timeout=seconds
放弃读之前从主服务器等候更多数据的秒数，考虑到连接中断和尝试重新连接。超时后立即开始第1次重试。由--master-connect-retry选项控制重试之间的间隔。
·         --slave-skip-errors=[err_code1,err_code2,... | all]
通常情况，当出现错误时复制停止，这样给你一个机会手动解决数据中的不一致性问题。该选项告诉从服务器SQL线程当语句返回任何选项值中所列的错误时继续复制。
如果你不能完全理解为什么发生错误，则不要使用该选项。如果复制设置和客户程序中没有bug，并且MySQL自身也没有bug，应不会发生停止复制的错误。滥用该选项会使从服务器与主服务器不能保存同步，并且你找不到原因。
对于错误代码，你应使用从服务器错误日志中错误消息提供的编号和SHOW SLAVE STATUS的输出。服务器错误代码列于附录B：错误代码和消息。
你也可以(但不应)使用不推荐的all值忽略所有错误消息，不考虑所发生的错误。无需而言，如果使用该值，我们不能保证数据的完整性。在这种情况下，如果从服务器的数据与主服务器上的不相近请不要抱怨(或编写bug报告)。已经警告你了。
例如：
--slave-skip-errors=1062,1053
--slave-skip-errors=all
从服务器按下面评估--replicate-*规则，确定是否执行或忽视语句：
1.    是否有--replicate-do-db或--replicate-ignore-db规则？
·         有：测试--binlog-do-db和--binlog-ignore-db(参见5.11.3节，“二进制日志”)。测试结果是什么？
o        忽视语句：忽视并退出。
o        许可语句：不立即执行语句。推迟决策；继续下一步。
·         没有：继续下一步。
2.    我们目前正执行保存的程序或函数吗？
·         是：执行查询并退出。
·         否：继续下一步。
3.    是否有--replicate-*-table规则？
·         没有：执行查询并退出。
·         有：继续下一步并开始按所示顺序评估表规则(首先是非通配规则，然后是通配规则)。只有待更新的表根据这些规则进行比较(INSERT INTO sales SELECT * FROM prices:只有sales根据这些规则进行比较)。如果要更新几个表(多表语句)，第1个匹配的表(匹配“do”或“ignore”)获赢。也就是说，根据这些规则比较第1个表。然后，如果不能进行决策，根据这些规则比较第2个表等等。
4.    是否有--replicate-do-table规则？
·         有：表匹配吗？
o        是：执行查询并退出。
o        否：继续下一步。
·         没有：继续下一步。
5.    是否有--replicate-ignore-table规则？
·         有：表匹配吗？
o        是：忽视查询并退出。
o        否：继续下一步。
·         没有：继续下一步。
6.    是否有--replicate-wild-do-table规则？
·         有：表匹配吗？
o        是：执行查询并退出。
o        否：继续下一步。
·         没有：继续下一步。
7.    是否有--replicate-wild-ignore-table规则？
·         有：表匹配吗？
o        是：忽视查询并退出。
o        否：继续下一步。
·         没有：继续下一步。
8.    没有匹配的--replicate-*-table规则。要根据这些规则测试其它表吗？
·         是：执行循环。
·         否：我们现在已经测试了所有待更新的表，结果不能匹配任何规则。是否有--replicate-do-table或--replicate-wild-do-table规则？
o        有：有“do”规则但不匹配。忽视查询并退出。
o        没有：执行查询并退出。
6.9. 复制FAQ
Q：如果主服务器正在运行并且不想停止主服务器，怎样配置一个从服务器？
A：有多种方法。如果你在某时间点做过主服务器备份并且记录了相应快照的二进制日志名和偏移量(通过SHOW MASTER STATUS命令的输出)，采用下面的步骤：
1.    确保从服务器分配了一个唯一的服务器ID号。
2.    在从服务器上执行下面的语句，为每个选项填入适当的值：
            mysql> CHANGE MASTER TO
                ->     MASTER_HOST='master_host_name',
                ->     MASTER_USER='master_user_name',
                ->     MASTER_PASSWORD='master_pass',
                ->     MASTER_LOG_FILE='recorded_log_file_name',
              ->     MASTER_LOG_POS=recorded_log_position;
3.    在从服务器上执行START SLAVE语句。
如果你没有备份主服务器，这里是一个创建备份的快速程序。所有步骤都应该在主服务器主机上执行。
1.    发出该语句：
     mysql> FLUSH TABLES WITH READ LOCK；
2.    仍然加锁时，执行该命令（或它的变体）：
     shell> tar zcf /tmp/backup.tar.gz /var/lib/mysql
3.    发出该语句并且确保记录了以后用到的输出：
     mysql>SHOW MASTER STATUS；
4.    释放锁：
     mysql> UNLOCK TABLES；
一个可选择的方法是，转储主服务器的SQL来代替前面步骤中的二进制复制。要这样做，你可以在主服务器上使用mysqldump --master-data，以后装载SQL转储到到你的从服务器。然而，这比进行二进制复制速度慢。
不管你使用这两种方法中的那一个，当你有一个快照和记录了日志名与偏移量时，后来根据说明操作。你可以使用相同的快照建立多个从服务器。一旦你拥有主服务器的一个快照，可以等待创建一个从服务器，只要主服务器的二进制日志完整。两个能够等待的时间实际的限制是指在主服务器上保存二进制日志的可用硬盘空间和从服务器同步所用的时间。
你也可以使用LOAD DATA FROM MASTER。这是一个方便的语句，它传输一个快照到从服务器并且立即调整日志名和偏移量。将来，LOAD DATA FROM MASTER将成为创建从服务器的推荐方法。然而需要注意，它只工作在MyISAM 表上并且可能长时间持有读锁定。它并不象我们希望的那样高效率地执行。如果你有大表，执行FLUSH TABLES WITH READ LOCK语句后，这时首选方法仍然是在主服务器上制作二进制快照。
Q：从服务器需要始终连接到主服务器吗？
A：不，不需要。从服务器可以宕机或断开连接几个小时甚至几天，重新连接后获得更新信息。例如，你可以在通过拨号的链接上设置主服务器/从服务器关系，其中只是偶尔短时间内进行连接。这意味着，在任何给定时间，从服务器不能保证与主服务器同步除非你执行某些特殊的方法。将来，我们将使用选项来阻塞主服务器直到有一个从服务器同步。
Q：我怎样知道从服务器与主服务器的最新比较? 换句话说，我怎样知道从服务器复制的最后一个查询的日期？
A：你可以查看SHOW SLAVE STATUS语句的Seconds_Behind_Master列的结果。参见6.3节，“复制实施细节”。
当从服务器SQL线程执行从主服务器读取的事件时，它根据事件时间戳修改自己的时间（这是TIMESTAMP能够很好复制的原因）。在SHOW PROCESSLIST语句输出的Time列内，为从服务器SQL线程显示的秒数是最后一个复制事件的时间戳和从服务器主机的实际时间之间相差的秒数。你可以使用它来确定最后一个复制事件的日期。注意，如果你的从服务器与主服务器连接断开一个小时，然后重新连接，在SHOW PROCESSLIST结果中，你可以立即看到从服务器SQL线程的Time值为3600。这可能是因为从服务器执行的语句是一个一小时之前的。
Q：我怎样强制主服务器阻塞更新直到从服务器同步？
A：使用下面的步骤：
1.    在主服务器上，执行这些语句：
     mysql> FLUSH TABLES WITH READ LOCK;
     mysql> SHOW MASTER STATUS;
 
记录SHOW语句的输出的日志名和偏移量。这些是复制坐标。
2.    在从服务器上，发出下面的语句，其中Master_POS_WAIT()函数的参量是前面步骤中的得到的复制坐标值：
     mysql> SELECT MASTER_POS_WAIT('log_name', log_offset);
SELECT语句阻塞直到从服务器达到指定的日志文件和偏移量。此时，从服务器与主服务器同步，语句返回。
3.    在主服务器上，发出下面的语句允许主服务器重新开始处理更新：
     mysql> UNLOCK TABLES；
Q：当设置双向复制时我应该知道发出那些语句？
A：MySQL复制目前不支持主服务器和从服务器之间的任何锁定协议来保证分布式(跨服务器)更新的原子性。换句话说，这样做是可能的：客户A根据协作-主服务器1更新，同时，在它传给协作-主服务器2之前，客户B能够根据协作-主服务器2更新，这样客户A的更新与它在协作-主服务器1的更新不同。这样，当客户A根据协作-主服务器2更新时，它产生的表与在协作-主服务器1上的不同，即使所有根据协作-主服务器2的更新已经传过来。这意味着，在双向复制关系中，你不应该把两个服务器串连在一起，除非你确信任何顺序的更新是安全的，或者除非你在客户端代码中注意怎样避免更新顺序错误。
你还必须认识到从更新角度，双向复制实际上并不能显著地提高性能（或者根本不能提高性能）。两个服务器都需要做相同数量的更新，如同在一个服务器做的那样。唯一的差别是锁竞争要少，这因为源于另一个服务器的更新在一个从线程中序列化。即使这个益处可能被网络延迟抵消。
Q：怎样通过复制来提高系统的性能？
A：你应将一个服务器设置为主服务器并且将所有写指向该服务器。然后根据预算配置尽可能多的从服务器以及栈空间，并且在主服务器和从服务器之间分发读取操作。你也可以用--skip-innodb、--skip-bdb、--low-priority-updates以及--delay-key-write=ALL选项启动从服务器，以便在从服务器端提高速度。在这种情况下，为了提高速度，从服务器使用非事务MyISAM表来代替InnoDB和BDB表。
Q：为了使用高性能的复制，我应该在自己的应用程序中怎样准备客户端代码？
A：如果你的代码中数据库访问部分已经正确地模块化，应该能够平滑和容易地转换为在复制步骤中运行的代码。仅需要更改数据库访问执行部分，以便发送所有的写操作到主服务器，以及发送读操作到主服务器或某个从服务器。如果你的代码没有这个级别，设置一个复制系统以便清除。应先通过下面的函数创建一个包装库或模块：
·         safe_writer_connect()
·         safe_reader_connect()
·         safe_reader_statement()
·         safe_writer_statement()
每个函数名的safe_意味着函数比较小心地处理所有错误。你可以使用不同名的函数。重要是对于读连接、写连接、读和写有一个统一的接口。
然后，你应该转换客户端代码使用包装库。刚开始这可能是痛苦和恐慌的过程，但从长远来看是值得的。使用刚才讨论的方法的所有应用程序都能够利用主服务器/从服务器配置的优越性，即使是含有多个从服务器的配置。代码非常容易维护，并且添加排错选项也很容易。你仅需要修改一两个函数；例如，记录每个语句执行的时间，或者你的上千个语句中哪个语句发生了错误。
如果你已经编写了许多代码，你可能想使用replace工具自动进行转换，该工具随标准MySQL一起发布，或可以自己编写转换脚本。理想情况，你的代码使用一致的程序转换风格。否则，可能最好重新编写代码，或者至少手工对其进行规则化以使用一致的风格。
Q：MySQL复制能够何时和多大程度提高系统性能？
A：MySQL复制对于频繁读和频繁写的系统具有最大好处。理论上，通过使用单个主服务器/多从服务器设置，可以通过添加更多的从服务器来扩充系统，直到用完网络带宽，或者你的更新负载已经增长到主服务器不能处理的点。
在获得的收益开始吃平之前，为了确定可以有多少从服务器，以及可以将你的站点的性能提高多少，需要知道查询模式，并且要通过基准测试并根据经验确定一个典型的主服务器和从服务器中的读取（每秒钟读取量，或者max_reads）吞吐量和写（max_writes）吞吐量的关系。通过一个假设的带有复制的系统，本例给出了一个非常简单的计算结果。
假设系统负载包括10%的写和90%的读取，并且我们通过基准测试确定max_reads是1200 –2 × max_writes。换句话说，如果没有写操作，系统每秒可以进行1,200次读取操作，平均写操作是平均读操作所用时间的两倍，并且关系是线性的。我们假定主服务器和每个从服务器具有相同的性能，并且我们有一个主服务器和N个从服务器。那么，对于每个服务器（主服务器或从服务器），我们有：
reads = 1200 – 2 × writes
reads = 9 × writes / (N + 1) (读取是分离的, 但是写入所有服务器)
9 × writes / (N + 1) + 2 × writes = 1200
writes = 1200 / (2 + 9/(N+1))
最后的等式表明了N个从服务器的最大写操作数，假设最大可能的读取速率是每分钟1,200次，读操作与写操作的比率是9。
如上分析可以得到下面的结论：
·         如果N = 0（这表明没有复制），系统每秒可以处理大约1200/11 = 109个写操作。
·         如果N = 1，每秒得到184个写操作。
·         如果N = 8，每秒得到400个写操作。
·         如果N = 17，每秒得到480个写操作。
·         最后，当 N 趋于无穷大（以及我们预算的负无穷大）时，可以得到非常接近每秒600个写操作，系统吞吐量增加将近5.5倍。然而，如果只用8个服务器，增加接近4倍。
请注意，这些计算假设网络带宽无穷大并忽略掉了其它一些因素，那些因素可能对系统产生重要的影响。在许多情况下，不能执行与刚才类似的计算，即如果添加N台复制从服务器，应该准确预报系统将发生哪些影响。回答下面的问题应能够帮助你确定复制是否和在多大程度上能够提高系统的性能：
·         系统上的读取/写比例是什么? 
·         如果减少读取操作，一个服务器可以多处理多少写负载？
·         网络带宽可满足多少从服务器的需求? 
Q：如何使用复制来提供冗余/高可用性? 
A：利用目前的可用特性，必须设置一个主服务器和一个从服务器（或多个从服务器），以及写一个脚本来监视主服务器是否启动。如果主服务器失败，通知应用程序和从服务器切换主服务器。下面是一些建议：
·         告知从服务器更改其主服务器，使用CHANGE MASTER TO语句。
·         通知应用程序主服务器位置的一个很好的方法是对主服务器提供动态DNS入口。用bind可以使用nsupdate动态更新DNS。
·         应该用--logs-bin选项而不用 --logs-slave-updates选项运行从服务器。这样，一旦你在其它从服务器上发出STOP SLAVE; RESET MASTER, 以及CHANGE MASTER TO语句，该从服务器可以切换为主服务器。例如，假设有下面的设置：
·                       WC
·                        \
·                         v
·                 WC----> M
·                       / | \
·                      /  |  \
·                     v   v   v
·                    S1   S2  S3
M代表主服务器，S代表从服务器，WC代表发出数据库写和读取操作的客户；只发出数据库读取操作的客户没有给出，因为它们不需要切换。S1、S2以及S3是从服务器，用--logs-bin选项而没有用--logs-slave-updates运行。因为从服务器收到的主服务器的更新没有记录在二进制日志中，除非指定 --logs-slave-updates选项，每个从服务器上的二进制日志是空的。如果因为某些原因M 变得不可用，你可以选取一个从服务器变为新的主服务器。例如，如果你选取了S1，所有WC应该重新指向S1和S2，并且S3然后应从S1复制。
确保所有从服务器已经处理了中继日志中的所有语句。在每个从服务器上，发出STOP SLAVE IO_THREAD语句，然后检查SHOW PROCESSLIST语句的输出，直到你看到Has read all relay log。当所有从服务器都执行完这些，它们可以被重新配置为一个新的设置。在被提升为主服务器的从服务器S1上，发出STOP SLAVE和RESET MASTER语句。
在其它从服务器S2和S3上，使用STOP SLAVE和CHANGE MASTER TO MASTER_HOST='S1'（其中'S1'表示S1实际的主机名）。为CHANGE MASTER添加关于从S2或S3如何连接到S1的所有信息（user、password、port）。在CHANGE MASTER命令中，不需要指定从其读取的S1的二进制日志名或二进制日志位置：我们知道它是第1个二进制日志，位置是4，这是CHANGE MASTER命令的默认值。最后，在S2和S3上使用START SLAVE 命令。
然后，指示所有WC 把它们的语句指向S1。此后，WC发出的所有发送到S1的更新语句被写入S1的二进制日志，S1则包含M死掉之后的发送到 S1的每一个更新语句。
结果是下面的配置：
       WC
      /
      |
 WC   |  M(unavailable)
  \   |
   \  |
    v v
     S1<--S2  S3
      ^       |
      +-------+
当 M重新启动后，你必须在M上发出相同的CHANGE MASTER语句，与在S2和S3上发出的语句一样，以便M变为S1的从服务器并且恢复在它宕机后丢失的所有WC写操作。要把 M 再次作为主服务器（例如，因为它是功能最强的机器），使用前面的步骤，好像S1不可用并且M变为一个新的主服务器一样。在这个过程中，在S1、S2以及S3作为M的从服务器之前，不要忘记在M上运行RESET MASTER。否则，它们可能拾取M变得不可用之前的旧WC写操作。
我们目前正在MySQL集成自动主服务器选择系统，但在准备好之前，你必须创建自己的监控工具。
6.10. 复制故障诊断与排除
如果你遵从了上述说明，复制设置仍然不工作，首先检查下面各项：
·         检查错误日志的消息。许多用户遇到问题后没有及时地这样做而浪费了时间。
·         主服务器记录到了二进制日志？用SHOW MASTER STATUS检查。如果已经记录，Position应为非零。如果没有记录，确认正用log-bin和server-id选项运行主服务器。
·         是否从服务器在运行？使用SHOWSHOW SLAVE STATUS检查是否slave_IO_Running和slave_SQL_Running的值均为Yes。如果不是，验证当启动从服务器时使用的选项。
·         如果从服务器正在运行，建立了与主服务器的连接吗？使用SHOW PROCESSLIST，找出I/O和SQL线程并检查它们的State列看它们如何显示。参见6.3节，“复制实施细节”。如果I/O线程状态为Connecting to master，验证主服务器上复制用户的权限、主服务器主机名、DNS设置，是否主服务器真正在运行，以及是否可以从从属服务器访问。
·         如果从服务器以前在运行但是现在已经停止，原因通常是在主服务器上成功的部分语句在从服务器上失败了。如果你正确快照了主服务器，并且从来没有不通过服务器线程修改从服务器上的数据，这种现象不应发生。如果发生，应为一个bug或你遇到了一个6.7节，“复制特性和已知问题” 描述的已知的复制限制。如果是一个bug，参见6.11节，“通报复制缺陷”查阅如何通报的说明。
·         如果某个在主服务器上成功的语句拒绝在从服务器上运行，并且不能执行完全的数据库重新同步(即删除从服务器的数据库并从主服务器复制新的快照)，尝试：
1.    确定是否从服务器的表与主服务器的不同。尽力了解发生的原因。然后让从服务器的表与主服务器的一样并运行START SLAVE。
2.    如果前面的步骤不工作或不适合，尽力了解手动更新是否安全(如果需要)，然后忽视来自主服务器的下一个语句。
3.    如果你确定可以跳过来自主服务器的下一个语句，执行下面的语句：
4.                  mysql> SET GLOBAL SQL_slave_SKIP_COUNTER = n；
5.                  mysql> START SLAVE；
如果来自主服务器的下一个语句不使用AUTO_INCREMENT或LAST_INSERT_ID()，n 值应为1。否则，值应为2。使用AUTO_INCREMENT或LAST_INSERT_ID()的语句使用值2的原因是它们从主服务器的二进制日志中取两个事件。
6.    如果你确保从服务器启动时完好地与主服务器同步，并且没有更新从服务器线程之外的表，则大概诧异是由于bug。如果你正运行最近的版本，请通报该问题。如果你正运行旧版本MySQL，尽力升级到最新的产品版本。
6.11. 通报复制缺陷
如果你确定没有用户错误，但复制仍然不工作或不稳定，则是向我们发送bug通报的时候了。我们需要尽可能从你那儿获得更多的信息已跟踪bug。请花一些时间和努力编写一份好的bug通报。
如果你有一个重复的测试案例来说明bug，请把它输入我们的bug数据库，位置为http://bugs.mysql.com/。如果你有一个“phantom”问题(不能按照期望进行复制)，则使用下面的程序：
1.    确认未包括用户错误。例如，如果你不用从服务器线程来更新从服务器，数据将不同步，并且会遇到唯一的键值违背更新。在这种情况下，从服务器线程停止并等待你手动清理表使它们同步。这不是复制问题。这是一个外部接口问题造成复制失败。
2.    用--logs-slave-updates和--logs-bin选项运行从服务器。这些选项使从服务器将从主服务器接收的更新记入自己的二进制日志。
3.    重新设置复制状态之前保存所有的证据。如果我们没有信息或只有粗略的信息，则难以或不可能跟踪问题。应搜集的证据为：
·         所有主服务器的二进制日志
·         所有从服务器的二进制日志
·         你发现问题时主服务器的SHOW MASTER STATUS的输出
·         你发现问题时主服务器的SHOW SLAVE STATUS的输出
·         主服务器和从服务器的错误日志
4.    使用mysqlbinlog检查二进制日志。下面命令应有助于发现有问题的查询，例如：
5.            shell> mysqlbinlog -j pos_from_slave_status \
6.                       /path/to/log_from_slave_status | head
搜集了问题的证据后，首先作为一个测试案例隔离开。然后将问题输入我们的bug数据库，位置为http://bugs.mysql.com/，应提供尽可能多的信息。
6.12. 多服务器复制中的Auto-Increment
当将多个服务器配置为复制主服务器时，使用auto_increment时应采取特殊步骤以防止键值冲突，否则插入行时多个主服务器会试图使用相同的auto_increment值。
服务器变量auto_increment_increment和auto_increment_offset可以帮助协调多主服务器复制和AUTO_INCREMENT列。每个变量有一个默认的(并且是最小的)值1，最大值为65,535。
将这些变量设置为非冲突的值，当在同一个表主插入新行时，多主服务器配置主的服务器将不会与AUTO_INCREMENT值冲突。
这两个变量这样影响AUTO_INCREMENT列：
·         auto_increment_increment控制列值增加的间隔。例如：
·                mysql> SHOW VARIABLES LIKE 'auto_inc%';
·                +--------------------------+-------+
·                | Variable_name            | Value |
·                +--------------------------+-------+
·                | auto_increment_increment | 1     |
·                | auto_increment_offset    | 1     |
·                +--------------------------+-------+
·                2 rows in set (0.00 sec)
·                 
·                mysql> CREATE TABLE autoinc1 (col INT NOT NULL AUTO_INCREMENT PRIMARY KEY);
·                Query OK, 0 rows affected (0.04 sec)
·                 
·                mysql> SET @auto_increment_increment=10;
·                Query OK, 0 rows affected (0.00 sec)
·                 
·                mysql> SHOW VARIABLES LIKE 'auto_inc%';
·                +--------------------------+-------+
·                | Variable_name            | Value |
·                +--------------------------+-------+
·                | auto_increment_increment | 10    |
·                | auto_increment_offset    | 1     |
·                +--------------------------+-------+
·                2 rows in set (0.01 sec)
·                 
·                mysql> INSERT INTO autoinc1 VALUES (NULL), (NULL), (NULL), (NULL);
·                Query OK, 4 rows affected (0.00 sec)
·                Records: 4  Duplicates: 0  Warnings: 0
·                 
·                mysql> SELECT col FROM autoinc1;
·                +-----+
·                | col |
·                +-----+
·                |   1 |
·                |  11 |
·                |  21 |
·                |  31 |
·                +-----+
·                4 rows in set (0.00 sec)
(这里注明如何使用SHOW VARIABLES以获得这些变量的当前值）。
·         auto_increment_offset确定AUTO_INCREMENT列值的起点。影响到在复制设置主可以有多少主服务器(例如将该值设置为10表示设置可以支持10个服务器)。
考虑下面的命令，假定在前面所示示例中的相同的会话中执行这些命令：
mysql> SET @auto_increment_offset=5;
Query OK, 0 rows affected (0.00 sec)
 
mysql> SHOW VARIABLES LIKE 'auto_inc%';
+--------------------------+-------+
| Variable_name            | Value |
+--------------------------+-------+
| auto_increment_increment | 10    |
| auto_increment_offset    | 5     |
+--------------------------+-------+
2 rows in set (0.00 sec)
 
mysql> CREATE TABLE autoinc2 (col INT NOT NULL AUTO_INCREMENT PRIMARY KEY);
Query OK, 0 rows affected (0.06 sec)
 
mysql> INSERT INTO autoinc2 VALUES (NULL), (NULL), (NULL), (NULL);
Query OK, 4 rows affected (0.00 sec)
Records: 4  Duplicates: 0  Warnings: 0
 
mysql> SELECT col FROM autoinc2;
+-----+
| col |
+-----+
|   5 |
|  15 |
|  25 |
|  35 |
+-----+
4 rows in set (0.02 sec)
详细信息参见5.3.3节，“服务器系统变量”。
第7章：优化
目录
7.1. 优化概述 
7.1.1. MySQL设计局限与折衷 
7.1.2. 为可移植性设计应用程序 
7.1.3. 我们已将MySQL用在何处？ 
7.1.4. MySQL基准套件 
7.1.5. 使用自己的基准
7.2. 优化SELECT语句和其它查询 
7.2.1. EXPLAIN语法（获取SELECT相关信息） 
7.2.2. 估计查询性能 
7.2.3. SELECT查询的速度 
7.2.4. MySQL怎样优化WHERE子句 
7.2.5. 范围优化 
7.2.6. 索引合并优化 
7.2.7. MySQL如何优化IS NULL 
7.2.8. MySQL如何优化DISTINCT 
7.2.9. MySQL如何优化LEFT JOIN和RIGHT JOIN 
7.2.10. MySQL如何优化嵌套Join 
7.2.11. MySQL如何简化外部联合 
7.2.12. MySQL如何优化ORDER BY 
7.2.13. MySQL如何优化GROUP BY 
7.2.14. MySQL如何优化LIMIT 
7.2.15. 如何避免表扫描 
7.2.16. INSERT语句的速度 
7.2.17. UPDATE语句的速度 
7.2.18. DELETE语句的速度 
7.2.19. 其它优化技巧
7.3. 锁定事宜 
7.3.1. 锁定方法 
7.3.2. 表锁定事宜
7.4. 优化数据库结构 
7.4.1. 设计选择 
7.4.2. 使你的数据尽可能小 
7.4.3. 列索引 
7.4.4. 多列索引 
7.4.5. MySQL如何使用索引 
7.4.6. MyISAM键高速缓冲 
7.4.7. MyISAM索引统计集合 
7.4.8. MySQL如何计算打开的表 
7.4.9. MySQL如何打开和关闭表 
7.4.10. 在同一个数据库中创建多个表的缺陷
7.5. 优化MySQL服务器 
7.5.1. 系统因素和启动参数的调节 
7.5.2. 调节服务器参数 
7.5.3. 控制查询优化器的性能 
7.5.4. 编译和链接怎样影响MySQL的速度 
7.5.5. MySQL如何使用内存 
7.5.6. MySQL如何使用DNS
7.6. 磁盘事宜 
7.6.1. 使用符号链接
优化是一个复杂的任务，因为最终要求了解整个待优化的系统。尽管可以进行局部优化而不需要了解系统或应用程序，为了优化得更好，你必须知道更多的信息。
本章解释并给出不同的优化MySQL的方法示例。但要记住总有一些其它方法使系统更快，尽管需要更多的工作。
7.1. 优化概述
7.1.1. MySQL设计局限与折衷 
7.1.2. 为可移植性设计应用程序 
7.1.3. 我们已将MySQL用在何处？ 
7.1.4. MySQL基准套件 
7.1.5. 使用自己的基准
使一个系统更快的最重要因素当然是基本设计。此外，还需要知道系统正做什么样的事情，以及瓶颈是什么。
最常见的系统瓶颈是：
磁盘搜索。需要花时间从磁盘上找到一个数据，用在现代磁盘的平均时间通常小于10ms，因此理论上我们能够每秒大约搜索1000次。这个时间在新磁盘上提高不大并且很难为一个表进行优化。优化它的方法是将数据分布在多个磁盘上。 
磁盘读/写。当磁盘放入正确位置后，我们需要从中读取数据。对于现代的磁盘，一个磁盘至少传输10-20Mb/s的吞吐。这比搜索要容易优化，因为你能从多个磁盘并行地读。 
CPU周期。我们将数据读入内存后，需要对它进行处理以获得我们需要的结果。表相对于内存较小是最常见的限制因素。但是对于小表，速度通常不成问题。 
·         内存带宽。当CPU需要的数据超出CPU缓存时，主缓存带宽就成为内存的一个瓶颈。这在大多数系统正是一个不常见的瓶颈但是你应该知道它。
7.1.1. MySQL设计局限与折衷
当使用MyISAM存储引擎时，MySQL使用极快速的表锁定，以便允许多次读或一次写。使用该存储引擎的最大问题出现在同一个表中进行混合稳定数据流更新与慢速选择。如果这只是某些表的问题，你可以使用另一个存储引擎。参见第15章：存储引擎和表类型。
MySQL可以使用事务表和非事务表。为了更容易地让非事务表顺利工作(如果出现问题不能回滚)，MySQL采用下述规则。请注意这些规则只适用于不运行在严格模式下或为INSERT或UPDATE使用IGNORE规定程序时。
·         所有列有默认值。请注意当运行在严格SQL模式(包括TRADITIONAL SQL模式)时，必须为NOT NULL列指定默认值。
·         如果向列内插入不合适的或超出范围的值，MySQL将该列设定为“最好的可能的值”，而不是报告错误。对于数字值，为0、可能的最小值或最大值。对于字符串，为空字符串或列内可以保存的字符串。请注意当运行在严格模式或TRADITIONAL SQL模式时该行为不 适用。
·         所有表达式的计算结果返回一个表示错误状况的信号。例如，1/0返回NULL。(使用ERROR_FOR_DIVISION_BY_ZERO SQL模式可以更改该行为)。
如果正使用非事务表，不应该使用MySQL来检查列的内容。一般情况，最安全的(通常是最快的)方法径是让应用程序确保只向数据库传递合法值。
相关详细信息参见1.8.6节，“MySQL处理约束的方式”和13.2.4节，“INSERT语法”或5.3.2节，“SQL服务器模式”。
7.1.2. 为可移植性设计应用程序
因为不同SQL服务器实现了标准SQL的不同部分，需要花功夫来编写可移植的SQL应用程序。对很简单的选择/插入，很容易实现移植，但是需要的功能越多则越困难。如果想要应用程序对很多数据库系统都快，它变得更难！
为了使一个复杂应用程序可移植，你需要选择它应该工作的SQL服务器，并确定这些服务器支持什么特性。
所有数据库都有一些弱点。这就是它们不同的设计折衷导致的不同行为。
可以使用MySQL的crash-me程序来找出能用于数据库服务器选择的函数、类型和限制。crash-me并不能找出所有的特性，但是其广度仍然很合理，可以进行大约450个测试。
crash-me可以提供的一种类型的信息的例子：如果想要使用Informix或DB2，不应该使用超过18个字符的列名。
crash-me程序和MySQL基准程序是独立于数据库的。通过观察它们是如何编写的，编可以知道必须为编写独立于数据库的应用程序做什么。基准本身可在MySQL源码分发的“sql-bench”目录下找到。它们用DBI数据库接口以Perl写成。使用DBI本身即可以解决部分移植性问题，因为它提供与数据库无关的的存取方法。
如果你为数据库的独立性而努力，需要很好地了解每个SQL服务器的瓶颈。例如，MySQL在检索和更新MyISAM表记录方面很快，但是在同一个表上混合慢速读者和写者方面有一个问题。另一方面，当你试图访问最近更新了(直到它们被刷新到磁盘上)的行时，在Oracle中有一个很大的问题。事务数据库总的来说在从记录文件表中生成总结表方面不是很好，因为在这种情况下，行锁定几乎没有用。
为了使应用程序“确实”独立于数据库，需要定义一个容易扩展的接口，用它可操纵数据。因为C++在大多数系统上可以适用，使用数据库的一个C++ 类接口是有意义的。
如果你使用某个数据库特定的功能(例如MySQL专用的REPLACE语句)，应该为SQL服务器编码一个方法以实现同样的功能。尽管慢些，但确允许其它服务器执行同样的任务。
用MySQL，可以使用/*! */语法把MySQL特定的关键词加到查询中。在/**/中的代码将被其它大多数SQL服务器视为注释(并被忽略)。
如果高性能真的比准确性更重要，就像在一些web应用程序那样，一种可行的方法是创建一个应用层，缓存所有的结果以便得到更高的性能。通过只是让旧的结果在短时间后‘过期’，能保持缓存合理地刷新。这在极高负载的情况下是相当不错的，在此情况下，能动态地增加缓存并且设定较高的过期时限直到一切恢复正常。
在这种情况下，表创建信息应该包含缓存初始大小和表刷新频率等信息。
实施应用程序缓存的一种方法是使用MySQL查询缓存。启用查询缓存后，服务器可以确定是否可以重新使用查询结果。这样简化了你的应用程序。参见5.13节，“MySQL查询高速缓冲”。
7.1.3. 我们已将MySQL用在何处？
该节描述了Mysql的早期应用程序。
在MySQL最初开发期间，MySQL的功能适合大多数客户。MySQL为瑞典的一些最大的零售商处理数据仓库。
我们从所有商店得到所有红利卡交易的每周总结，并且我们期望为所有店主提供有用的信息以帮助他们得出他们的广告战如何影响他们的顾客。
数据是相当巨量的(大约每月7百万宗交易总结)并且我们保存4-10年来的数据需要呈现给用户。我们每周从顾客那里得到请求，他们想要“立刻”访问来自该数据的新报告。
我们通过每月将所有信息存储在压缩的“交易”表中来解决它。我们有一套简单的宏/脚本用来生成来自交易表的不同条件( 产品组、顾客id，商店...)的总结表。报告是由一个进行语法分析网页的小perl脚本动态生成的网页，在脚本中执行SQL语句并且插入结果。我们很想使用PHP或mod_perl，但是那时它们还不可用。
对图形数据，我们用C语言编写了一个简单的工具，它能基于那些结果处理SQL查询结果并生成GIF图形。该工具也从分析Web网页的perl脚本中动态地执行。
在大多数情况下，一个新的报告通过简单地复制一个现有脚本并且修改其中的SQL查询来完成。在一些情况下，我们将需要把更多的列加到一个现有的总结表中或产生一个新的，但是这也相当简单，因为我们在磁盘上保存所有交易表。（目前我们大约有50G的交易表和200G的其它顾客数据)。 
我们也让我们的顾客直接用ODBC访问总结表以便高级用户能自己用这些数据进行试验。
该系统工作得很好，我们可以毫无问题地用很适度的Sun Ultra SPARC工作站硬件(2x200MHz)来处理数据。该系统被逐步移植到了Linux中。
7.1.4. MySQL基准套件
本节应该包含MySQL基准套件(和crash-me)的技术描述，但是该描述还没写成。目前，你可以通过在MySQL源码分发中的“sql-bench”目录下的代码和结果了解基准套件是如何工作的。
通过基准用户可以了解一个给定的SQL实现在哪方面执行得很好或很糟糕。
注意，这个基准是单线程的，它可以测量操作执行的最小时间。我们计划将来在基准套件中添加多线程测试。
要使用基准套件，必须满足下面的要求：
·         基准套件随MySQL源码分发提供。可以从http://dev.mysql.com/downloads/下载分发，或者使用当前的开发源码树(参见2.8.3节，“从开发源码树安装”)。
·         基准脚本用Perl编写而成，使用Perl DBI模块访问数据库服务器，因此必须安装DBI。还需要为每个待测试的服务器提供服务器专用DBD驱动程序。例如，要测试MySQL、PostgreSQL和DB2，必须安装DBD::mysql、DBD::Pg和DBD::DB2模块。参见2.13节，“Perl安装注意事项”。
获得MySQL源码分发后，可以在sql-bench目录找到基准套件。要运行基准测试，应构建MySQL，然后进入sql-bench目录并执行run-all-tests脚本：
shell> cd sql-bench
shell> perl run-all-tests --server=server_name
server_name是一个支持的服务器。要获得所有选项和支持的服务器，调用命令：
shell> perl run-all-tests --help
crash-me脚本也位于sql-bench目录。crash-me尝试通过实际运行查询确定数据库支持的特性以及其功能和限制。例如，它确定：
·         支持什么列类型
·         支持多少索引
·         支持什么函数
·         查询可以多大
·         VARCHAR列可以多大
关于一些可移植的基准程序的例子，参见MySQL基准套件。请参见7.1.4节，“MySQL基准套件”。可以利用这个套件的任何程序并且根据你的需要修改它。通过这样做，可以尝试不同的问题的解决方案并测试哪一个是最好的解决方案。
另一个免费基准套件是开放源码数据库基准套件，参见http://osdb.sourceforge.net/。
在系统负载繁重时出现一些问题是很普遍的，并且很多客户已经与我们联系了，他们在生产系统中有一个(测试)系统并且有负载问题。大多数情况下，性能问题经证明是与基本数据库设计有关的问题(例如，表扫描在高负载时表现不好)或操作系统或库问题。如果系统已经不在生产系统中，它们大多数将很容易修正。
为了避免这样的问题，应该把工作重点放在在可能最坏的负载下测试你的整个应用程序。你可以使用Super Smack。该工具可以从http://jeremy.zawodny.com/mysql/super-smack/获得。正如它的名字所建议，它可以根据你的需要提供合理的系统，因此确保只用于你的开发系统。
7.2. 优化SELECT语句和其它查询
7.2.1. EXPLAIN语法（获取SELECT相关信息） 
7.2.2. 估计查询性能 
7.2.3. SELECT查询的速度 
7.2.4. MySQL怎样优化WHERE子句 
7.2.5. 范围优化 
7.2.6. 索引合并优化 
7.2.7. MySQL如何优化IS NULL 
7.2.8. MySQL如何优化DISTINCT 
7.2.9. MySQL如何优化LEFT JOIN和RIGHT JOIN 
7.2.10. MySQL如何优化嵌套Join 
7.2.11. MySQL如何简化外部联合 
7.2.12. MySQL如何优化ORDER BY 
7.2.13. MySQL如何优化GROUP BY 
7.2.14. MySQL如何优化LIMIT 
7.2.15. 如何避免表扫描 
7.2.16. INSERT语句的速度 
7.2.17. UPDATE语句的速度 
7.2.18. DELETE语句的速度 
7.2.19. 其它优化技巧
首先，影响所有语句的一个因素是：你的许可设置得越复杂，所需要的开销越多。
执行GRANT语句时使用简单的许可，当客户执行语句时，可以使MySQL降低许可检查开销。例如，如果未授予任何表级或列级权限，服务器不需要检查tables_priv和columns_priv表的内容。同样地，如果不对任何 账户进行限制，服务器不需要对资源进行统计。如果查询量很高，可以花一些时间使用简化的授权结构来降低许可检查开销。
如果你的问题是与具体MySQL表达式或函数有关，可以使用mysql客户程序所带的BENCHMARK()函数执行定时测试。其语法为BENCHMARK(loop_count,expression)。例如：
mysql> SELECT BENCHMARK(1000000,1+1)；
+------------------------+
| BENCHMARK(1000000,1+1) |
+------------------------+
|                      0 |
+------------------------+
1 row in set (0.32 sec)
上面结果在PentiumII 400MHz系统上获得。它显示MySQL在该系统上在0.32秒内可以执行1,000,000个简单的+表达式运算。
所有MySQL函数应该被高度优化，但是总有可能有一些例外。BENCHMARK()是一个找出是否查询有问题的优秀的工具。
7.2.1. EXPLAIN语法（获取SELECT相关信息）
EXPLAIN tbl_name
或：
EXPLAIN [EXTENDED] SELECT select_options
EXPLAIN语句可以用作DESCRIBE的一个同义词，或获得关于MySQL如何执行SELECT语句的信息：
·         EXPLAIN tbl_name是DESCRIBE tbl_name或SHOW COLUMNS FROM tbl_name的一个同义词。
·         如果在SELECT语句前放上关键词EXPLAIN，MySQL将解释它如何处理SELECT，提供有关表如何联接和联接的次序。
该节解释EXPLAIN的第2个用法。
借助于EXPLAIN，可以知道什么时候必须为表加入索引以得到一个使用索引来寻找记录的更快的SELECT。
如果由于使用不正确的索引出现了问题，应运行ANALYZE TABLE更新表的统计（例如关键字集的势），这样会影响优化器进行的选择。参见13.5.2.1节，“ANALYZE TABLE语法”。
还可以知道优化器是否以一个最佳次序联接表。为了强制优化器让一个SELECT语句按照表命名顺序的联接次序，语句应以STRAIGHT_JOIN而不只是SELECT开头。
EXPLAIN为用于SELECT语句中的每个表返回一行信息。表以它们在处理查询过程中将被MySQL读入的顺序被列出。MySQL用一遍扫描多次联接（single-sweep multi-join）的方式解决所有联接。这意味着MySQL从第一个表中读一行，然后找到在第二个表中的一个匹配行，然后在第3个表中等等。当所有的表处理完后，它输出选中的列并且返回表清单直到找到一个有更多的匹配行的表。从该表读入下一行并继续处理下一个表。
当使用EXTENDED关键字时，EXPLAIN产生附加信息，可以用SHOW WARNINGS浏览。该信息显示优化器限定SELECT语句中的表和列名，重写并且执行优化规则后SELECT语句是什么样子，并且还可能包括优化过程的其它注解。
EXPLAIN的每个输出行提供一个表的相关信息，并且每个行包括下面的列：
·         id
SELECT识别符。这是SELECT的查询序列号。
·         select_type
SELECT类型，可以为以下任何一种：
o        SIMPLE
简单SELECT(不使用UNION或子查询) 
o        PRIMARY
最外面的SELECT
o        UNION
UNION中的第二个或后面的SELECT语句
o        DEPENDENT UNION
UNION中的第二个或后面的SELECT语句，取决于外面的查询
o        UNION RESULT
UNION的结果。
o        SUBQUERY
子查询中的第一个SELECT
o        DEPENDENT SUBQUERY
子查询中的第一个SELECT，取决于外面的查询
o        DERIVED
导出表的SELECT(FROM子句的子查询)
·         table
输出的行所引用的表。
·         type
联接类型。下面给出各种联接类型，按照从最佳类型到最坏类型进行排序：
o        system
表仅有一行(=系统表)。这是const联接类型的一个特例。
o        const
表最多有一个匹配行，它将在查询开始时被读取。因为仅有一行，在这行的列值可被优化器剩余部分认为是常数。const表很快，因为它们只读取一次！
const用于用常数值比较PRIMARY KEY或UNIQUE索引的所有部分时。在下面的查询中，tbl_name可以用于const表：
SELECT * from tbl_name WHERE primary_key=1；
 
SELECT * from tbl_name
WHERE primary_key_part1=1和 primary_key_part2=2；
o        eq_ref
对于每个来自于前面的表的行组合，从该表中读取一行。这可能是最好的联接类型，除了const类型。它用在一个索引的所有部分被联接使用并且索引是UNIQUE或PRIMARY KEY。
eq_ref可以用于使用= 操作符比较的带索引的列。比较值可以为常量或一个使用在该表前面所读取的表的列的表达式。
在下面的例子中，MySQL可以使用eq_ref联接来处理ref_tables：
SELECT * FROM ref_table,other_table
  WHERE ref_table.key_column=other_table.column;
 
SELECT * FROM ref_table,other_table
  WHERE ref_table.key_column_part1=other_table.column
    AND ref_table.key_column_part2=1;
o        ref
对于每个来自于前面的表的行组合，所有有匹配索引值的行将从这张表中读取。如果联接只使用键的最左边的前缀，或如果键不是UNIQUE或PRIMARY KEY（换句话说，如果联接不能基于关键字选择单个行的话），则使用ref。如果使用的键仅仅匹配少量行，该联接类型是不错的。
ref可以用于使用=或<=>操作符的带索引的列。
在下面的例子中，MySQL可以使用ref联接来处理ref_tables：
SELECT * FROM ref_table WHERE key_column=expr;
 
SELECT * FROM ref_table,other_table
  WHERE ref_table.key_column=other_table.column;
 
SELECT * FROM ref_table,other_table
  WHERE ref_table.key_column_part1=other_table.column
    AND ref_table.key_column_part2=1;
o        ref_or_null
该联接类型如同ref，但是添加了MySQL可以专门搜索包含NULL值的行。在解决子查询中经常使用该联接类型的优化。
在下面的例子中，MySQL可以使用ref_or_null联接来处理ref_tables：
SELECT * FROM ref_table
WHERE key_column=expr OR key_column IS NULL;
参见7.2.7节，“MySQL如何优化IS NULL”。
o        index_merge
该联接类型表示使用了索引合并优化方法。在这种情况下，key列包含了使用的索引的清单，key_len包含了使用的索引的最长的关键元素。详细信息参见7.2.6节，“索引合并优化”。
o        unique_subquery
该类型替换了下面形式的IN子查询的ref：
value IN (SELECT primary_key FROM single_table WHERE some_expr)
unique_subquery是一个索引查找函数，可以完全替换子查询，效率更高。
o        index_subquery
该联接类型类似于unique_subquery。可以替换IN子查询，但只适合下列形式的子查询中的非唯一索引：
value IN (SELECT key_column FROM single_table WHERE some_expr)
o        range
只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引。key_len包含所使用索引的最长关键元素。在该类型中ref列为NULL。
当使用=、<>、>、>=、<、<=、IS NULL、<=>、BETWEEN或者IN操作符，用常量比较关键字列时，可以使用range：
SELECT * FROM tbl_name
WHERE key_column = 10;
 
SELECT * FROM tbl_name
WHERE key_column BETWEEN 10 and 20;
 
SELECT * FROM tbl_name
WHERE key_column IN (10,20,30);
 
SELECT * FROM tbl_name
WHERE key_part1= 10 AND key_part2 IN (10,20,30);
o        index
该联接类型与ALL相同，除了只有索引树被扫描。这通常比ALL快，因为索引文件通常比数据文件小。
当查询只使用作为单索引一部分的列时，MySQL可以使用该联接类型。
o        ALL
对于每个来自于先前的表的行组合，进行完整的表扫描。如果表是第一个没标记const的表，这通常不好，并且通常在它情况下很差。通常可以增加更多的索引而不要使用ALL，使得行能基于前面的表中的常数值或列值被检索出。
·         possible_keys
possible_keys列指出MySQL能使用哪个索引在该表中找到行。注意，该列完全独立于EXPLAIN输出所示的表的次序。这意味着在possible_keys中的某些键实际上不能按生成的表次序使用。
如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查WHERE子句看是否它引用某些列或适合索引的列来提高你的查询性能。如果是这样，创造一个适当的索引并且再次用EXPLAIN检查查询。参见13.1.2节，“ALTER TABLE语法”。
为了看清一张表有什么索引，使用SHOW INDEX FROM tbl_name。
·         key
key列显示MySQL实际决定使用的键（索引）。如果没有选择索引，键是NULL。要想强制MySQL使用或忽视possible_keys列中的索引，在查询中使用FORCE INDEX、USE INDEX或者IGNORE INDEX。参见13.2.7节，“SELECT语法”。
对于MyISAM和BDB表，运行ANALYZE TABLE可以帮助优化器选择更好的索引。对于MyISAM表，可以使用myisamchk --analyze。参见13.5.2.1节，“ANALYZE TABLE语法”和5.9.4节，“表维护和崩溃恢复”。
·         key_len
key_len列显示MySQL决定使用的键长度。如果键是NULL，则长度为NULL。注意通过key_len值我们可以确定MySQL将实际使用一个多部关键字的几个部分。
·         ref
ref列显示使用哪个列或常数与key一起从表中选择行。
·         rows
rows列显示MySQL认为它执行查询时必须检查的行数。
·         Extra
该列包含MySQL解决查询的详细信息。下面解释了该列可以显示的不同的文本字符串：
o        Distinct
MySQL发现第1个匹配行后，停止为当前的行组合搜索更多的行。
o        Not exists
MySQL能够对查询进行LEFT JOIN优化，发现1个匹配LEFT JOIN标准的行后，不再为前面的的行组合在该表内检查更多的行。
下面是一个可以这样优化的查询类型的例子：
SELECT * 从t1 LEFT JOIN t2 ON t1.id=t2.id
  WHERE t2.id IS NULL；
假定t2.id定义为NOT NULL。在这种情况下，MySQL使用t1.id的值扫描t1并查找t2中的行。如果MySQL在t2中发现一个匹配的行，它知道t2.id绝不会为NULL，并且不再扫描t2内有相同的id值的行。换句话说，对于t1的每个行，MySQL只需要在t2中查找一次，无论t2内实际有多少匹配的行。
o        range checked for each record (index map: #)
MySQL没有发现好的可以使用的索引，但发现如果来自前面的表的列值已知，可能部分索引可以使用。对前面的表的每个行组合，MySQL检查是否可以使用range或index_merge访问方法来索取行。关于适用性标准的描述参见7.2.5节，“范围优化”和7.2.6节，“索引合并优化”，不同的是前面表的所有列值已知并且认为是常量。
这并不很快，但比执行没有索引的联接要快得多。
o        Using filesort
MySQL需要额外的一次传递，以找出如何按排序顺序检索行。通过根据联接类型浏览所有行并为所有匹配WHERE子句的行保存排序关键字和行的指针来完成排序。然后关键字被排序，并按排序顺序检索行。参见7.2.12节，“MySQL如何优化ORDER BY”。
o        Using index
从只使用索引树中的信息而不需要进一步搜索读取实际的行来检索表中的列信息。当查询只使用作为单一索引一部分的列时，可以使用该策略。
o        Using temporary
为了解决查询，MySQL需要创建一个临时表来容纳结果。典型情况如查询包含可以按不同情况列出列的GROUP BY和ORDER BY子句时。
o        Using where
WHERE子句用于限制哪一个行匹配下一个表或发送到客户。除非你专门从表中索取或检查所有行，如果Extra值不为Using where并且表联接类型为ALL或index，查询可能会有一些错误。
如果想要使查询尽可能快，应找出Using filesort 和Using temporary的Extra值。
o        Using sort_union(...), Using union(...), Using intersect(...)
这些函数说明如何为index_merge联接类型合并索引扫描。详细信息参见7.2.6节，“索引合并优化”。
o        Using index for group-by
类似于访问表的Using index方式，Using index for group-by表示MySQL发现了一个索引，可以用来查询GROUP BY或DISTINCT查询的所有列，而不要额外搜索硬盘访问实际的表。并且，按最有效的方式使用索引，以便对于每个组，只读取少量索引条目。详情参见7.2.13节，“MySQL如何优化GROUP BY”。
通过相乘EXPLAIN输出的rows列的所有值，你能得到一个关于一个联接如何的提示。这应该粗略地告诉你MySQL必须检查多少行以执行查询。当你使用max_join_size变量限制查询时，也用这个乘积来确定执行哪个多表SELECT语句。参见7.5.2节，“调节服务器参数”。
下列例子显示出一个多表JOIN如何能使用EXPLAIN提供的信息逐步被优化。
假定你有下面所示的SELECT语句，计划使用EXPLAIN来检查它：
EXPLAIN SELECT tt.TicketNumber, tt.TimeIn,
               tt.ProjectReference, tt.EstimatedShipDate,
               tt.ActualShipDate, tt.ClientID,
               tt.ServiceCodes, tt.RepetitiveID,
               tt.CurrentProcess, tt.CurrentDPPerson,
               tt.RecordVolume, tt.DPPrinted, et.COUNTRY,
               et_1.COUNTRY, do.CUSTNAME
        FROM tt, et, et AS et_1, do
        WHERE tt.SubmitTime IS NULL
          AND tt.ActualPC = et.EMPLOYID
          AND tt.AssignedPC = et_1.EMPLOYID
          AND tt.ClientID = do.CUSTNMBR;
对于这个例子，假定：
·         被比较的列声明如下：
表
列
列类型
tt
ActualPC
CHAR(10)
tt
AssignedPC
CHAR(10)
tt
ClientID
CHAR(10)
et
EMPLOYID
CHAR(15)
do
CUSTNMBR
CHAR(15)
·         表有下面的索引：
表
索引
tt
ActualPC
tt
AssignedPC
tt
ClientID
et
EMPLOYID(主键)
do
CUSTNMBR(主键)
·         tt.ActualPC值不是均匀分布的。
开始，在进行优化前，EXPLAIN语句产生下列信息：
 
table type possible_keys key  key_len ref  rows  Extra
et    ALL  PRIMARY       NULL NULL    NULL 74
do    ALL  PRIMARY       NULL NULL    NULL 2135
et_1  ALL  PRIMARY       NULL NULL    NULL 74
tt    ALL  AssignedPC,   NULL NULL    NULL 3872
           ClientID,
           ActualPC
      range checked for each record (key map: 35)
 
因为type对每张表是ALL，这个输出显示MySQL正在对所有表产生一个笛卡尔乘积；即每一个行的组合！这将花相当长的时间，因为必须检查每张表的行数的乘积！对于一个实例，这是74 * 2135 * 74 * 3872 = 45,268,558,720行。如果表更大，你只能想象它将花多长时间…… 
这里的一个问题是MySQL能更高效地在声明具有相同类型和尺寸的列上使用索引。在本文中，VARCHAR和CHAR是相同的，除非它们声明为不同的长度。因为tt.ActualPC被声明为CHAR(10)并且et.EMPLOYID被声明为CHAR(15)，长度不匹配。
为了修正在列长度上的不同，使用ALTER TABLE将ActualPC的长度从10个字符变为15个字符：
mysql> ALTER TABLE tt MODIFY ActualPC VARCHAR(15);
现在tt.ActualPC和et.EMPLOYID都是VARCHAR(15)，再执行EXPLAIN语句产生这个结果：
 
table type   possible_keys key     key_len ref         rows    Extra
tt    ALL    AssignedPC,   NULL    NULL    NULL        3872    Using
             ClientID,                                         where
             ActualPC
do    ALL    PRIMARY       NULL    NULL    NULL        2135
      range checked for each record (key map: 1)
et_1  ALL    PRIMARY       NULL    NULL    NULL        74
      range checked for each record (key map: 1)
et    eq_ref PRIMARY       PRIMARY 15      tt.ActualPC 1
 
这不是完美的，但是好一些了：rows值的乘积少了一个因子74。这个版本在几秒内执行完。
第2种方法能消除tt.AssignedPC = et_1.EMPLOYID和tt.ClientID = do.CUSTNMBR比较的列的长度失配问题：
mysql> ALTER TABLE tt MODIFY AssignedPC VARCHAR(15),
    ->                MODIFY ClientID   VARCHAR(15);
EXPLAIN产生的输出显示在下面：
table type   possible_keys key      key_len ref           rows Extra
et    ALL    PRIMARY       NULL     NULL    NULL          74
tt    ref    AssignedPC,   ActualPC 15      et.EMPLOYID   52   Using
             ClientID,                                         where
             ActualPC
et_1  eq_ref PRIMARY       PRIMARY  15      tt.AssignedPC 1
do    eq_ref PRIMARY       PRIMARY  15      tt.ClientID   1
 
这几乎很好了。 
剩下的问题是，默认情况，MySQL假设在tt.ActualPC列的值是均匀分布的，并且对tt表不是这样。幸好，很容易告诉MySQL来分析关键字分布：
mysql> ANALYZE TABLE tt；
现在联接是“完美”的了，而且EXPLAIN产生这个结果：
table type   possible_keys key     key_len ref           rows Extra
tt    ALL    AssignedPC    NULL    NULL    NULL          3872 Using
             ClientID,                                        where
             ActualPC
et    eq_ref PRIMARY       PRIMARY 15      tt.ActualPC   1
et_1  eq_ref PRIMARY       PRIMARY 15      tt.AssignedPC 1
do    eq_ref PRIMARY       PRIMARY 15      tt.ClientID   1
注意在从EXPLAIN输出的rows列是一个来自MySQL联接优化器的“教育猜测”。你应该检查数字是否接近事实。如果不是，可以通过在SELECT语句里面使用STRAIGHT_JOIN并且试着在FROM子句以不同的次序列出表，可能得到更好的性能。
7.2.2. 估计查询性能
在大多数情况下，可以通过计算磁盘搜索来估计性能。对小的表，通常能在1次磁盘搜索中找到行(因为索引可能被缓存)。对更大的表，可以使用B－树索引进行估计，将需要log(row_count)/log(index_block_length/3 * 2/(index_length + data_pointer_length))+1次搜索才能找到行。
在MySQL中，索引块通常是1024个字节，数据指针通常是4个字节，这对于有一个长度为3(中等整数)的索引的500,000行的表，通过公式可以计算出log(500,000)/log(1024/3*2/(3+4))+1= 4次搜索。
上面的索引需要大约500,000 * 7 * 3/2 = 5.2MB，(假设典型情况下索引缓存区填充率为2/3)，可以将大部分索引保存在内存中，仅需要1-2调用从OS读数据来找出行。
然而对于写，将需要4次搜索请求(如上)来找到在哪儿存放新索引，并且通常需要2次搜索来更新这个索引并且写入行。
注意，上述讨论并不意味着应用程序的性能将缓慢地以logN 退化！当表格变得更大时，所有内容缓存到OS或SQL服务器后，将仅仅或多或少地更慢。在数据变得太大不能缓存后，将逐渐变得更慢，直到应用程序只能进行磁盘搜索(以logN增加)。为了避免这个问题，随数据增加而增加 键高速缓冲区大小。对于MyISAM表, 由key_buffer_size系统变量控制 键高速缓冲区大小。参见7.5.2节，“调节服务器参数”。
7.2.3. SELECT查询的速度
总的来说，要想使一个较慢速SELECT ... WHERE更快，应首先检查是否能增加一个索引。不同表之间的引用通常通过索引来完成。你可以使用EXPLAIN语句来确定SELECT语句使用哪些索引。参见7.4.5节，“MySQL如何使用索引”和7.2.1节，“EXPLAIN语法（获取关于SELECT的信息）”。
下面是一些加速对MyISAM表的查询的一般建议：
·         为了帮助MySQL更好地优化查询，在一个装载数据后的表上运行ANALYZE TABLE或myisamchk --analyze。这样为每一个索引更新指出有相同值的行的平均行数的值（当然，如果只有一个索引，这总是1。）MySQL使用该方法来决定当你联接两个基于非常量表达式的表时选择哪个索引。你可以使用SHOW INDEX FROM tbl_name并检查Cardinality值来检查表分析结果。myisamchk --description --verbose可以显示索引分布信息。
·         要想根据一个索引排序一个索引和数据，使用myisamchk --sort-index --sort-records=1（如果你想要在索引1上排序）。如果只有一个索引，想要根据该索引的次序读取所有的记录，这是使查询更快的一个好方法。但是请注意，第一次对一个大表按照这种方法排序时将花很长时间！
7.2.4. MySQL怎样优化WHERE子句
该节讨论为处理WHERE子句而进行的优化。例子中使用了SELECT语句，但相同的优化也适用DELETE和UPDATE语句中的WHERE子句。
请注意对MySQL优化器的工作在不断进行中，因此该节并不完善。MySQL执行了大量的优化，本文中所列的并不详尽。
下面列出了MySQL执行的部分优化：
·         去除不必要的括号：
·                        ((a AND b) AND c OR (((a AND b) AND (c AND d))))
·                -> (a AND b AND c) OR (a AND b AND c AND d)
·         常量重叠：
·                   (a<b AND b=c) AND a=5
·                -> b>5 AND b=c AND a=5
·         去除常量条件(由于常量重叠需要)：
·                   (B>=5 AND B=5) OR (B=6 AND 5=5) OR (B=7 AND 5=6)
·                -> B=5 OR B=6
·         索引使用的常数表达式仅计算一次。
对于MyISAM和HEAP表，在一个单个表上的没有一个WHERE的COUNT(*)直接从表中检索信息。当仅使用一个表时，对NOT NULL表达式也这样做。 
无效常数表达式的早期检测。MySQL快速检测某些SELECT语句是不可能的并且不返回行。 
如果不使用GROUP BY或分组函数(COUNT()、MIN()……)，HAVING与WHERE合并。 
对于联接内的每个表，构造一个更简单的WHERE以便更快地对表进行WHERE计算并且也尽快跳过记录。 
所有常数的表在查询中比其它表先读出。常数表为： 
空表或只有1行的表。 
与在一个PRIMARY KEY或UNIQUE索引的WHERE子句一起使用的表，这里所有的索引部分使用常数表达式并且索引部分被定义为NOT NULL。 
下列的所有表用作常数表： 
mysql> SELECT * FROM t WHERE primary_key=1;
mysql> SELECT * FROM t1,t2
           WHERE t1.primary_key=1 AND t2.primary_key=t1.id;
尝试所有可能性便可以找到表联接的最好联接组合。如果所有在ORDER BY和GROUP BY的列来自同一个表，那么当联接时，该表首先被选中。 
如果有一个ORDER BY子句和不同的GROUP BY子句，或如果ORDER BY或GROUP BY包含联接队列中的第一个表之外的其它表的列，则创建一个临时表。 
如果使用SQL_SMALL_RESULT，MySQL使用内存中的一个临时表。 
每个表的索引被查询，并且使用最好的索引，除非优化器认为使用表扫描更有效。是否使用扫描取决于是否最好的索引跨越超过30%的表。优化器更加复杂，其估计基于其它因素，例如表大小、行数和I/O块大小，因此固定比例不再决定选择使用索引还是扫描。 
在一些情况下，MySQL能从索引中读出行，甚至不查询数据文件。如果索引使用的所有列是数值类，那么只使用索引树来进行查询。 
输出每个记录前，跳过不匹配HAVING子句的行。 
下面是一些快速查询的例子：
SELECT COUNT(*) FROM tbl_name;
 
SELECT MIN(key_part1),MAX(key_part1) FROM tbl_name;
 
SELECT MAX(key_part2) FROM tbl_name
    WHERE key_part1=constant;
 
SELECT ... FROM tbl_name
    ORDER BY key_part1,key_part2,... LIMIT 10;
 
SELECT ... FROM tbl_name
    ORDER BY key_part1 DESC, key_part2 DESC, ... LIMIT 10;
下列查询仅使用索引树就可以解决(假设索引的列为数值型)：
SELECT key_part1,key_part2 FROM tbl_name WHERE key_part1=val;
 
SELECT COUNT(*) FROM tbl_name
    WHERE key_part1=val1 AND key_part2=val2;
 
SELECT key_part2 FROM tbl_name GROUP BY key_part1;
下列查询使用索引按排序顺序检索行，不用另外的排序：
SELECT ... FROM tbl_name
    ORDER BY key_part1,key_part2,... ;
 
SELECT ... FROM tbl_name
    ORDER BY key_part1 DESC, key_part2 DESC, ... ;
7.2.5. 范围优化
7.2.5.1. 单元素索引的范围访问方法 
7.2.5.2. 多元素索引的范围访问方法
range访问方法使用单一索引来搜索包含在一个或几个索引值距离内的表记录的子集。可以用于单部分或多元素索引。后面的章节将详细描述如何从WHERE子句提取区间。
7.2.5.1. 单元素索引的范围访问方法
对于单元素索引，可以用WHERE子句中的相应条件很方便地表示索引值区间，因此我们称为范围条件而不是“区间”。
单元素索引范围条件的定义如下：
·         对于BTREE和HASH索引，当使用=、<=>、IN、IS NULL或者IS NOT NULL操作符时，关键元素与常量值的比较关系对应一个范围条件。
·         对于BTREE索引，当使用>、<、>=、<=、BETWEEN、!=或者<>，或者LIKE 'pattern'(其中 'pattern'不以通配符开始)操作符时，关键元素与常量值的比较关系对应一个范围条件。
·         对于所有类型的索引，多个范围条件结合OR或AND则产生一个范围条件。
前面描述的“常量值”系指：
·         查询字符串中的常量
·         同一联接中的const或system表中的列
·         无关联子查询的结果
·         完全从前面类型的子表达式组成的表达式
下面是一些WHERE子句中有范围条件的查询的例子：
SELECT * FROM t1 
    WHERE key_col > 1 
    AND key_col < 10;
 
SELECT * FROM t1 
    WHERE key_col = 1 
    OR key_col IN (15,18,20);
 
SELECT * FROM t1 
    WHERE key_col LIKE 'ab%' 
    OR key_col BETWEEN 'bar' AND 'foo';
 
请注意在常量传播阶段部分非常量值可以转换为常数。
MySQL尝试为每个可能的索引从WHERE子句提取范围条件。在提取过程中，不能用于构成范围条件的条件被放弃，产生重叠范围的条件组合到一起，并且产生空范围的条件被删除。
例如，考虑下面的语句，其中key1是有索引的列，nonkey没有索引：
SELECT * FROM t1 WHERE
   (key1 < 'abc' AND (key1 LIKE 'abcde%' OR key1 LIKE '%b')) OR
   (key1 < 'bar' AND nonkey = 4) OR
   (key1 < 'uux' AND key1 > 'z');
key1的提取过程如下：
1.    用原始WHERE子句开始：
2.    (key1 < 'abc' AND (key1 LIKE 'abcde%' OR key1 LIKE '%b')) OR
3.     (key1 < 'bar' AND nonkey = 4) OR
4.     (key1 < 'uux' AND key1 > 'z')
5.    删除nonkey = 4和key1 LIKE '%b'，因为它们不能用于范围扫描。删除它们的正确途径是用TRUE替换它们，以便进行范围扫描时不会丢失匹配的记录。用TRUE替换它们后，可以得到：
6.            (key1 < 'abc' AND (key1 LIKE 'abcde%' OR TRUE)) OR
7.            (key1 < 'bar' AND TRUE) OR
8.            (key1 < 'uux' AND key1 > 'z')
9.    取消总是为true或false的条件：
·         (key1 LIKE 'abcde%' OR TRUE)总是true
·         (key1 < 'uux' AND key1 > 'z')总是false 
用常量替换这些条件，我们得到：
(key1 < 'abc' AND TRUE) OR (key1 < 'bar' AND TRUE) OR (FALSE)
删除不必要的TRUE和FALSE常量，我们得到
(key1 < 'abc') OR (key1 < 'bar')
10.将重叠区间组合成一个产生用于范围扫描的最终条件：
11.        (key1 < 'bar')
总的来说(如前面的例子所述)，用于范围扫描的条件比WHERE子句限制少。MySQL再执行检查以过滤掉满足范围条件但不完全满足WHERE子句的行。
范围条件提取算法可以处理嵌套的任意深度的AND/OR结构，并且其输出不依赖条件在WHERE子句中出现的顺序。
7.2.5.2. 多元素索引的范围访问方法
多元素索引的范围条件是单元素索引的范围条件的扩展。多元素索引的范围条件将索引记录限制到一个或几个关键元组内。使用索引的顺序，通过一系列关键元组来定义关键元组区间。
例如，考虑定义为key1(key_part1, key_part2, key_part3)的多元素索引，以及下面的按关键字顺序所列的关键元组：
key_part1  key_part2  key_part3
  NULL       1          'abc'
  NULL       1          'xyz'
  NULL       2          'foo'
   1         1          'abc'
   1         1          'xyz'
   1         2          'abc'
   2         1          'aaa'
 
条件key_part1 = 1定义了下面的范围：
(1，-inf，-inf) <= (key_part1，key_part2，key_part3) < (1，+inf，+inf)
范围包括前面数据集中的第4、5和6个元组，可以用于范围访问方法。
通过对比，条件key_part3 = 'abc'不定义单一的区间，不能用于范围访问方法。
下面更加详细地描述了范围条件如何用于多元素索引中。
·         对于HASH索引，可以使用包含相同值的每个区间。这说明区间只能由下面形式的条件产生：
·                     key_part1 cmp const1
·                 AND key_part2 cmp const2
·                 AND ...
·                AND key_partN cmp constN;
这里，const1，const2，...为常量，cmp是=、<=>或者IS NULL比较操作符之一，条件包括所有索引部分。(也就是说，有N 个条件，每一个对应N-元素索引的每个部分）。
关于常量的定义，参见7.2.5.1节，“单元素索引的范围访问方法”。
例如，下面为三元素HASH索引的范围条件：
key_part1 = 1 AND key_part2 IS NULL AND key_part3 = 'foo'
·         对于BTREE索引，区间可以对结合AND的条件有用，其中每个条件用一个常量值通过=、<=>、IS NULL、>、<、>=、<=、!=、<>、BETWEEN或者LIKE 'pattern' (其中'pattern'不以通配符开头)比较一个关键元素。区间可以足够长以确定一个包含所有匹配条件(或如果使用<>或!=，为两个区间)的记录的单一的关键元组。例如，对于条件：
·                  key_part1 = 'foo' AND key_part2 >= 10 AND key_part3 > 10
单一区间为：
('foo'，10，10)
   < (key_part1，key_part2，key_part3)
      < ('foo'，+inf，+inf)
创建的区间可以比原条件包含更多的记录。例如，前面的区间包括值('foo'，11，0)，不满足原条件。
·         如果包含区间内的一系列记录的条件结合使用OR，则形成包括一系列包含在区间并集的记录的一个条件。如果条件结合使用了AND，则形成包括一系列包含在区间交集内的记录的一个条件。例如，对于两部分索引的条件：
·                (key_part1 = 1 AND key_part2 < 2)
·                OR (key_part1 > 5)
区间为：
(1, -inf) < (key_part1, key_part2) < (1, 2)
(5, -inf) < (key_part1, key_part2)
在该例子中，第1行的区间左侧的约束使用了一个关键元素，右侧约束使用了两个关键元素。第2行的区间只使用了一个关键元素。EXPLAIN输出的key_len列表示所使用关键字前缀的最大长度。
在某些情况中，key_len可以表示使用的关键元素，但可能不是你所期望的。假定key_part1和key_part2可以为NULL。则key_len列显示下面条件的两个关键元素的长度：
key_part1 >= 1 AND key_part2 < 2
但实际上，该条件可以变换为：
key_part1 >= 1 AND key_part2 IS NOT NULL
7.2.5.1节，“单元素索引的范围访问方法”描述了如何进行优化以结合或删除单元素索引范围条件的区间。多元素索引范围条件的区间的步骤类似。
7.2.6. 索引合并优化
7.2.6.1. 索引合并交集访问算法 
7.2.6.2. 索引合并并集访问算法 
7.2.6.3. 索引合并排序并集访问算法
索引合并方法用于通过range扫描搜索行并将结果合成一个。合并会产生并集、交集或者正在进行的扫描的交集的并集。
在EXPLAIN输出中，该方法表现为type列内的index_merge。在这种情况下，key列包含一列使用的索引，key_len包含这些索引的最长的关键元素。
例如：
SELECT * FROM tbl_name WHERE key_part1 = 10 OR key_part2 = 20;
 
SELECT * FROM tbl_name
    WHERE (key_part1 = 10 OR key_part2 = 20) AND non_key_part=30;
 
SELECT * FROM t1, t2
    WHERE (t1.key1 IN (1,2) OR t1.key2 LIKE 'value%')
    AND t2.key1=t1.some_col;
 
SELECT * FROM t1, t2
    WHERE t1.key1=1
    AND (t2.key1=t1.some_col OR t2.key2=t1.some_col2);
 
索引合并方法有几种访问算法 (参见EXPLAIN输出的Extra字段)：
·         交集
·         联合
·         排序并集
后面几节更加详细地描述了这些方法。
注释：索引合并优化算法具有以下几个已知缺陷：
·         如果可以对某些关键字进行范围扫描，则不考虑索引合并。例如，下面的查询：
·                SELECT * FROM t1 WHERE (goodkey1 < 10 OR goodkey2 < 20) AND badkey < 30;
对于该查询，可以有两个方案：
1.    使用(goodkey1 < 10 OR goodkey2 < 20)条件进行索引合并扫描。
2.    使用badkey < 30条件进行范围扫描。
然而，优化器只考虑第2个方案。如果这不是你想要的，你可以通过使用IGNORE INDEX或FORCE INDEX让优化器考虑index_merge。下面的查询使用索引合并执行：
SELECT * FROM t1 FORCE INDEX(goodkey1,goodkey2)
WHERE (goodkey1 < 10 OR goodkey2 < 20) AND badkey < 30;
 
SELECT * FROM t1 IGNORE INDEX(badkey)
WHERE (goodkey1 < 10 OR goodkey2 < 20) AND badkey < 30;
·         如果查询有一个复杂的WHERE子句，有较深的AND/OR嵌套关系，MySQL不选择该优选方案，通过下面的识别法则尝试分布各条件：
·                (x AND y) OR z = (x OR z) AND (y OR z)
·                (x OR y) AND z = (x AND z) OR (y AND z)
index_merge访问方法的不同变量之间的选择和其它访问方法基于各适用选项的成本估计。
7.2.6.1. 索引合并交集访问算法
该访问算法可以用于当WHERE子句结合AND被转换为不同的关键字的几个范围条件，每个条件为下面之一：
·         以这种形式，即索引有确切的N部分(即包括了所有索引部分)：
·                key_part1=const1 AND key_part2=const2 ... AND key_partN=constN
·         任何InnoDB或BDB表的主键的范围条件。
下面是一些例子：
SELECT * FROM innodb_table WHERE primary_key < 10 AND key_col1=20;
 
SELECT * FROM tbl_name
WHERE (key1_part1=1 AND key1_part2=2) AND key2=2;
索引合并交集算法同时对所有使用的索引进行扫描，并产生从合并的索引扫描接收的行序列的交集。
如果使用的索引包括查询中使用的所有列，所有表记录均不搜索，并且在这种情况下EXPLAIN的输出包含Extra字段中的Using index。下面是一个此类查询的例子：
SELECT COUNT(*) FROM t1 WHERE key1=1 AND key2=1;
如果使用的索引未包括查询中使用的所有列，只有满足所有使用的关键字的范围条件才搜索所有记录。
如果某个合并条件是InnoDB或BDB表的主键的一个条件，不用于记录查询，但用于过滤使用其它条件搜索的记录。
7.2.6.2. 索引合并并集访问算法
该算法的适用标准类似于索引合并方法交集算法的标准。算法可以用于当WHERE子句结合OR被转换为不同的关键字的几个范围条件的时候，每个条件为下面之一：
·         以这种形式，即索引有确切的N部分(即包括了所有索引部分)：
·                key_part1=const1 AND key_part2=const2 ... AND key_partN=constN
·         任何InnoDB或BDB表的主键的范围条件。
·         索引合并方法交集算法适用的一个条件。
下面是一些例子：
SELECT * FROM t1 WHERE key1=1 OR key2=2 OR key3=3;
 
SELECT * FROM innodb_table WHERE (key1=1 AND key2=2) OR
  (key3='foo' AND key4='bar') AND key5=5;
7.2.6.3. 索引合并排序并集访问算法
该访问算法可以用于当WHERE子句结合OR被转换为不同的关键字的几个范围条件，但索引合并方法联合算法并不适用的时候。
下面是一些例子：
SELECT * FROM tbl_name WHERE key_col1 < 10 OR key_col2 < 20;
 
SELECT * FROM tbl_name
     WHERE (key_col1 > 10 OR key_col2 = 20) AND nonkey_col=30;
排序联合算法和联合算法的区别是排序联合算法必须先索取所有记录的行ID，然后在返回记录前对它们进行排序。
7.2.7. MySQL如何优化IS NULL
MySQL可以对可以结合col_name = constant_value使用的col_name IS NULL进行相同的优化。例如，MySQL可以使用索引和范围用IS NULL搜索NULL。
SELECT * FROM tbl_name WHERE key_col IS NULL;
 
SELECT * FROM tbl_name WHERE key_col <=> NULL;
 
SELECT * FROM tbl_name
    WHERE key_col=const1 OR key_col=const2 OR key_col IS NULL;
如果WHERE子句包括声明为NOT NULL的列的col_name IS NULL条件，表达式则优化。当列会产生NULL时，不会进行优化；例如，如果来自LEFT JOIN右侧的表。
MySQL也可以优化组合col_name = expr AND col_name IS NULL，这是解决子查询的一种常用形式。当使用优化时EXPLAIN显示ref_or_null。
该优化可以为任何关键元素处理IS NULL。
下面是一些优化的查询例子，假定表t2的列a和b有一个索引：
SELECT * FROM t1 WHERE t1.a=expr OR t1.a IS NULL;
 
SELECT * FROM t1, t2 WHERE t1.a=t2.a OR t2.a IS NULL;
 
SELECT * FROM t1, t2
    WHERE (t1.a=t2.a OR t2.a IS NULL) AND t2.b=t1.b;
 
SELECT * FROM t1, t2
    WHERE t1.a=t2.a AND (t2.b=t1.b OR t2.b IS NULL);
 
SELECT * FROM t1, t2
    WHERE (t1.a=t2.a AND t2.a IS NULL AND ...)
    OR (t1.a=t2.a AND t2.a IS NULL AND ...);
ref_or_null首先读取参考关键字，然后单独搜索NULL关键字的行。
请注意该优化只可以处理一个IS NULL。在后面的查询中，MySQL只对表达式(t1.a=t2.a AND t2.a IS NULL)使用关键字查询，不能使用b的关键元素：
SELECT * FROM t1, t2
     WHERE (t1.a=t2.a AND t2.a IS NULL)
     OR (t1.b=t2.b AND t2.b IS NULL);
7.2.8. MySQL如何优化DISTINCT
在许多情况下结合ORDER BY的DISTINCT需要一个临时表。
请注意因为DISTINCT可能使用GROUP BY，必须清楚MySQL如何使用所选定列的一部分的ORDER BY或HAVING子句中的列。参见12.10.3节，“具有隐含字段的GROUP BY”。
在大多数情况下，DISTINCT子句可以视为GROUP BY的特殊情况。例如，下面的两个查询是等效的：
SELECT DISTINCT c1, c2, c3 FROM t1 WHERE c1 > const;
 
SELECT c1, c2, c3 FROM t1 WHERE c1 > const GROUP BY c1, c2, c3;
由于这个等效性，适用于GROUP BY查询的优化也适用于有DISTINCT子句的查询。这样，关于DISTINCT查询的优化的更详细的情况，参见7.2.13节，“MySQL如何优化GROUP BY”。
结合LIMIT row_count和DISTINCT后，MySQL发现唯一的row_count行后立即停止。
如果不使用查询中命名的所有表的列，MySQL发现第1个匹配后立即停止扫描未使用的表。在下面的情况中，假定t1在t2之前使用(可以用EXPLAIN检查)，发现t2中的第1行后，MySQL不再(为t1中的任何行)读t2：
SELECT DISTINCT t1.a FROM t1, t2 where t1.a=t2.a;
7.2.9. MySQL如何优化LEFT JOIN和RIGHT JOIN
在MySQL中，A LEFT JOIN B join_condition执行过程如下：
·         根据表A和A依赖的所有表设置表B。
·         根据LEFT JOIN条件中使用的所有表(除了B)设置表A。
·         LEFT JOIN条件用于确定如何从表B搜索行。(换句话说，不使用WHERE子句中的任何条件）。
·         可以对所有标准联接进行优化，只是只有从它所依赖的所有表读取的表例外。如果出现循环依赖关系，MySQL提示出现一个错误。
·         进行所有标准WHERE优化。
·         如果A中有一行匹配WHERE子句，但B中没有一行匹配ON条件，则生成另一个B行，其中所有列设置为NULL。
·         如果使用LEFT JOIN找出在某些表中不存在的行，并且进行了下面的测试：WHERE部分的col_name IS NULL，其中col_name是一个声明为 NOT NULL的列，MySQL找到匹配LEFT JOIN条件的一个行后停止(为具体的关键字组合)搜索其它行。
RIGHT JOIN的执行类似LEFT JOIN，只是表的角色反过来。
联接优化器计算表应联接的顺序。LEFT JOIN和STRAIGHT_JOIN强制的表读顺序可以帮助联接优化器更快地工作，因为检查的表交换更少。请注意这说明如果执行下面类型的查询，MySQL进行全扫描b，因为LEFT JOIN强制它在d之前读取：
SELECT *
    FROM a,b LEFT JOIN c ON (c.key=a.key) LEFT JOIN d ON (d.key=a.key)
    WHERE b.key=d.key;
在这种情况下修复时用a的相反顺序，b列于FROM子句中：
SELECT *
    FROM b,a LEFT JOIN c ON (c.key=a.key) LEFT JOIN d ON (d.key=a.key)
    WHERE b.key=d.key;
MySQL可以进行下面的LEFT JOIN优化：如果对于产生的NULL行，WHERE条件总为假，LEFT JOIN变为普通联接。
例如，在下面的查询中如果t2.column1为NULL，WHERE 子句将为false：
SELECT * FROM t1 LEFT JOIN t2 ON (column1) WHERE t2.column2=5;
因此，可以安全地将查询转换为普通联接：
SELECT * FROM t1, t2 WHERE t2.column2=5 AND t1.column1=t2.column1;
这样可以更快，因为如果可以使查询更佳，MySQL可以在表t1之前使用表t2。为了强制使用表顺序，使用STRAIGHT_JOIN。
7.2.10. MySQL如何优化嵌套Join
表示联接的语法允许嵌套联接。下面的讨论引用了13.2.7.1节，“JOIN语法”中描述的联接语法。
同SQL标准比较，table_factor语法已经扩展了。后者只接受table_reference，而不是括号内所列的。
table_reference项列表内的每个逗号等价于内部联接，这是一个保留扩展名。例如：
SELECT * FROM t1 LEFT JOIN (t2, t3, t4)
                 ON (t2.a=t1.a AND t3.b=t1.b AND t4.c=t1.c)
等价于：
SELECT * FROM t1 LEFT JOIN (t2 CROSS JOIN t3 CROSS JOIN t4)
                 ON (t2.a=t1.a AND t3.b=t1.b AND t4.c=t1.c)
在MySQL中，CROSS JOIN语法上等价于INNER JOIN (它们可以彼此代替。在标准SQL中，它们不等价。INNER JOIN结合ON子句使用；CROSS JOIN 用于其它地方。
总的来说，在只包含内部联接操作的联接表达式中可以忽略括号。删除括号并将操作组合到左侧后，联接表达式：
t1 LEFT JOIN (t2 LEFT JOIN t3 ON t2.b=t3.b OR t2.b IS NULL)
   ON t1.a=t2.a
转换为表达式：
(t1 LEFT JOIN t2 ON t1.a=t2.a) LEFT JOIN t3
    ON t2.b=t3.b OR t2.b IS NULL
但是这两个表达式不等效。要说明这点，假定表t1、t2和t3有下面的状态：
·         表t1包含行{1}、{2}
·         表t2包含行{1,101}
·         表t3包含行{101}
在这种情况下，第1个表达式返回包括行{1,1,101,101}、{2,NULL,NULL,NULL}的结果，第2个表达式返回行{1,1,101,101}、{2,NULL,NULL,101}：
mysql> SELECT *
    -> FROM t1
    ->      LEFT JOIN
    ->      (t2 LEFT JOIN t3 ON t2.b=t3.b OR t2.b IS NULL)
    ->      ON t1.a=t2.a;
+------+------+------+------+
| a    | a    | b    | b    |
+------+------+------+------+
|    1 |    1 |  101 |  101 |
|    2 | NULL | NULL | NULL |
+------+------+------+------+
 
mysql> SELECT *
    -> FROM (t1 LEFT JOIN t2 ON t1.a=t2.a)
    ->      LEFT JOIN t3
    ->      ON t2.b=t3.b OR t2.b IS NULL;
+------+------+------+------+
| a    | a    | b    | b    |
+------+------+------+------+
|    1 |    1 |  101 |  101 |
|    2 | NULL | NULL |  101 |
+------+------+------+------+
在下面的例子中，外面的联接操作结合内部联接操作使用：
t1 LEFT JOIN (t2，t3) ON t1.a=t2.a
该表达式不能转换为下面的表达式：
t1 LEFT JOIN t2 ON t1.a=t2.a，t3.
对于给定的表状态，第1个表达式返回行{1,1,101,101}、{2,NULL,NULL,NULL}，第2个表达式返回行{1,1,101,101}、{2,NULL,NULL,101}：
mysql> SELECT *
    -> FROM t1 LEFT JOIN (t2, t3) ON t1.a=t2.a;
+------+------+------+------+
| a    | a    | b    | b    |
+------+------+------+------+
|    1 |    1 |  101 |  101 |
|    2 | NULL | NULL | NULL |
+------+------+------+------+
 
mysql> SELECT *
    -> FROM t1 LEFT JOIN t2 ON t1.a=t2.a, t3;
+------+------+------+------+
| a    | a    | b    | b    |
+------+------+------+------+
|    1 |    1 |  101 |  101 |
|    2 | NULL | NULL |  101 |
+------+------+------+------+
因此，如果我们忽略联接表达式中的括号连同外面的联接操作符，我们会改变原表达式的结果。
更确切地说，我们不能忽视左外联接操作的右操作数和右联接操作的左操作数中的括号。换句话说，我们不能忽视外联接操作中的内表达式中的括号。可以忽视其它操作数中的括号(外部表的操作数)。
对于任何表t1、t2、t3和属性t2.b和t3.b的任何条件P，下面的表达式：
(t1,t2) LEFT JOIN t3 ON P(t2.b,t3.b)
等价于表达式 
t1，t2 LEFT JOIN t3 ON P(t2.b,t3.b)
如果联接表达式(join_table)中的联接操作的执行顺序不是从左到右，我们则应讨论嵌套的联接。这样，下面的查询：
SELECT * FROM t1 LEFT JOIN (t2 LEFT JOIN t3 ON t2.b=t3.b) ON t1.a=t2.a
  WHERE t1.a > 1
 
SELECT * FROM t1 LEFT JOIN (t2, t3) ON t1.a=t2.a
  WHERE (t2.b=t3.b OR t2.b IS NULL) AND t1.a > 1
联接表：
t2 LEFT JOIN t3 ON t2.b=t3.b
t2, t3
认为是嵌套的。第1个查询结合左联接操作则形成嵌套的联接，而在第二个查询中结合内联接操作形成嵌套联接。
在第1个查询中，括号可以忽略：联接表达式的语法结构与联接操作的执行顺序相同。但对于第2个查询，括号不能省略，尽管如果没有括号，这里的联接表达式解释不清楚。(在外部扩展语法中，需要第2个查询的(t2，t3)的括号，尽管从理论上对查询分析时不需要括号：这些查询的语法结构将仍然不清楚，因为LEFT JOIN和ON将充当表达式(t2,t3)的左、右界定符的角色)。
前面的例子说明了这些点：
·         对于只包含内联接(而非外联接)的联接表达式，可以删除括号。你可以移除括号并从左到右评估(或实际上，你可以按任何顺序评估表)。
·         总的来说，对外联接却不是这样。去除括号可能会更改结果。
·         总的来说，对外联接和内联接的结合，也不是这样。去除括号可能会更改结果。
含嵌套外联接的查询按含内联接的查询的相同的管道方式执行。更确切地说，利用了嵌套环联接算法。让我们回忆嵌套环联接执行查询时采用什么算法。
假定我们有一个如下形式的表T1、T2、T3的联接查询：
SELECT * FROM T1 INNER JOIN T2 ON P1(T1,T2)
                 INNER JOIN T3 ON P2(T2,T3)
  WHERE P(T1,T2,T3).
这里，P1(T1,T2)和P2(T3,T3)是一些联接条件(表达式)，其中P(t1,t2,t3)是表T1、T2、T3的列的一个条件。
嵌套环联接算法将按下面的方式执行该查询：
 
FOR each row t1 in T1 {
  FOR each row t2 in T2 such that P1(t1,t2) {
    FOR each row t3 in T3 such that P2(t2,t3) {
      IF P(t1,t2,t3) {
         t:=t1||t2||t3; OUTPUT t;
      }
    }
  }
}
符号t1||t2||t3表示“连接行t1、t2和t3的列组成的行”。在下面的一些例子中，出现行名的NULL表示NULL用于行的每个列。例如，t1||t2||NULL表示“连接行t1和t2的列以及t3的每个列的NULL组成的行”。
现在让我们考虑带嵌套的外联接的查询：
SELECT * FROM T1 LEFT JOIN
              (T2 LEFT JOIN T3 ON P2(T2,T3))
              ON P1(T1,T2)
  WHERE P(T1,T2,T3)。
对于该查询我们修改嵌套环模式可以得到：
FOR each row t1 in T1 {
  BOOL f1:=FALSE;
  FOR each row t2 in T2 such that P1(t1,t2) {
    BOOL f2:=FALSE;
    FOR each row t3 in T3 such that P2(t2,t3) {
      IF P(t1,t2,t3) {
        t:=t1||t2||t3; OUTPUT t;
      }
      f2=TRUE;
      f1=TRUE;
    }
    IF (!f2) {
      IF P(t1,t2,NULL) {
        t:=t1||t2||NULL; OUTPUT t;
      }
      f1=TRUE;
    }
  }
  IF (!f1) {
    IF P(t1,NULL,NULL) {
      t:=t1||NULL||NULL; OUTPUT t;
    }
  }
}
 
总的来说，对于外联接操作中的第一个内表的嵌套环，引入了一个标志，在环之前关闭并且在环之后打开。如果对于外部表的当前行，如果匹配表示内操作数的表，则标志打开。如果在循环结尾处标志仍然关闭，则对于外部表的当前行，没有发现匹配。在这种情况下，对于内表的列，应使用NULL值补充行。结果行被传递到输出进行最终检查或传递到下一个嵌套环，但只能在行满足所有嵌入式外联接的联接条件时。
在我们的例子中，嵌入了下面表达式表示的外联接表：
(T2 LEFT JOIN T3 ON P2(T2,T3))
请注意对于有内联接的查询，优化器可以选择不同的嵌套环顺序，例如：
FOR each row t3 in T3 {
  FOR each row t2 in T2 such that P2(t2,t3) {
    FOR each row t1 in T1 such that P1(t1,t2) {
      IF P(t1,t2,t3) {
         t:=t1||t2||t3; OUTPUT t;
      }
    }
  }
}
对于有外联接的查询，优化器可以只选择这样的顺序：外表的环优先于内表的环。这样，对于有外联接的查询，只可能有一种嵌套顺序。在下面的查询中，优化器将评估两个不同的嵌套：
SELECT * T1 LEFT JOIN (T2,T3) ON P1(T1,T2) AND P2(T1,T3)
  WHERE P(T1,T2,T3)
嵌套为：
FOR each row t1 in T1 {
  BOOL f1:=FALSE;
  FOR each row t2 in T2 such that P1(t1,t2) {
    FOR each row t3 in T3 such that P2(t1,t3) {
      IF P(t1,t2,t3) {
        t:=t1||t2||t3; OUTPUT t;
      }
      f1:=TRUE
    }
  }
  IF (!f1) {
    IF P(t1,NULL,NULL) {
      t:=t1||NULL||NULL; OUTPUT t;
    }
  }
}
和
FOR each row t1 in T1 {
  BOOL f1:=FALSE;
  FOR each row t3 in T3 such that P2(t1,t3) {
    FOR each row t2 in T2 such that P1(t1,t2) {
      IF P(t1,t2,t3) {
        t:=t1||t2||t3; OUTPUT t;
      }
      f1:=TRUE
    }
  }
  IF (!f1) {
    IF P(t1,NULL,NULL) {
      t:=t1||NULL||NULL; OUTPUT t;
    }
  }
}
在两个嵌套中，必须在外环中处理T1，因为它用于外联接中。T2和T3用于内联接中，因此联接必须在内环中处理。但是，因为该联接是一个内联接，T2和T3可以以任何顺序处理。
当讨论内联接嵌套环的算法时，我们忽略了部分详情，可能对查询执行的性能的影响会很大。我们没有提及所谓的“下推”条件。假定可以用连接公式表示我们的WHERE条件P(T1,T2,T3)：
P(T1,T2,T2) = C1(T1) AND C2(T2) AND C3(T3)。
在这种情况下，MySQL实际使用了下面的嵌套环方案来执行带内联接得到查询：
FOR each row t1 in T1 such that C1(t1) {
  FOR each row t2 in T2 such that P1(t1,t2) AND C2(t2)  {
    FOR each row t3 in T3 such that P2(t2,t3) AND C3(t3) {
      IF P(t1,t2,t3) {
         t:=t1||t2||t3; OUTPUT t;
      }
    }
  }
}
你会看见每个连接 C1(T1)，C2(T2)，C3(T3)被从最内部的环内推出到可以对它进行评估的最外的环中。如果C1(T1)是一个限制性很强的条件，下推条件可以大大降低从表T1传递到内环的行数。结果是查询大大加速。
对于有外联接的查询，只有查出外表的当前的行可以匹配内表后，才可以检查WHERE条件。这样，对内嵌套环下推的条件不能直接用于带外联接的查询。这里我们必须引入有条件下推前提，由遇到匹配后打开的标志保护。
对于带下面的外联接的例子
P(T1,T2,T3)=C1(T1) AND C(T2) AND C3(T3)
使用受保护的下推条件的嵌套环方案看起来应为：
FOR each row t1 in T1 such that C1(t1) {
  BOOL f1:=FALSE;
  FOR each row t2 in T2
      such that P1(t1,t2) AND (f1?C2(t2):TRUE) {
    BOOL f2:=FALSE;
    FOR each row t3 in T3
        such that P2(t2,t3) AND (f1&&f2?C3(t3):TRUE) {
      IF (f1&&f2?TRUE:(C2(t2) AND C3(t3))) {
        t:=t1||t2||t3; OUTPUT t;
      }
      f2=TRUE;
      f1=TRUE;
    }
    IF (!f2) {
      IF (f1?TRUE:C2(t2) && P(t1,t2,NULL)) {
        t:=t1||t2||NULL; OUTPUT t;
      }
      f1=TRUE;
    }
  }
  IF (!f1 && P(t1,NULL,NULL)) {
      t:=t1||NULL||NULL; OUTPUT t;
  }
}
总的来说，可以从联接条件（例如P1(T1,T2)和P(T2,T3)）提取下推前提。在这种情况下，下推前提也受一个标志保护，防止检查由相应外联接操作所产生的NULL-补充的行的断言。
请注意如果从判断式的WHERE条件推导出，根据从一个内表到相同嵌套联接的另一个表的关键字进行的访问被禁止。(在这种情况下，我们可以使用有条件关键字访问，但是该技术还未用于MySQL 5.1中）。
7.2.11. MySQL如何简化外部联合
在许多情况下，一个查询的FROM子句的表的表达式可以简化。
在分析阶段，带右外联接操作的查询被转换为只包含左联接操作的等效查询。总的来说，根据以下原则进行转换：
(T1, ...) RIGHT JOIN (T2,...) ON P(T1,...,T2,...) =
(T2, ...) LEFT JOIN (T1,...) ON P(T1,...,T2,...)
所有T1 INNER JOIN T2 ON P(T1,T2)形式的内联接表达式被替换为T1,T2、P(T1,T2)，并根据WHERE条件(或嵌入连接的联接条件，如果有)联接为一个连接。
当优化器为用外联接操作的联接查询评估方案时，它只考虑在访问内表之前访问外表的操作的方案。优化器选项受到限制，因为只有这样的方案允许我们用嵌套环机制执行带外联接操作的查询。
假定我们有一个下列形式的查询：
SELECT * T1 LEFT JOIN T2 ON P1(T1,T2)
  WHERE P(T1,T2) AND R(T2)
R(T2)大大减少了表T2中匹配的行数。如果我们这样执行查询，优化器将不会有其它选择，只能在访问表T2之前访问表T1，从而导致执行方案非常低。
幸运的是，如果WHERE条件拒绝null，MySQL可以将此类查询转换为没有外联接操作的查询。如果为该操作构建的NULL补充的行评估为FALSE或UNKNOWN，则该条件称为对于某个外联接操作拒绝null。
因此，对于该外联接：
T1 LEFT JOIN T2 ON T1.A=T2.A
类似下面的条件为拒绝null：
T2.B IS NOT NULL,
T2.B > 3,
T2.C <= T1.C,
T2.B < 2 OR T2.C > 1
类似下面的条件不为拒绝null：
T2.B IS NULL,
T1.B < 3 OR T2.B IS NOT NULL,
T1.B < 3 OR T2.B > 3
检查一个外联接操作的条件是否拒绝null的总原则很简单。以下情况下为拒绝null的条件：
·         形式为A IS NOT NULL，其中A是任何内表的一个属性
·         包含内表引用的判断式，当某个参量为NULL时评估为UNKNOWN
·         包含用于连接的拒绝null的条件的联合
·         拒绝null的条件的逻辑和
一个条件可以对于一个查询中的一个外联接操作为拒绝null的而对于另一个不为拒绝null的。在下面的查询中：
SELECT * FROM T1 LEFT JOIN T2 ON T2.A=T1.A
                 LEFT JOIN T3 ON T3.B=T1.B
  WHERE T3.C > 0
WHERE条件对于第2个外联接操作为拒绝null的但对于第1个不为拒绝null的。
如果WHERE条件对于一个查询中的一个外联接操作为拒绝null的，外联接操作被一个内联接操作代替。
例如，前面的查询被下面的查询代替：
SELECT * FROM T1 LEFT JOIN T2 ON T2.A=T1.A
                 INNER JOIN T3 ON T3.B=T1.B
  WHERE T3.C > 0
对于原来的查询，优化器将评估只与一个访问顺序T1、T2、T3兼容的方案。在替换的查询中，还考虑了访问顺序T3、T1、T2。
一个外联接操作的转化可以触发另一个的转化。这样，查询：
SELECT * FROM T1 LEFT JOIN T2 ON T2.A=T1.A
                 LEFT JOIN T3 ON T3.B=T2.B
  WHERE T3.C > 0
将首先转换为查询：
SELECT * FROM T1 LEFT JOIN T2 ON T2.A=T1.A
                 INNER JOIN T3 ON T3.B=T2.B
  WHERE T3.C > 0
该查询等效于查询：
SELECT * FROM (T1 LEFT JOIN T2 ON T2.A=T1.A), T3
  WHERE T3.C > 0 AND T3.B=T2.B
现在剩余的外联接操作也可以被一个内联接替换，因为条件T3.B=T2.B为拒绝null的，我们可以得到一个根本没有外联接的查询：
SELECT * FROM (T1 INNER JOIN T2 ON T2.A=T1.A), T3
  WHERE T3.C > 0 AND T3.B=T2.B
有时我们可以成功替换嵌入的外联接操作，但不能转换嵌入的外联接。下面的查询：
SELECT * FROM T1 LEFT JOIN
              (T2 LEFT JOIN T3 ON T3.B=T2.B)
              ON T2.A=T1.A
  WHERE T3.C > 0
被转换为：
SELECT * FROM T1 LEFT JOIN
              (T2 INNER JOIN T3 ON T3.B=T2.B)
              ON T2.A=T1.A
  WHERE T3.C > 0，
只能重新写为仍然包含嵌入式外联接操作的形式：
SELECT * FROM T1 LEFT JOIN
              (T2,T3)
              ON (T2.A=T1.A AND T3.B=T2.B)
  WHERE T3.C > 0。
如果试图转换一个查询中的嵌入式外联接操作，我们必须考虑嵌入式外联接的联接条件和WHERE条件。在下面的查询中：
SELECT * FROM T1 LEFT JOIN
              (T2 LEFT JOIN T3 ON T3.B=T2.B)
              ON T2.A=T1.A AND T3.C=T1.C
  WHERE T3.D > 0 OR T1.D > 0
WHERE条件对于嵌入式外联接不为拒绝null的，但嵌入式外联接T2.A=T1.A AND T3.C=T1.C的联接条件为拒绝null的。因此该查询可以转换为：
SELECT * FROM T1 LEFT JOIN
              (T2, T3)
              ON T2.A=T1.A AND T3.C=T1.C AND T3.B=T2.B
  WHERE T3.D > 0 OR T1.D > 0
7.2.12. MySQL如何优化ORDER BY
在某些情况中，MySQL可以使用一个索引来满足ORDER BY子句，而不需要额外的排序。
即使ORDER BY不确切匹配索引，只要WHERE子句中的所有未使用的索引部分和所有额外的ORDER BY 列为常数，就可以使用索引。下面的查询使用索引来解决ORDER BY部分：
SELECT * FROM t1 
    ORDER BY key_part1,key_part2,... ;
    
SELECT * FROM t1 
    WHERE key_part1=constant 
    ORDER BY key_part2;
    
SELECT * FROM t1 
    ORDER BY key_part1 DESC, key_part2 DESC;
    
SELECT * FROM t1
    WHERE key_part1=1 
    ORDER BY key_part1 DESC, key_part2 DESC;
在某些情况下，MySQL不能使用索引来解决ORDER BY，尽管它仍然使用索引来找到匹配WHERE子句的行。这些情况包括：
·         对不同的关键字使用ORDER BY：
·                SELECT * FROM t1 ORDER BY key1, key2；
·         对关键字的非连续元素使用ORDER BY：
·                SELECT * FROM t1 WHERE key2=constant ORDER BY key_part2；
·         混合ASC和DESC：
·                SELECT * FROM t1 ORDER BY key_part1 DESC, key_part2 ASC；
·         用于查询行的关键字与ORDER BY中所使用的不相同：
·                SELECT * FROM t1 WHERE key2=constant ORDER BY key1；
·         你正联接许多表，并且ORDER BY中的列并不是全部来自第1个用于搜索行的非常量表。(这是EXPLAIN输出中的没有const联接类型的第1个表）。
·         有不同的ORDER BY和GROUP BY表达式。
·         使用的表索引的类型不能按顺序保存行。例如，对于HEAP表的HASH索引情况即如此。
通过EXPLAIN SELECT ...ORDER BY，可以检查MySQL是否可以使用索引来解决查询。如果Extra列内有Using filesort，则不能解决查询。参见7.2.1节，“EXPLAIN语法（获取关于SELECT的信息）”。
文件排序优化不仅用于记录排序关键字和行的位置，并且还记录查询需要的列。这样可以避免两次读取行。文件排序算法的工作象这样：
1.    读行匹配WHERE子句的行，如前面所示。
2.    对于每个行，记录构成排序关键字和行位置的一系列值，并且记录查询需要的列。
3.    根据排序关键字排序元组
4.    按排序的顺序检索行，但直接从排序的元组读取需要的列，而不是再一次访问表。
该算法比以前版本的Mysql有很大的改进。
为了避免速度变慢，该优化只用于排序元组中的extra列的总大小不超过max_length_for_sort_data系统变量值的时候。(将该变量设置得太高的的迹象是将看到硬盘活动太频繁而CPU活动较低）。 
如果想要增加ORDER BY的速度，首先看是否可以让MySQL使用索引而不是额外的排序阶段。如果不能，可以尝试下面的策略：
·         增加sort_buffer_size变量的大小。
·         增加read_rnd_buffer_size变量的大小。
·         更改tmpdir指向具有大量空闲空间的专用文件系统。该选项接受几个使用round-robin(循环)模式的路径。在Unix中路径应用冒号(‘:’)区间开，在Windows、NetWare和OS/2中用分号(‘；’)。可以使用该特性将负载均分到几个目录中。注释：路径应为位于不同物理硬盘上的文件系统的目录，而不是同一硬盘的不同的分区。
默认情况下，MySQL排序所有GROUP BY col1，col2，...查询的方法如同在查询中指定ORDER BY col1，col2，...。如果显式包括一个包含相同的列的ORDER BY子句，MySQL可以毫不减速地对它进行优化，尽管仍然进行排序。如果查询包括GROUP BY但你想要避免排序结果的消耗，你可以指定ORDER BY NULL禁止排序。例如：
INSERT INTO foo
SELECT a, COUNT(*) FROM bar GROUP BY a ORDER BY NULL;
7.2.13. MySQL如何优化GROUP BY
7.2.13.1. 松散索引扫描 
7.2.13.2. 紧凑索引扫描
满足GROUP BY子句的最一般的方法是扫描整个表并创建一个新的临时表，表中每个组的所有行应为连续的，然后使用该临时表来找到组并应用累积函数(如果有)。在某些情况中，MySQL能够做得更好，通过索引访问而不用创建临时表。
为GROUP BY使用索引的最重要的前提条件是 所有GROUP BY列引用同一索引的属性，并且索引按顺序保存其关键字(例如，这是B-树索引，而不是HASH索引)。是否用索引访问来代替临时表的使用还取决于在查询中使用了哪部分索引、为该部分指定的条件，以及选择的累积函数。
有两种方法通过索引访问执行GROUP BY查询，如下面的章节所描述。在第1个方法中，组合操作结合所有范围判断式使用(如果有)。第2个方法首先执行范围扫描，然后组合结果元组。
7.2.13.1. 松散索引扫描
使用索引时最有效的途径是直接搜索组域。通过该访问方法，MySQL使用某些关键字排序的索引类型(例如，B-树)的属性。该属性允许使用 索引中的查找组而不需要考虑满足所有WHERE条件的索引中的所有关键字。既然该访问方法只考虑索引中的关键字的一小部分，它被称为松散索引扫描。如果没有WHERE子句， 松散索引扫描读取的关键字数量与组数量一样多，可以比所有关键字数小得多。如果WHERE子句包含范围判断式(关于range联接类型的讨论参见7.2.1节，“EXPLAIN语法（获取关于SELECT的信息）”)， 松散索引扫描查找满足范围条件的每个组的第1个关键字，并且再次读取尽可能最少数量的关键字。在下面的条件下是可以的：
·         查询针对一个单表。
·         GROUP BY包括索引的第1个连续部分(如果对于GROUP BY，查询有一个DISTINCT子句，则所有显式属性指向索引开头)。
·         只使用累积函数(如果有)MIN()和MAX()，并且它们均指向相同的列。
·         索引的任何其它部分（除了那些来自查询中引用的GROUP BY）必须为常数(也就是说，必须按常量数量来引用它们)，但MIN()或MAX() 函数的参数例外。
此类查询的EXPLAIN输出显示Extra列的Using indexforgroup-by。
下面的查询提供该类的几个例子，假定表t1(c1,c2,c3,c4)有一个索引idx(c1，c2，c3)：
SELECT c1, c2 FROM t1 GROUP BY c1, c2;
SELECT DISTINCT c1, c2 FROM t1;
SELECT c1, MIN(c2) FROM t1 GROUP BY c1;
SELECT c1, c2 FROM t1 WHERE c1 < const GROUP BY c1, c2;
SELECT MAX(c3), MIN(c3), c1, c2 FROM t1 WHERE c2 > const GROUP BY c1, c2;
SELECT c2 FROM t1 WHERE c1 < const GROUP BY c1, c2;
SELECT c1, c2 FROM t1 WHERE c3 = const GROUP BY c1, c2；
由于上述原因，不能用该快速选择方法执行下面的查询：
1.      除了MIN()或MAX()，还有其它累积函数，例如：
     SELECT c1, SUM(c2) FROM t1 GROUP BY c1;
2.      GROUP BY子句中的域不引用索引开头，如下所示：
     SELECT c1,c2 FROM t1 GROUP BY c2, c3;
3.      查询引用了GROUP BY部分后面的关键字的一部分，并且没有等于常量的等式，例如：
     SELECT c1,c3 FROM t1 GROUP BY c1, c2；
7.2.13.2. 紧凑索引扫描
紧凑式索引扫描可以为索引扫描或一个范围索引扫描，取决于查询条件。
如果不满足松散索引扫描条件，GROUP BY查询仍然可以不用创建临时表。如果WHERE子句中有范围条件，该方法只读取满足这些条件的关键字。否则，进行索引扫描。该方法读取由WHERE子句定义的每个范围的所有关键字，或没有范围条件式扫描整个索引，我们将它定义为紧凑式索引扫描。请注意对于紧凑式索引扫描，只有找到了满足范围条件的所有关键字后才进行组合操作。
要想让该方法工作，对于引用GROUP BY关键字元素的前面、中间关键字元素的查询中的所有列，有一个常量等式条件即足够了。等式条件中的常量填充了搜索关键字中的“差距”，可以形成完整的索引前缀。这些索引前缀可以用于索引查找。如果需要排序GROUP BY结果，并且能够形成索引前缀的搜索关键字，MySQL还可以避免额外的排序操作，因为使用有顺序的索引的前缀进行搜索已经按顺序检索到了所有关键字。
上述的第一种方法不适合下面的查询，但第2种索引访问方法可以工作(假定我们已经提及了表t1的索引idx)：
·         GROUP BY中有一个差距，但已经由条件c2 = 'a'覆盖。
     SELECT c1，c2，c3 FROM t1 WHERE c2 = 'a' GROUP BY c1，c3;
·         GROUP BY不以关键字的第1个元素开始，但是有一个条件提供该元素的常量：
     SELECT c1，c2，c3 FROM t1 WHERE c1 = 'a' GROUP BY c2，c3;
7.2.14. MySQL如何优化LIMIT
在一些情况中，当你使用LIMIT row_count而不使用HAVING时，MySQL将以不同方式处理查询。
·         如果你用LIMIT只选择一些行，当MySQL选择做完整的表扫描时，它将在一些情况下使用索引。
·         如果你使用LIMIT row_count与ORDER BY，MySQL一旦找到了排序结果的第一个row_count行，将结束排序而不是排序整个表。如果使用索引，将很快。如果必须进行文件排序（filesort），必须选择所有匹配查询没有LIMIT子句的行，并且在确定已经找到第1个row_count行前，必须对它们的大部分进行排序。在任何一种情况下，一旦找到了行，则不需要再排序结果的其它部分，并且MySQL不再进行排序。
·         当结合LIMIT row_count和DISTINCT时，MySQL一旦找到row_count个唯一的行，它将停止。
·         在一些情况下，GROUP BY能通过顺序读取键(或在键上做排序)来解决，然后计算摘要直到关键字的值改变。在这种情况下，LIMIT row_count将不计算任何不必要的GROUP BY值。
·         只要MySQL已经发送了需要的行数到客户，它将放弃查询，除非你正使用SQL_CALC_FOUND_ROWS。
·         LIMIT 0将总是快速返回一个空集合。这对检查查询的有效性是有用的。当使用MySQL API时，它也可以用来得到结果列的列类型。(该技巧在MySQL Monitor中不工作，只显示Empty set；应使用SHOW COLUMNS或DESCRIBE）。 
·         当服务器使用临时表来进行查询时，使用LIMIT row_count子句来计算需要多少空间。
7.2.15. 如何避免表扫描
EXPLAIN的输出显示了当MySQL使用表扫描来解决查询时使用的所有类型列。这通常在如下条件下发生：
·         表很小，扫描表比查找关键字速度快。这对于少于10行并且行较短的表比较普遍。
·         在ON或WHERE子句中没有适用的索引列的约束。
·         正用常量值比较索引列，并且MySQL已经计算到(基于索引树)常数覆盖了表的很大部分并且表扫描将会比较快。参见7.2.4节，“MySQL怎样优化WHERE子句”。
·         你正通过另一个列使用一个低的集的势的关键字(许多行匹配关键字)。在这种情况下，MySQL假设通过使用关键字它可能会进行许多关键字查找，表扫描将会更快。
对于小表，表扫描通常合适。对于大表，尝试下面的技巧以避免优化器错选了表扫描：
·         使用ANALYZE TABLE tbl_name为扫描的表更新关键字分布。参见13.5.2.1节，“ANALYZE TABLE语法”。
·         对扫描的表使用FORCE INDEX告知MySQL，相对于使用给定的索引表扫描将非常耗时。参见13.2.7节，“SELECT语法”。
·                SELECT * FROM t1, t2 FORCE INDEX (index_for_column)
·                    WHERE t1.col_name=t2.col_name；
·         用--max-seeks-for-key=1000选项启动mysqld或使用SET max_seeks_for_key=1000告知优化器假设关键字扫描不会超过1,000次关键字搜索。参见5.3.3节，“服务器系统变量”。
7.2.16. INSERT语句的速度
插入一个记录需要的时间由下列因素组成，其中的数字表示大约比例：
连接：(3) 
发送查询给服务器：(2) 
分析查询：(2) 
插入记录：（1x记录大小） 
插入索引：（1x索引） 
关闭：(1) 
这不考虑打开表的初始开销，每个并发运行的查询打开。
表的大小以logN (B树)的速度减慢索引的插入。
加快插入的一些方法：
·         如果同时从同一个客户端插入很多行，使用含多个VALUE的INSERT语句同时插入几行。这比使用单行INSERT语句快(在某些情况下快几倍)。如果你正向一个非空表添加数据，可以调节bulk_insert_buffer_size变量，使数据插入更快。参见5.3.3节，“服务器系统变量”。
·         如果你从不同的客户端插入很多行，能通过INSERT DELAYED语句加快速度。参见13.2.4节，“INSERT语法”。
·         用MyISAM，如果在表中没有删除的行，能在SELECT语句正在运行的同时插入行。
·         当从一个文本文件装载一个表时，使用LOAD DATA INFILE。这通常比使用很多INSERT语句快20倍。参见13.2.5节，“LOAD DATA INFILE语法”。
·         当表有很多索引时，有可能要多做些工作使得LOAD DATA INFILE更快些。使用下列过程：
1. 有选择地用CREATE TABLE创建表。 
2. 执行FLUSH TABLES语句或命令mysqladmin flush-tables。 
3. 使用myisamchk --keys-used=0 -rq /path/to/db/tbl_name。这将从表中取消所有索引的使用。 
4. 用LOAD DATA INFILE把数据插入到表中，因为不更新任何索引，因此很快。 
5. 如果只想在以后读取表，使用myisampack压缩它。参见15.1.3.3节，“压缩表特性”。 
6. 用myisamchk -r -q /path/to/db/tbl_name重新创建索引。这将在写入磁盘前在内存中创建索引树，并且它更快，因为避免了大量磁盘搜索。结果索引树也被完美地平衡。 
7. 执行FLUSH TABLES语句或mysqladmin flush-tables命令。 
请注意如果插入一个空MyISAM表，LOAD DATA INFILE也可以执行前面的优化；主要不同处是可以让myisamchk为创建索引分配更多的临时内存，比执行LOAD DATA INFILE语句时为服务器重新创建索引分配得要多。
也可以使用ALTER TABLE tbl_name DISABLE KEYS代替myisamchk --keys-used=0 -rq /path/to/db/tbl_name，使用ALTER TABLE tbl_name ENABLE KEYS代替myisamchk -r -q /path/to/db/tbl_name。使用这种方式，还可以跳过FLUSH TABLES。
·         锁定表可以加速用多个语句执行的INSERT操作：
LOCK TABLES a WRITE; 
INSERT INTO a VALUES (1,23),(2,34),(4,33); 
INSERT INTO a VALUES (8,26),(6,29); 
UNLOCK TABLES; 
这样性能会提高，因为索引缓存区仅在所有INSERT语句完成后刷新到磁盘上一次。一般有多少INSERT语句即有多少索引缓存区刷新。如果能用一个语句插入所有的行，就不需要锁定。
对于事务表，应使用BEGIN和COMMIT代替LOCK TABLES来加快插入。
锁定也将降低多连接测试的整体时间，尽管因为它们等候锁定最大等待时间将上升。例如：
Connection 1 does 1000 inserts
Connections 2, 3, and 4 do 1 insert
Connection 5 does 1000 inserts
如果不使用锁定，2、3和4将在1和5前完成。如果使用锁定，2、3和4将可能不在1或5前完成，但是整体时间应该快大约40%。
INSERT、UPDATE和DELETE操作在MySQL中是很快的，通过为在一行中多于大约5次连续不断地插入或更新的操作加锁，可以获得更好的整体性能。如果在一行中进行多次插入，可以执行LOCK TABLES，随后立即执行UNLOCK TABLES(大约每1000行)以允许其它的线程访问表。这也会获得好的性能。
INSERT装载数据比LOAD DATA INFILE要慢得多，即使是使用上述的策略。
·         为了对LOAD DATA INFILE和INSERT在MyISAM表得到更快的速度，通过增加key_buffer_size系统变量来扩大 键高速缓冲区。参见7.5.2节，“调节服务器参数”。
 
7.2.17. UPDATE语句的速度
更新查询的优化同SELECT查询一样，需要额外的写开销。写速度依赖于更新的数据大小和更新的索引的数量。没有更改的索引不被更新。
使更改更快的另一个方法是推迟更改然后在一行内进行多次更新。如果锁定表，同时做多个更新比一次做一个快得多。
请注意对使用动态记录格式的MyISAM表，更新一个较长总长的记录可能会切分记录。如果经常这样该，偶尔使用OPTIMIZE TABLE很重要。参见13.5.2.5节，“OPTIMIZE TABLE语法”。
7.2.18. DELETE语句的速度
删除一个记录的时间与索引数量确切成正比。为了更快速地删除记录，可以增加键高速缓冲的大小。参见7.5.2节，“调节服务器参数”。
如果想要删除一个表的所有行，使用TRUNCATE TABLE tbl_name 而不要用DELETE FROM tbl_name。参见13.2.9节，“TRUNCATE语法”。
7.2.19. 其它优化技巧
该节列出了提高查询速度的各种技巧：
·         使用持久的连接数据库以避免连接开销。如果不能使用持久的连接并且你正启动许多新的与数据库的连接，可能要更改thread_cache_size变量的值。参见7.5.2节，“调节服务器参数”。
·         总是检查所有查询确实使用已经在表中创建了的索引。在MySQL中，可以用EXPLAIN命令做到。参见7.2.1节，“EXPLAIN语法（获取关于SELECT的信息）”。
·         尝试避免在频繁更新的表上执行复杂的SELECT查询，以避免与锁定表有关的由于读、写冲突发生的问题。
·         对于没有删除的行的MyISAM表，可以在另一个查询正从表中读取的同时在末尾插入行。如果这很重要，应考虑按照避免删除行的方式使用表。另一个可能性是在删除大量行后运行OPTIMIZE TABLE。参见15.1节，“MyISAM存储引擎”。
·         要修复任何ARCHIVE表可以发生的压缩问题，可以执行OPTIMIZE TABLE。参见15.8节，“ARCHIVE存储引擎”。
·         如果你主要按expr1，expr2，...顺序检索行，使用ALTER TABLE ... ORDER BY expr1, expr2, ...。对表大量更改后使用该选项，可以获得更好的性能。
·         在一些情况下，使得基于来自其它表的列的信息引入一个“ 哈希”的列有意义。如果该列较短并且有合理的唯一值，它可以比在许多列上的一个大索引快些。在MySQL中，很容易使用这个额外列：
·                SELECT * FROM tbl_name
·                     WHERE hash_col=MD5(CONCAT(col1,col2))
·                     AND col1='constant' AND col2='constant';
·         对于频繁更改的MyISAM表，应试图避免所有变长列(VARCHAR、BLOB和TEXT)。如果表包括单一的变长列则使用动态记录格式。参见第15章：存储引擎和表类型。
·         只是因为行太大，将一张表分割为不同的表一般没有什么用处。为了访问行，最大的性能冲击是磁盘搜索以找到行的第一个字节。在找到数据后，大多数新型磁盘对大多数应用程序来说足够快，能读入整个行。确实有必要分割的唯一情形是如果它是使用动态记录格式使之变为固定的记录大小的MyISAM表(见上述)，或如果你需要很频繁地扫描表而不需要大多数列。参见第15章：存储引擎和表类型。
·         如果你需要很经常地计算结果，例如基于来自很多行的信息的计数，引入一个新表并实时更新计数器可能更好一些。下面形式的更新会更快一些：
UPDATE tbl_name SET count_col=count_col+1 WHERE key_col=constant;
当你使用象MyISAM那样的只有表级锁定的MySQL存储引擎(多重读/单个写)时，这确实很重要。这也给大多数数据库较好的性能，因为行锁定管理器在这种情况下有较少的事情要做。
·         如果你需要从大的记录文件表中收集统计信息，使用总结性的表而不是扫描整个表。维护总结应该比尝试做“实时”统计要快些。当有变化时从日志重新生成新的总结表比改变运行的应用(取决于业务决策)要快得多。
如果可能，应该将报告分类为“实时”或“统计”，这里统计报告所需的数据仅仅基于从实际数据定期产生的总结表中产生。 
充分利用列有默认值的事实。只有当插入的值不同于默认值时，才明确地插入值。这减少MySQL需要做的语法分析从而提高插入速度。 
在一些情况下，包装并存储数据到一个BLOB列中是很方便的。在这种情况下，必须在你的应用中增加额外的代码来打包/解包信息，但是这种方法可以在某些阶段节省很多访问。当有不符合行和列表结构的数据时，这很实用。 
在一般情况下，应该尝试以非冗余方式(查看数据库理论中的第三正则形式)保存数据，但是为了获得更快的速度，可以复制信息或创建总结表。 
存储过程或UDF(用户定义函数)可能是获得更好性能的一个好方法，详细信息参见第20章：存储程序和函数和27.2节，“为MySQL添加新函数”。 
总是能通过在应用程序中缓存查询/答案并尝试同时执行很多插入/更新来获得一些好处。如果数据库支持锁定表(象MySQL和Oracle)，这应该有助于确保索引缓存只在所有更新后刷新一次。还可以利用MySQL的查询缓存来获得类似的结果；参见5.13节，“MySQL查询高速缓冲”。 
当不需要知道何时写入数据时，使用INSERT DELAYED。这样可以加快处理，因为很多记录可以通过一次磁盘写入被写入。 
当你想要让选择显得更重要时，使用INSERT /*! LOW_PRIORITY */。 
使用INSERT LOW_PRIORITY来取得插入队列的检索，也就是即使有另一个客户等待写入也要执行SELECT。 
使用多行INSERT语句通过一个SQL命令来存储很多行(许多SQL服务器支持它，包括MySQL)。 
使用LOAD DATA INFILE装载较大数量的数据。这比使用INSERT要快得多。 
使用AUTO_INCREMENT列构成唯一值。 
当MyISAM使用动态表格式时，偶尔使用OPTIMIZE TABLE可以避免碎片。参见15.1.3节，“MyISAM表的存储格式”。 
可能时使用MEMORY表以得到更快的速度。参见15.4节，“MEMORY (HEAP)存储引擎”。 
在Web服务器中，图象和其它二进制资产应该作为文件存储。也就是仅在数据库中存储的本文件的引用而不是文件本身。大多数Web服务器在缓存文件方面比数据库内容要好得多，因此使用文件一般要快得多。 
对经常访问的不重要数据(如为没有在Web 浏览器中启用cookie的用户最后显示的标语的相关信息)使用内存表。在许多Web应用程序环境中也可以使用用户会话来处理可变状态数据。 
在不同表中具有相同信息的列应该被声明为相同的并有相同的名字。尝试使名字简单化。例如，在customer表中使用name而不是customer_name。为了使名字能移植到其它SQL服务器，应该使名字短于18个字符。 
如果确实需要很高的速度，应该研究一下不同SQL服务器支持的数据存储的低层接口！例如直接访问MySQL MyISAM存储引擎，比起使用SQL接口，速度可以提高2-5倍。为了能实现，数据必须与应用程序在同一台服务器上，并且通常只应该被一个进程访问(因为外部文件锁定确实很慢)。通过在MySQL服务器中引进低层MyISAM命令能消除以上问题(如果需要，这可能是获得更好性能的一个简单的方法)。通过精心设计数据库接口，应该能相当容易地支持这类优化。 
如果正使用数字数据，在许多情况下，从一个数据库访问信息(使用实时连接)比访问一个文本文件快些。这是因为数据库中的信息比文本文件更紧凑，因此这将涉及更少的磁盘访问。还可以在应用程序中节省代码，因为不须分析文本文件来找出行和列的边界。 
·         通过复制可以提高某些操作的性能。可以在复制服务器中分布客户的检索以均分负载。为了防止备份时主服务器变慢，可以使用一个从服务器来备份。参见第6章：MySQL中的复制。
·         用DELAY_KEY_WRITE=1选项声明MyISAM表可以使索引更新更快，因为在表关闭之前它们不刷新到硬盘上。不利之处是当表打开时如果杀掉服务器，应确保用--myisam-recover选项运行服务器保证没有问题，或者在重启服务器之前运行myisamchk。(然而，即使在这种情况下，应通过使用DELAY_KEY_WRITE保证不丢失数据，因为关键字信息总是可以从数据行产生）。
 
7.3. 锁定事宜
7.3.1. 锁定方法 
7.3.2. 表锁定事宜
7.3.1. 锁定方法
MySQL 5.1支持对MyISAM和MEMORY表进行表级锁定，对BDB表进行页级锁定，对InnoDB表进行行级锁定。
在许多情况下，可以根据培训猜测应用程序使用哪类锁定类型最好，但一般很难说出某个给出的锁类型就比另一个好。一切取决于应用程序，应用程序的不同部分可能需要不同的锁类型。
为了确定是否想要使用行级锁定的存储引擎，应看看应用程序做什么并且混合使用什么样的选择和更新语句。例如，大多数Web应用程序执行许多选择，而很少进行删除，只对关键字的值进行更新，并且只插入少量具体的表。基本MySQL MyISAM设置已经调节得很好。
在MySQL中对于使用表级锁定的存储引擎，表锁定时不会死锁的。这通过总是在一个查询开始时立即请求所有必要的锁定并且总是以同样的顺序锁定表来管理。
对WRITE，MySQL使用的表锁定方法原理如下：
如果在表上没有锁，在它上面放一个写锁。 
否则，把锁定请求放在写锁定队列中。 
对READ，MySQL使用的锁定方法原理如下：
如果在表上没有写锁定，把一个读锁定放在它上面。 
否则，把锁请求放在读锁定队列中。 
当一个锁定被释放时，锁定可被写锁定队列中的线程得到，然后是读锁定队列中的线程。
这意味着，如果你在一个表上有许多更新，SELECT语句将等待直到没有更多的更新。
可以通过检查table_locks_waited和table_locks_immediate状态变量来分析系统上的表锁定争夺：
mysql> SHOW STATUS LIKE 'Table%';
+-----------------------+---------+
| Variable_name         | Value   |
+-----------------------+---------+
| Table_locks_immediate | 1151552 |
| Table_locks_waited    | 15324   |
+-----------------------+---------+
如果INSERT语句不冲突，可以自由为MyISAM表混合并行的INSERT和SELECT语句而不需要锁定。也就是说，你可以在其它客户正读取MyISAM表的时候插入行。如果数据文件中间不包含空闲块，不会发生冲突，因为在这种情况下，记录总是插入在数据文件的尾部。(从表的中部删除或更新的行可能导致空洞）。如果有空洞，当所有空洞填入新的数据时，并行的插入能够重新自动启用。
如果不能同时插入，为了在一个表中进行多次INSERT和SELECT操作，可以在临时表中插入行并且立即用临时表中的记录更新真正的表。
这可用下列代码做到：
mysql> LOCK TABLES real_table WRITE, insert_table WRITE;
mysql> INSERT INTO real_table SELECT * FROM insert_table;
mysql> TRUNCATE TABLE insert_table;
mysql> UNLOCK TABLES;
 
InnoDB使用行锁定，BDB使用页锁定。对于这两种存储引擎，都可能存在死锁。这是因为，在SQL语句处理期间，InnoDB自动获得行锁定和BDB获得页锁定，而不是在事务启动时获得。
行级锁定的优点：
·         当在许多线程中访问不同的行时只存在少量锁定冲突。
·         回滚时只有少量的更改。
·         可以长时间锁定单一的行。
行级锁定的缺点：
·         比页级或表级锁定占用更多的内存。
·         当在表的大部分中使用时，比页级或表级锁定速度慢，因为你必须获取更多的锁。
·         如果你在大部分数据上经常进行GROUP BY操作或者必须经常扫描整个表，比其它锁定明显慢很多。
·         用高级别锁定，通过支持不同的类型锁定，你也可以很容易地调节应用程序，因为其锁成本小于行级锁定。
在以下情况下，表锁定优先于页级或行级锁定：
·         表的大部分语句用于读取。
·         对严格的关键字进行读取和更新，你可以更新或删除可以用单一的读取的关键字来提取的一行：
·                UPDATE tbl_name SET column=value WHERE unique_key_col=key_value;
·                DELETE FROM tbl_name WHERE unique_key_col=key_value;
·         SELECT 结合并行的INSERT语句，并且只有很少的UPDATE或DELETE语句。
·         在整个表上有许多扫描或GROUP BY操作，没有任何写操作。
不同于行级或页级锁定的选项：
·         版本(例如，为并行的插入在MySQL中使用的技术)，其中可以一个写操作，同时有许多读取操作。这说明数据库或表支持数据依赖的不同视图，取决于访问何时开始。其它共同的术语是“时间跟踪”、“写复制”或者“按需复制”。
·         按需复制在许多情况下优先于页级或行级锁定。然而，在最坏的情况下，它可能比使用常规锁定使用更多的内存。
·         除了行级锁定外，你可以使用应用程序级锁定，例如在MySQL中使用GET_LOCK()和RELEASE_LOCK()。这些是建议性锁定，它们只能在运行良好的应用程序中工作。
7.3.2. 表锁定事宜
为达到最高锁定速度，除InnoDB和BDB之外，对所有存储引擎，MySQL使用表锁定(而不是页、行或者列锁定)。
对于InnoDB和BDB表，如果你用LOCK TABLES显式锁定表，MySQL只使用表锁定。对于这些表类型，我们建议你根本不要使用LOCK TABLES，因为InnoDB使用自动行级锁定而BDB使用页级锁定来保证事务隔离。
对于大表，对于大多数应用程序，表锁定比行锁定更好，但存在部分缺陷。
表锁定使许多线程同时从一个表中进行读取操作，但如果一个线程想要对表进行写操作，它必须首先获得独占访问。更新期间，所有其它想要访问该表的线程必须等待直到更新完成。
表更新通常情况认为比表检索更重要，因此给予它们更高的优先级。这应确保更新一个表的活动不能“饿死”，即使该表上有很繁重的SELECT活动。
表锁定在这种情况下会造成问题，例如当线程正等待，因为硬盘已满并且在线程可以处理之前必须有空闲空间。在这种情况下，所有想要访问出现问题的表的线程也被设置成等待状态，直到有更多的硬盘空间可用。
表锁定在下面的情况下也存在问题：
·         一个客户发出长时间运行的查询。
·         然后，另一个客户对同一个表进行更新。该客户必须等待直到SELECT完成。
·         另一个客户对同一个表上发出了另一个SELECT语句。因为UPDATE比SELECT优先级高，该SELECT语句等待UPDATE完成，并且等待第1个SELECT完成。
下面描述了一些方法来避免或减少表锁定造成的竞争：
·         试图使SELECT语句运行得更快。你可能必须创建一些摘要(summary)表做到这点。
·         用--low-priority-updates启动mysqld。这将给所有更新(修改)一个表的语句以比SELECT语句低的优先级。在这种情况下，在先前情形的第2个SELECT语句将在UPDATE语句前执行，而不需要等候第1个SELECT完成。
·         可以使用SET LOW_PRIORITY_UPDATES=1语句指定具体连接中的所有更新应使用低优先级。参见13.5.3节，“SET语法”
·         可以用LOW_PRIORITY属性给与一个特定的INSERT、UPDATE或DELETE语句较低优先级。
·         可以用HIGH_PRIORITY属性给与一个特定的SELECT语句较高优先级。参见13.2.7节，“SELECT语法”。
·         为max_write_lock_count系统变量指定一个低值来启动mysqld来强制MySQL在具体数量的插入完成后临时提高所有等待一个表的SELECT语句的优先级。这样允许在一定数量的WRITE锁定后给出READ锁定。
·         如果你有关于INSERT结合SELECT的问题，切换到使用新的MyISAM表，因为它们支持并发的SELECT和INSERT。
·         如果你对同一个表混合插入和删除，INSERT DELAYED将会有很大的帮助。参见13.2.4.2节，“INSERT DELAYED语法”。
·         如果你对同一个表混合使用SELECT和DELETE语句出现问题，DELETE的LIMIT选项可以有所帮助。参见13.2.1节，“DELETE语法”。
·         对SELECT语句使用SQL_BUFFER_RESULT可以帮助使表锁定时间变短。参见13.2.7节，“SELECT语法”。
·         可以更改mysys/thr_lock.c中的锁代码以使用单一的队列。在这种情况下，写锁定和读锁定将具有相同的优先级，对一些应用程序会有帮助。
这里是一些MySQL中表锁定相关的技巧：
·         如果不混合更新与需要在同一个表中检查许多行的选择，可以进行并行操作。
·         可以使用LOCK TABLES来提高速度，因为在一个锁定中进行许多更新比没有锁定的更新要快得多。将表中的内容切分为几个表也可以有所帮助。
·         如果在MySQL中表锁定时遇到速度问题，可以将你的表转换为InnoDB或BDB表来提高性能。参见15.2节，“InnoDB存储引擎”和15.5节，“BDB (BerkeleyDB)存储引擎”。
7.4. 优化数据库结构
7.4.1. 设计选择 
7.4.2. 使你的数据尽可能小 
7.4.3. 列索引 
7.4.4. 多列索引 
7.4.5. MySQL如何使用索引 
7.4.6. MyISAM键高速缓冲 
7.4.7. MyISAM索引统计集合 
7.4.8. MySQL如何计算打开的表 
7.4.9. MySQL如何打开和关闭表 
7.4.10. 在同一个数据库中创建多个表的缺陷
7.4.1. 设计选择
MySQL将行数据和索引数据保存在不同的文件中。许多(几乎所有)其它数据库将行数据和索引数据混合保存在用一个文件中。我们认为MySQL 选择对广范围的现代系统更好一些。
保存行数据的另一种方式是将每个列的信息保存在单独的区域(例如SDBM和Focus)。这样会对每个访问多个列的查询造成性能问题。因为当访问多个列时退化得很快，我们认为该模型对一般数据库不合适。
更常见的情形是索引和数据保存在一起(例如Oracle/Sybase)。在这种情况下，你可以在索引的叶级页找到行的信息。该布局比较好的事情是在许多情况下，根据索引缓存得怎样，可以保存一个硬盘读取。该布局的不利之处表现在：
·         表扫描要慢得多，因为你必须通读索引以获得数据。
·         你不能只使用表来检索查询的数据。
·         你需要使用更多的空间，因为你必须从节点复制索引(你不能保存节点上的行)。
·         删除要经过一段时间后才退化表(因为删除时通常不会更新节点上的索引)。
·         只缓存索引数据会更加困难。
7.4.2. 使你的数据尽可能小
最基本的优化之一是使表在磁盘上占据的空间尽可能小。这能给出巨大的改进，因为磁盘读入较快，并且在查询执行过程中小表的内容被处理时占用较少的主存储器。如果在更小的列上做索引，索引也占据较少的资源。
MySQL支持许多不同的存储引擎(表类型)和行格式。对于每个表，可以确定使用哪个存储引擎和索引方法。为应用程序选择合适的表格式可以大大提高性能。参见第15章：存储引擎和表类型。
可以使用下面的技术可以使表的性能更好并且使存储空间最小：
尽可能地使用最有效(最小)的数据类型。MySQL有很多节省磁盘空间和内存的专业化类型。 
尽可能使用较小的整数类型使表更小。例如，MEDIUMINT经常比INT好一些，因为MEDIUMINT列使用的空间要少25%。 
如果可能，声明列为NOT NULL。它使任何事情更快而且每列可以节省一位。注意如果在应用程序中确实需要NULL，应该毫无疑问使用它，只是避免 默认地在所有列上有它。 
对于MyISAM表，如果没有任何变长列(VARCHAR、TEXT或BLOB列)，使用固定尺寸的记录格式。这比较快但是不幸地可能会浪费一些空间。参见15.1.3节，“MyISAM表的存储格式”。即使你已经用CREATE选项让VARCHAR列ROW_FORMAT=fixed，也可以提示想使用固定长度的行。 
在MySQL/InnoDB中，InnoDB表使用更紧凑的存储格式。在以前版本的MySQL中，InnoDB记录包含一些冗余信息，例如列数目和每个列的长度，即使对于固定大小的列。默认情况，创建的表为紧凑格式(ROW_FORMAT=COMPACT)。如果想要降级旧版本的MySQL/InnoDB，可以用ROW_FORMAT=REDUNDANT要求旧的格式。 
紧凑的InnoDB格式也改变了包含UTF-8数据的CHAR列的保存方式。在ROW_FORMAT=REDUNDANT格式中，UTF-8 CHAR(n)占用3*n字节，假定UTF-8编码的字符的最大长度是3字节。许多语言可以主要用单字节UTF-8字符来编写，固定的存储长度通常会浪费空间。通过根据需要剥离尾部的空格，ROW_FORMAT=COMPACT格式为这些列分配可变数量的n..3*n字节。最小存储长度按顺序保存为n字节，以在典型情况下帮助更新。 
每张表的主索引应该尽可能短。这使一行的识别容易而有效。 
只创建你确实需要的索引。索引对检索有好处，但是当你需要快速存储东西时就变得糟糕。如果主要通过搜索列的组合来存取一个表，对它们做一个索引。第一个索引部分应该是最常用的列。如果从表中选择时总是使用许多列，应该首先以更多的副本使用列以获得更好的索引压缩。 
如果很可能一个索引在头几个字符上有唯一的前缀，仅仅索引该前缀比较好。MySQL支持对一个字符列的最左边部分创建一个索引(参见13.1.4节，“CREATE INDEX语法”)。更短的索引会更快，不仅因为它们占较少的磁盘空间，而且因为它们将在索引缓存中提供更多的访问，因此磁盘搜索更少。参见7.5.2节，“调节服务器参数”。 
·         在一些情形下，将一个经常被扫描的表分割为2个表是有益的。特别是如果它是一个动态格式的表，并且可能使用一个扫描表时能用来找出相关行的较小静态格式的表。
7.4.3. 列索引
所有MySQL列类型可以被索引。对相关列使用索引是提高SELECT操作性能的最佳途径。
根据存储引擎定义每个表的最大索引数和最大索引长度。参见第15章：存储引擎和表类型。所有存储引擎支持每个表至少16个索引，总索引长度至少为256字节。大多数存储引擎有更高的限制。
在索引定义中用col_name(length)语法，你可以创建一个只使用CHAR或VARCHAR列的第1个length字符的索引。按这种方式只索引列值的前缀可以使索引文件小得多。
MyISAM和InnoDB存储引擎还支持对BLOB和TEXT列的索引。当索引一个BLOB或TEXT列时，你必须为索引指定前缀长度。例如：
CREATE TABLE test (blob_col BLOB, INDEX(blob_col(10)));
在MySQL 5.1中，对于MyISAM和InnoDB表，前缀可以达到1000字节长。请注意前缀的限制应以字节为单位进行测量，而CREATE TABLE语句中的前缀长度解释为字符数。当为使用多字节字符集的列指定前缀长度时一定要加以考虑。
还可以创建FULLTEXT索引。该索引可以用于全文搜索。只有MyISAM存储引擎支持FULLTEXT索引，并且只为CHAR、VARCHAR和TEXT列。索引总是对整个列进行，不支持局部(前缀)索引。详情参见12.7节，“全文搜索功能”。
也可以为空间列类型创建索引。只有MyISAM存储引擎支持空间类型。空间索引使用R-树。
默认情况MEMORY(HEAP)存储引擎使用hash索引，但也支持B-树索引。
7.4.4. 多列索引
MySQL可以为多个列创建索引。一个索引可以包括15个列。对于某些列类型，可以索引列的前缀(参见7.4.3节，“列索引”)。
多列索引可以视为包含通过连接索引列的值而创建的值的排序的数组。
MySQL按这样的方式使用多列索引：当你在WHERE子句中为索引的第1个列指定已知的数量时，查询很快，即使你没有指定其它列的值。
假定表具有下面的结构：
CREATE TABLE test (
    id INT NOT NULL,
    last_name CHAR(30) NOT NULL,
    first_name CHAR(30) NOT NULL,
    PRIMARY KEY (id),
    INDEX name (last_name,first_name)
);
name索引是一个对last_name和first_name的索引。索引可以用于为last_name，或者为last_name和first_name在已知范围内指定值的查询。因此，name索引用于下面的查询：
SELECT * FROM test WHERE last_name='Widenius';
 
SELECT * FROM test
    WHERE last_name='Widenius' AND first_name='Michael';
 
SELECT * FROM test
    WHERE last_name='Widenius'
    AND (first_name='Michael' OR first_name='Monty');
 
SELECT * FROM test
    WHERE last_name='Widenius'
    AND first_name >='M' AND first_name < 'N';
然而，name索引不用于下面的查询：
SELECT * FROM test WHERE first_name='Michael';
 
SELECT * FROM test
    WHERE last_name='Widenius' OR first_name='Michael';
MySQL使用索引提高查询性能的方式将在7.4.5节，“MySQL如何使用索引”中讨论。
7.4.5. MySQL如何使用索引
索引用于快速找出在某个列中有一特定值的行。不使用索引，MySQL必须从第1条记录开始然后读完整个表直到找出相关的行。表越大，花费的时间越多。如果表中查询的列有一个索引，MySQL能快速到达一个位置去搜寻到数据文件的中间，没有必要看所有数据。如果一个表有1000行，这比顺序读取至少快100倍。注意如果你需要访问大部分行，顺序读取要快得多，因为此时我们避免磁盘搜索。
大多数MySQL索引(PRIMARY KEY、UNIQUE、INDEX和FULLTEXT)在B树中存储。只是空间列类型的索引使用R-树，并且MEMORY表还支持hash索引。
字符串自动地压缩前缀和结尾空格。参见13.1.4节，“CREATE INDEX语法”。
总的来说，按后面的讨论使用索引。本节最后描述hash索引(用于MEMORY表)的特征。
索引用于下面的操作：
·         快速找出匹配一个WHERE子句的行。
·         删除行。如果可以在多个索引中进行选择，MySQL通常使用找到最少行的索引。
·         当执行联接时，从其它表检索行。
·         对具体有索引的列key_col找出MAX()或MIN()值。由预处理器进行优化，检查是否对索引中在key_col之前发生所有关键字元素使用了WHERE key_part_# = constant。在这种情况下，MySQL为每个MIN()或MAX()表达式执行一次关键字查找，并用常数替换它。如果所有表达式替换为常量，查询立即返回。例如：
·                SELECT MIN(key_part2),MAX(key_part2)
·                    FROM tbl_name WHERE key_part1=10;
·         如果对一个可用关键字的最左面的前缀进行了排序或分组(例如，ORDER BY key_part_1,key_part_2)，排序或分组一个表。如果所有关键字元素后面有DESC，关键字以倒序被读取。参见7.2.12节，“MySQL如何优化ORDER BY”。
·         在一些情况中，可以对一个查询进行优化以便不用查询数据行即可以检索值。如果查询只使用来自某个表的数字型并且构成某些关键字的最左面前缀的列，为了更快，可以从索引树检索出值。
·                SELECT key_part3 FROM tbl_name
·                    WHERE key_part1=1
假定你执行下面的SELECT语句：
mysql> SELECT * FROM tbl_name WHERE col1=val1 AND col2=val2;
如果col1和col2上存在一个多列索引，可以直接取出相应行。如果col1和col2上存在单列索引，优化器试图通过决定哪个索引将找到更少的行来找出更具限制性的索引并且使用该索引取行。
如果表有一个多列索引，优化器可以使用最左面的索引前缀来找出行。例如，如果有一个3列索引(col1,col2,col3)，则已经对(col1)、(col1,col2)和(col1,col2,col3)上的搜索进行了索引。
如果列不构成索引最左面的前缀，MySQL不能使用局部索引。假定有下面显示的SELECT语句。
 
SELECT * FROM tbl_name WHERE col1=val1;
SELECT * FROM tbl_name WHERE col1=val1 AND col2=val2;
 
SELECT * FROM tbl_name WHERE col2=val2;
SELECT * FROM tbl_name WHERE col2=val2 AND col3=val3;
 
如果 (col1，col2，col3)有一个索引，只有前2个查询使用索引。第3个和第4个查询确实包括索引的列，但(col2)和(col2，col3)不是 (col1，col2，col3)的最左边的前缀。
也可以在表达式通过=、>、>=、<、<=或者BETWEEN操作符使用B-树索引进行列比较。如果LIKE的参数是一个不以通配符开头的常量字符串，索引也可以用于LIKE比较。例如，下面的SELECT语句使用索引：
SELECT * FROM tbl_name WHERE key_col LIKE 'Patrick%';
SELECT * FROM tbl_name WHERE key_col LIKE 'Pat%_ck%';
在第1个语句中，只考虑带'Patrick' <=key_col < 'Patricl'的行。在第2个语句中，只考虑带'Pat' <=key_col < 'Pau'的行。
下面的SELECT语句不使用索引：
SELECT * FROM tbl_name WHERE key_col LIKE '%Patrick%';
SELECT * FROM tbl_name WHERE key_col LIKE other_col;
在第一条语句中，LIKE值以一个通配符字符开始。在第二条语句中，LIKE值不是一个常数。
如果使用... LIKE '%string%'并且string超过3个字符，MySQL使用Turbo Boyer-Moore算法初始化字符串的模式然后使用该模式来更快地进行搜索。
如果col_name被索引，使用col_name IS NULL的搜索将使用索引。
任何不跨越WHERE子句中的所有AND级的索引不用于优化查询。换句话说，为了能够使用索引，必须在每个AND组中使用索引前缀。
下面的WHERE子句使用索引：
... WHERE index_part1=1 AND index_part2=2 AND other_column=3
    /* index = 1 OR index = 2 */
... WHERE index=1 OR A=10 AND index=2
    /* optimized like "index_part1='hello'" */
... WHERE index_part1='hello' AND index_part3=5
    /* Can use index on index1 but not on index2 or index3 */
... WHERE index1=1 AND index2=2 OR index1=3 AND index3=3;
下面的WHERE子句不使用索引：
    /* index_part1 is not used */
... WHERE index_part2=1 AND index_part3=2
 
    /*  Index is not used in both parts of the WHERE clause  */
... WHERE index=1 OR A=10
 
    /* No index spans all rows  */
... WHERE index_part1=1 OR index_part2=10
有时MySQL不使用索引，即使有可用的索引。一种情形是当优化器估计到使用索引将需要MySQL访问表中的大部分行时。(在这种情况下，表扫描可能会更快些，因为需要的搜索要少）。然而，如果此类查询使用LIMIT只搜索部分行，MySQL则使用索引，因为它可以更快地找到几行并在结果中返回。
Hash索引还有一些其它特征：
·         它们只用于使用=或<=>操作符的等式比较(但很快)。它们用于比较 操作符，例如发现范围值的<。
·         优化器不能使用hash索引来加速ORDER BY操作。(该类索引不能用来按顺序搜索下一个条目）。
·         MySQL不能确定在两个值之间大约有多少行(这被范围优化器用来确定使用哪个索引)。如果你将一个MyISAM表改为hash-索引的MEMORY表，会影响一些查询。
·         只能使用整个关键字来搜索一行。(用B-树索引，任何关键字的最左面的前缀可用来找到行）。
7.4.6. MyISAM键高速缓冲
7.4.6.1. 共享键高速缓冲访问 
7.4.6.2. 多键高速缓冲 
7.4.6.3. 中点插入策略 
7.4.6.4. 索引预加载 
7.4.6.5. 键高速缓冲块大小 
7.4.6.6. 重构键高速缓冲
为了使硬盘I/O最小化，MyISAM存储引擎使用一个被许多数据库管理系统使用的策略。它使用一个缓存机制将经常访问的表锁在内存中：
·         对于索引块，维护一个称之为键高速缓冲(或键高速缓冲区)的特殊结构。该结构包含大量块缓存区，其中放置了最常用的索引块。
·         对于数据块，MySQL不使用特殊缓存。而使用原生的操作系统文件系统的缓存。
本节首先描述了MyISAM键高速缓冲的基本操作。然后讨论了提高 键高速缓冲性能并使你更好地控制缓存操作的最新的更改：
·         多个线程可以并行访问缓存。
·         可以设置多个键高速缓冲，并将表索引指定给具体缓存。
可以使用key_buffer_size系统变量控制 键高速缓冲的大小。如果该变量设置为零，不使用键高速缓冲。如果key_buffer_size值太小不能分配最小数量的块缓存区(8)，也不使用 键高速缓冲。
如果键高速缓冲不工作，只使用操作系统提供的原生文件系统缓存区访问索引文件。(换句话说，使用与表数据块相同的策略表来访问索引块）。 
索引块是一个连续的访问MyISAM索引文件的单位。通常一个索引块的大小等于索引B-树节点的大小。(在硬盘上使用B-树数据结构表示索引。树底部的节点为叶子节点。叶子节点上面的节点为非叶子节点）。
键高速缓冲结构中的所有块缓存区大小相同。该大小可以等于、大于或小于表索引块的大小。通常这两个值中的一个是另一个的几倍。
当必须访问表索引块中的数据时，服务器首先检查是否它可以用于键高速缓冲中的某些块缓存区。如果适用，服务器访问键高速缓冲中的数据而不是硬盘上的数据。也就是说，从缓存读取或写入缓存，而不是从硬盘读写。否则，服务器选择一个包含一个不同的表索引块的缓存块缓存区，并用需要的表索引块的拷贝替换那里的数据。一旦新的索引块位于缓存中，可以访问索引数据。
如果用于替换的块已经被修改了，块被视为“脏了”。在这种情况下，在替换前，其内容被刷新到它来自的表索引。
通常服务器遵从LRU(最近最少使用)策略：当选择一个块用于替换时，它选择最近最少使用的索引块。为了使该选择更容易， 键高速缓冲模块维护所有使用的块的专门队列(LRU链)。当访问块时，它被放到队列最后。当块需要替换时，队列开头的块是最近最少使用的块，并成为第1个候选者。
7.4.6.1. 共享键高速缓冲访问
在以下条件下，线程可以同时访问键高速缓冲缓存区：
·         没有被更新的缓存区可以被多个线程访问。
·         正被更新的缓存区让需要使用它的线程等待直到更新完成。
·         多个线程可以发起请求替换缓存块，只要它们不彼此干扰(也就是说，只要它们需要不同的索引块，并且使不同的缓存块被替换)。
对键高速缓冲的共享访问允许服务器大大提高吞吐量。
7.4.6.2. 多键高速缓冲
对键高速缓冲的共享访问可以提高性能但不能完全消除线程之间的竟争。它们仍然竞争对键高速缓冲缓存区的访问进行管理的控制结构。为了进一步降低 键高速缓冲访问竟争，MySQL 5.1还提供了多个键高速缓冲，允许你为不同的键高速缓冲分配不同的表索引。
有多个键高速缓冲时，当为给定的MyISAM表处理查询时，服务器必须知道使用哪个缓存。默认情况，所有MyISAM表索引被缓存到默认 键高速缓冲中。要想为具体键高速缓冲分配表索引，应使用CACHE INDEX语句(参见13.5.5.1节，“CACHE INDEX语法”)。
例如，下面的语句将表t1、t2和t3的索引分配给名为hot_cache的 键高速缓冲：
mysql> CACHE INDEX t1, t2, t3 IN hot_cache;
+---------+--------------------+----------+----------+
| Table   | Op                 | Msg_type | Msg_text |
+---------+--------------------+----------+----------+
| test.t1 | assign_to_keycache | status   | OK       |
| test.t2 | assign_to_keycache | status   | OK       |
| test.t3 | assign_to_keycache | status   | OK       |
+---------+--------------------+----------+----------+
 
可以用SET GLOBAL参数设置语句或使用服务器启动选项设置在CACHE INDEX语句中引用的键高速缓冲的大小来创建键高速缓冲。例如：
mysql> SET GLOBAL keycache1.key_buffer_size=128*1024;
要想删除键高速缓冲，将其大小设置为零：
mysql> SET GLOBAL keycache1.key_buffer_size=0;
请注意不能删除默认键高速缓冲。删除默认键高速缓冲的尝试将被忽略：
mysql> set global key_buffer_size = 0;
 
mysql> show variables like 'key_buffer_size';
+-----------------+---------+
| Variable_name   | Value   |
+-----------------+---------+
| key_buffer_size | 8384512 |
+-----------------+---------+
 
键高速缓冲变量是结构式系统变量，有一个名和组件。对于keycache1.key_buffer_size，keycache1是缓存变量名，key_buffer_size是缓存组件。关于引用结构式 键高速缓冲系统变量所使用的语法的描述，参见9.4.1节，“结构式系统变量”
默认情况下，表索引被分配给服务器启动时创建的主要(默认)键高速缓冲。当 键高速缓冲被删除后，所有分配给它的索引被重新分配给默认键高速缓冲。
对于一个忙的服务器，我们建议采用使用三个键高速缓冲的策略：
·         占用为所有键高速缓冲分配的空间的20%的“热”键高速缓冲。该缓存用于频繁用于搜索但没有更新的表。
·         占用为所有键高速缓冲分配的空间的20%的“冷”键高速缓冲。该缓存用于中等大小、大量修改的表，例如临时表。
·         占用键高速缓冲空间的20%的“温”键高速缓冲。使用它作为默认 键高速缓冲，默认情况被所有其它表使用。
使用3个键高速缓冲有好处的一个原因是对一个键高速缓冲结构的访问不会阻挡对其它的访问。访问分配给一个缓存的表的查询不会与访问分配给其它缓存的表的查询竞争。由于其它原因也会提高性能：
·         热缓存只用于检索查询，因此其内容决不会被修改。结果是，无论何时需要从硬盘上拉入索引块，选择用于替换的缓存块的内容不需要先刷新。
·         对于分配给热缓存的索引，如果没有查询需要索引扫描，很有可能对应索引B-树的非叶子节点的索引块仍然在缓存中。
·         当更新的节点位于缓存中并且不需要先从硬盘读入时，为临时表频繁执行的更新操作会执行得更快。如果临时表的索引的大小可以与冷键高速缓冲相比较，很可能更新的节点位于缓存中。
CACHE INDEX在一个表和 键高速缓冲之间建立一种联系，但每次服务器重启时该联系被丢失。如果你想要每次服务器重启时该联系生效，一个发办法是使用选项文件：包括配置 键高速缓冲的变量设定值，和一个init-file选项用来命名包含待执行的CACHE INDEX语句的一个文件。例如：
key_buffer_size = 4G
hot_cache.key_buffer_size = 2G
cold_cache.key_buffer_size = 2G
init_file=/path/to/data-directory/mysqld_init.sql
每次服务器启动时执行mysqld_init.sql中的语句。该文件每行应包含一个SQL语句。下面的例子分配几个表，分别对应hot_cache和cold_cache：
CACHE INDEX a.t1, a.t2, b.t3 IN hot_cache
CACHE INDEX a.t4, b.t5, b.t6 IN cold_cache
7.4.6.3. 中点插入策略
默认情况，键高速缓冲管理系统采用LRU策略选择要收回的键高速缓冲块，但它也支持更复杂的方法，称之为“中点插入策略”。
当使用中点插入策略时，LRU链被分为两个部分：一条热子链和一条温子链。两部分之间的划分点不固定，但 键高速缓冲管理系统关注温部分不“太短”，总是包含至少key_cache_division_limit比例的 键高速缓冲块。key_cache_division_limit是结构式 键高速缓冲变量的一个组件，因此其值是一个可以根据每个缓存进行设置的参数。
当一个索引块从表中读入键高速缓冲，它被放入温子链的末端。经过一定量的访问后(访问块)，它被提升给热子链。目前，需要用来提升一个块(3)的访问次数与所有索引块的相同。
提升到热子链的块被放到子链的末端。块然后在该子链中循环。如果块在子链的开头停留足够长的时间，它被降到温链。该时间由键高速缓冲key_cache_age_threshold组件的值确定。
对于包含N个块的 键高速缓冲，阈值表示，热子链开头的没有在最后N *key_cache_age_threshold/100次访问中被访问的块将被移动到温子链开头。该块然后变为第1个挤出的候选者，因为替换的块总是来自温子链的开头。
中点插入策略允许你将更有价值的块总是在缓存中。如果你想使用简单的LRU策略，使key_cache_division_limit值保持其默认值100。
若执行的查询要求索引扫描有效推出所有索引块对应有数值的高级B-树节点的缓存，中点插入策略可以帮助提高性能。要想避免，必须使用中点插入策略，而key_cache_division_limit设置为远小于100。然后在索引扫描操作过程中，有数值的经常访问的节点被保留在热子链中。
7.4.6.4. 索引预加载
如果键高速缓冲内有足够的块以容纳整个索引的块，或者至少容纳对应其非叶节点的块，则在使用前，预装含索引块的键高速缓冲很有意义。预装可以以更有效的方式将表索引块放入 键高速缓冲缓存区中：通过顺序地从硬盘读取索引块。
不进行预装，块仍然根据查询需要放入键高速缓冲中。尽管块将仍然在缓存中（因为有足够的缓存区保存它们），它们以随机方式从硬盘上索取，而不是以顺序方式。
要想将索引预装到缓存中，使用LOAD INDEX INTO CACHE语句。例如，下面的语句可以预装表t1和t2索引的节点(索引块)：
mysql> LOAD INDEX INTO CACHE t1, t2 IGNORE LEAVES;
+---------+--------------+----------+----------+
| Table   | Op           | Msg_type | Msg_text |
+---------+--------------+----------+----------+
| test.t1 | preload_keys | status   | OK       |
| test.t2 | preload_keys | status   | OK       |
+---------+--------------+----------+----------+
IGNORE LEAVES修改器只允许预装索引非叶节点所用的块。这样，上述的语句预装t1中的所有索引块，但只预装t2中的非叶节点对应的块。
如果已经使用CACHE INDEX语句为一个索引分配了一个键高速缓冲，预装可以将索引块放入该缓存。否则，索引被装入默认键高速缓冲。
7.4.6.5. 键高速缓冲块大小
可以使用key_cache_block_size变量为具体的 键高速缓冲指定块缓存区的大小。这样允许为索引文件调节I/O操作的性能。
当读缓存区的大小等于原生操作系统I/O缓存区的大小时，可以获得I/O操作的最佳性能。但是将关键字节点的大小设置为等于I/O缓存区的大小并不总是能保证最佳整体性能。当读取大的叶节点时，服务器读入大量的不需要的数据，结果防止读入其它叶子的节点。
目前，你不能控制表内索引块的大小。该大小由服务器在创建.MYI索引文件时设置，取决于表定义中索引的关键字大小。在大多数情况下，它被设置为与I/O缓存区大小相等。
7.4.6.6. 重构键高速缓冲
键高速缓冲可以通过更新其参数值随时重新构建。例如：
mysql> SET GLOBAL cold_cache。key_buffer_size=4*1024*1024；
如果你为key_buffer_size或key_cache_block_size键高速缓冲组件分配的值与组件当前的值不同，服务器将毁掉缓存的旧结构并根据新值创建一个新的。如果缓存包含任何脏的块，服务器在销毁前将它们保存到硬盘上并重新创建缓存。如果你设置其它 键高速缓冲参数，则不会发生重新构建。
当重新构建键高速缓冲时，服务器首先将任何脏缓存区的内容刷新到硬盘上。之后，缓存内容不再需要。然而，重新构建并不阻塞需要使用分配给缓存的索引的查询。相反，服务器使用原生文件系统缓存直接访问表索引。文件系统缓存不如使用 键高速缓冲有效，因此尽管查询可以执行，但速度会减慢。缓存被重新构建后，它又可以缓存分配给它的索引了，并且索引不再使用文件系统缓存。
7.4.7. MyISAM索引统计集合
存储引擎搜集优化器使用的表的统计信息。表统计基于数数值组，其中数数值组是一系列有相同的关键字前缀值的记录。对于优化器，重要的统计即为数数值组的平均大小。
MySQL用下述方式使用平均数数值组：
·         估计必须为每个ref访问读取多少行
·         估计部分联接将产生多少行；也就是说，下述形式的操作将产生的行数：
·                  (...) JOIN tbl_name ON tbl_name.key = expr
随着索引的平均数数值组大小的增加，索引将更没有用，因为每个查找的平均行数增加：为了让索引有利于优化目的，最好是每个索引值对应表内的少量行数。当某个给定的索引值产生较多行时，索引更加没有用，MySQL更不可能使用它。
平均数数值组大小与表的集的势相关，即数数值组的数目。SHOW INDEX语句显示集的势值（基于N/S），其中N是表内的记录数，S是平均数数值组大小。该比例产生表内数数值组的大约数。
对于基于<=>比较 操作符的联接，NULL并不视为与任何其它值不同：NULL <=> NULL，正如对于其它N ，N <=> N。
然而，对于基于=操作符的联接，NULL与非NULL值不同：当expr1或expr2(或两者)为NULL时，expr1 = expr2不为真。这样影响比较形式tbl_name.key = expr的ref访问：如果expr当前的值为NULL，MySQL不会访问表，因为比较不能为真。
对于=比较，表内有多少NULL值并不重要。为了优化目的，相关值为非NULL数值组的平均大小。然而，MySQL目前不允许搜集或使用该平均大小。
对于MyISAM表，你可以使用myisam_stats_method系统变量部分控制表统计信息的搜集。该变量有两个可能的不同值，如下所示：
·         当myisam_stats_method为nulls_equal时，所有NULL值被视为相等的(也就是说，它们都形成一个数值组)。
如果NULL数值组大小远大于平均非NULL数值组大小，该方法向上倾斜平均数数值组大小。这样使索引对于优化器来说比它实际为查找非NULL值的联接更加没有用。结果是，nulls_equal方法会使优化器进行ref访问时本应使用索引而没有使用。
·         当myisam_stats_method为nulls_unequal时，NULL值不视为相同。相反，每个NULL值形成一个单独的数值组，大小为1。
如果你有许多NULL值，该方法向下倾斜平均数数值组大小。如果平均非NULL数值组较大，统计大小为1的每个组的NULL值会使优化器过高估计查找非NULL值的联接的索引值。结果是，当其它方法会更好时，nulls_unequal方法会使优化器为ref查找使用该索引。
如果你要使用许多使用<=>而不是=的联接，在比较过程中NULL值并不特殊，一个NULL等于另一个NULL。在这种情况下，nulls_equal是合适的统计方法。
myisam_stats_method系统变量有全局和会话值。设置全局值会影响MyISAM 为所有MyISAM表的统计的搜集。设置会话值只影响当前客户连接的统计的搜集。这说明你可以强制用给定的方法重新生成表的统计的搜集，而不需要因为设置myisam_stats_method的会话值而影响其它客户。
可以使用下面任一方法来重新生成表的统计信息：
·         设置myisam_stats_method，然后执行CHECK TABLE语句
·         执行myisamchk --stats_method=method_name --analyze
·         更改表，使其统计信息不为最新(例如，插入一行然后删除它)，然后设置myisam_stats_method并执行ANALYZE TABLE语句
使用myisam_stats_method的一些警告：
你可以强制显式搜集表的统计信息，如上所述。然而，MySQL也可以自动搜集统计信息。例如，如果在为表执行语句的过程中，一些语句修改了表，MySQL可以搜集统计信息。(例如，大批插入或删除，或者执行ALTER TABLE语句时可能发生）。如果发生，使用myisam_stats_method此时所有的值搜集统计信息。这样，如果你使用一个方法搜集统计信息，但当后面自动搜集一个表的统计信息时myisam_stats_method被设置为另一个方法，将使用其它方法。
对于给定的MyISAM表，还不能说出使用哪个方法来产生统计信息。
myisam_stats_method只适合MyISAM表。其它存储引擎只有一个方法来搜集表的统计信息。通常它接近于nulls_equal方法。
7.4.8. MySQL如何计算打开的表
当运行mysqladmin status时，将看见象这样的一些东西：
Uptime: 426 Running threads: 1 Questions: 11082
Reloads: 1 Open tables: 12
 
如果你仅有6个表，Open tables值为12可能有点令人困惑。
MySQL是多线程的，因此许多客户可以同时在同一个表上进行查询。为了使多个客户线程在同一个表上有不同状态的问题减到最小，表被每个并发进程独立地打开。这样需要额外的内存但一般会提高性能。对于MyISAM表，数据文件需要为每个打开表的客户提供一个额外的文件描述符。(索引文件描述符在所有线程之间共享)。
下一节中提供了该主题的更多的信息。参见7.4.9节，“MySQL如何打开和关闭表”。
7.4.9. MySQL如何打开和关闭表
table_cache、max_connections和max_tmp_tables系统变量影响服务器保持打开的文件的最大数量。如果你增加这些值其中的一个或两个，会遇到操作系统为每个进程打开文件描述符的数量强加的限制。许多操作系统允许你增加打开的文件的限制，尽管该方法随系统的不同而不同。查阅操作系统文档以确定是否可以增加限制以及如何操作。
table_cache与max_connections有关。例如，对于200个并行运行的连接，应该让表的缓存至少有200 * N，这里N是可以执行的查询的一个联接中表的最大数量。还需要为临时表和文件保留一些额外的文件描述符。
确保操作系统可以处理table_cache设置所指的打开的文件描述符的数目。如果table_cacheis设得太高，MySQL可能为文件描述符耗尽资源并拒绝连接，不能执行查询，并且很不可靠。还必须考虑到MyISAM存储引擎需要为每个打开的表提供两个文件描述符。可以在mysqld_safe中使用--open-files-limit启动选项来增加MySQL适用的文件描述符的数量。参见A.2.17节，“文件未找到”。
打开表的缓存可以保持在table_cache条。 默认为64；可以用mysqld的--table_cache选项来更改。请注意 MySQL可以临时打开更多的 表以执行查询。
在下面的条件下，未使用的表将被关闭并从表缓存中移出：
·         当缓存满了并且一个线程试图打开一个不在缓存中的表时。
·         当缓存包含超过table_cache个条目，并且缓存中的表不再被任何线程使用。
·         当表刷新操作发生。当执行FLUSH TABLES语句或执行mysqladmin flush-tables或mysqladmin refresh命令时会发生。
当表缓存满时，服务器使用下列过程找到一个缓存入口来使用：
·         当前未使用的表被释放，以最近最少使用顺序。
·         如果缓存满了并且没有表可以释放，但是一个新表需要打开，缓存必须临时被扩大。
如果缓存处于一个临时扩大状态并且一个表从在用变为不在用状态，它被关闭并从缓存中释放。
对每个并发访问打开一个表。这意味着，如果2个线程访问同一个表或在同一个查询中访问表两次(例如，将表连接为自身时)，表需要被打开两次。每个并行的打开要求在表缓存中有一个条目。任何表的第一次打开占2个文件描述符：一个用于数据文件另一个用于索引文件。表的每一次额外使用仅占一个数据文件的文件描述符。索引文件描述符在所有线程之间共享。
如果你正用HANDLER tbl_name OPEN语句打开一个表，将为该线程专门分配一个表。该表不被其它线程共享，只有线程调用HANDLER tbl_name CLOSE或线程终止后才被关闭。表关闭后，被拉回表缓存中(如果缓存不满)。参见13.2.3节，“HANDLER语法”。
可以通过检查mysqld的状态变量Opened_tables确定表缓存是否太小：
mysql> SHOW STATUS LIKE 'Opened_tables';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| Opened_tables | 2741  |
+---------------+-------+
如果值很大，即使你没有发出许多FLUSH TABLES语句，也应增加表缓存的大小。参见5.3.3节，“服务器系统变量”和5.3.4节，“服务器状态变量”。
7.4.10. 在同一个数据库中创建多个表的缺陷
如果在同一个数据库目录中有许多MyISAM表，打开、关闭和创建操作将会很慢。如果对许多不同的表执行SELECT语句，当表缓存满时，将有一点开销，因为对每个必须打开的表，另外一个必须被关闭。可以通过使表缓存更大些来减少这个开销。 
7.5. 优化MySQL服务器
7.5.1. 系统因素和启动参数的调节 
7.5.2. 调节服务器参数 
7.5.3. 控制查询优化器的性能 
7.5.4. 编译和链接怎样影响MySQL的速度 
7.5.5. MySQL如何使用内存 
7.5.6. MySQL如何使用DNS
7.5.1. 系统因素和启动参数的调节
我们从系统级因素开始，因为必须尽早地进行部分决策以获得较大性能。在其它情况下，快速浏览该节就足够了。但是，了解一下更改该层次的参数能够获得多少性能提高是很有意义的。
使用的操作系统很重要。为了更好地使用多CPU机器，应使用Solaris(因为其线程工作得很好)或Linux(因为2.4和以后的内核有很好的SMP支持)。请注意默认情况旧的Linux内核有一个2GB的文件大小限制。如果有这样的一个内核并且需要文件大于2GB，应得到ext2文件系统的大文件支持(LFS)补丁。其它文件系统例如ReiserFS和XFS没有此2GB限制。
将MySQL用于生产前，我们建议你在想用的平台上对它进行测试。
其它技巧：
·         如果有足够的RAM，可以移除所有的交换设备。有些操作系统即使有自由内存也使用交换设备。
·         使用--skip-external-locking MySQL选项以避免外部锁定。该选项默认开启。
请注意只要你只运行一个服务器，--skip-external-locking选项不影响MySQL的功能。只要记住运行myisamchk之前关闭服务器(或锁定并刷新相关表)。在一些系统上该选项是强制的，因为在任何情况下外部锁定均不工作。
不能使用--skip-external-locking的唯一情况是对相同的数据运行多个MySQL服务器(非客户)的情况，或者如果没有事先告诉服务器刷新并锁定一个表即运行myisamchk来检查(非修复)该表。请注意一般不建议使用多个MySQL服务器来并行访问相同的数据，除了使用MySQL Cluster时。
即使使用--skip-external-locking，仍然可以使用LOCK TABLES和UNLOCK TABLES。
7.5.2. 调节服务器参数
可以用这个命令得到mysqld服务器 默认缓存区的大小：
shell> mysqld --verbose --help
这个命令生成所有mysqld选项和可配置变量的列表。输出包括 默认值并且看上去象这样：
help                              TRUE
abort-slave-event-count           0
allow-suspicious-udfs             FALSE
auto-increment-increment          1
auto-increment-offset             1
automatic-sp-privileges           TRUE
basedir                           /home/jon/bin/mysql/
bdb                               FALSE
bind-address                      (No default value)
character-set-client-handshake    TRUE
character-set-server              latin1
character-sets-dir                /home/jon/bin/mysql/share/mysql/charsets/
chroot                            (No default value)
collation-server                  latin1_swedish_ci
completion-type                   0
concurrent-insert                 1
console                           FALSE
datadir                           /home/jon/bin/mysql/var/
default-character-set             latin1
default-collation                 latin1_swedish_ci
default-time-zone                 (No default value)
disconnect-slave-event-count      0
enable-locking                    FALSE
enable-pstack                     FALSE
engine-condition-pushdown         FALSE
external-locking                  FALSE
gdb                               FALSE
large-pages                       FALSE
init-connect                      (No default value)
init-file                         (No default value)
init-slave                        (No default value)
innodb                            TRUE
innodb_checksums                  TRUE
innodb_data_home_dir              (No default value)
innodb_doublewrite                TRUE
innodb_fast_shutdown              1
innodb_file_per_table             FALSE
innodb_flush_log_at_trx_commit    1
innodb_flush_method               (No default value)
innodb_locks_unsafe_for_binlog    FALSE
innodb_log_arch_dir               (No default value)
innodb_log_group_home_dir         (No default value)
innodb_max_dirty_pages_pct        90
innodb_max_purge_lag              0
innodb_status_file                FALSE
innodb_table_locks                TRUE
innodb_support_xa                 TRUE
isam                              FALSE
language                          /home/jon/bin/mysql/share/mysql/english
local-infile                      TRUE
log                               /home/jon/bin/mysql/var/master1.log
log-bin                           /home/jon/bin/mysql/var/master1
log-bin-index                     (No default value)
log-bin-trust-routine-creators    FALSE
log-error                         /home/jon/bin/mysql/var/master1.err
log-isam                          myisam.log
log-queries-not-using-indexes     FALSE
log-short-format                  FALSE
log-slave-updates                 FALSE
log-slow-admin-statements         FALSE
log-slow-queries                  (No default value)
log-tc                            tc.log
log-tc-size                       24576
log-update                        (No default value)
log-warnings                      1
low-priority-updates              FALSE
master-connect-retry              60
master-host                       (No default value)
master-info-file                  master.info
master-password                   (No default value)
master-port                       3306
master-retry-count                86400
master-ssl                        FALSE
master-ssl-ca                     (No default value)
master-ssl-capath                 (No default value)
master-ssl-cert                   (No default value)
master-ssl-cipher                 (No default value)
master-ssl-key                    (No default value)
master-user                       test
max-binlog-dump-events            0
memlock                           FALSE
myisam-recover                    OFF
ndbcluster                        FALSE
ndb-connectstring                 (No default value)
ndb-mgmd-host                     (No default value)
ndb-nodeid                        0
ndb-autoincrement-prefetch-sz     32
ndb-distibution                   KEYHASH
ndb-force-send                    TRUE
ndb_force_send                    TRUE
ndb-use-exact-count               TRUE
ndb_use_exact_count               TRUE
ndb-shm                           FALSE
ndb-optimized-node-selection      TRUE
ndb-cache-check-time              0
ndb-index-stat-enable             TRUE
ndb-index-stat-cache-entries      32
ndb-index-stat-update-freq        20
new                               FALSE
old-alter-table                   FALSE
old-passwords                     FALSE
old-style-user-limits             FALSE
pid-file                          /home/jon/bin/mysql/var/hostname.pid1
port                              3306
relay-log                         (No default value)
relay-log-index                   (No default value)
relay-log-info-file               relay-log.info
replicate-same-server-id          FALSE
report-host                       (No default value)
report-password                   (No default value)
report-port                       3306
report-user                       (No default value)
rpl-recovery-rank                 0
safe-user-create                  FALSE
secure-auth                       FALSE
server-id                         1
show-slave-auth-info              FALSE
skip-grant-tables                 FALSE
skip-slave-start                  FALSE
slave-load-tmpdir                 /tmp/
socket                            /tmp/mysql.sock
sporadic-binlog-dump-fail         FALSE
sql-mode                          OFF
symbolic-links                    TRUE
tc-heuristic-recover              (No default value)
temp-pool                         TRUE
timed_mutexes                     FALSE
tmpdir                            (No default value)
use-symbolic-links                TRUE
verbose                           TRUE
warnings                          1
back_log                          50
binlog_cache_size                 32768
bulk_insert_buffer_size           8388608
connect_timeout                   5
date_format                       (No default value)
datetime_format                   (No default value)
default_week_format               0
delayed_insert_limit              100
delayed_insert_timeout            300
delayed_queue_size                1000
expire_logs_days                  0
flush_time                        0
ft_max_word_len                   84
ft_min_word_len                   4
ft_query_expansion_limit          20
ft_stopword_file                  (No default value)
group_concat_max_len              1024
innodb_additional_mem_pool_size   1048576
innodb_autoextend_increment       8
innodb_buffer_pool_awe_mem_mb     0
innodb_buffer_pool_size           8388608
innodb_concurrency_tickets        500
innodb_file_io_threads            4
innodb_force_recovery             0
innodb_lock_wait_timeout          50
innodb_log_buffer_size            1048576
innodb_log_file_size              5242880
innodb_log_files_in_group         2
innodb_mirrored_log_groups        1
innodb_open_files                 300
innodb_sync_spin_loops            20
innodb_thread_concurrency         20
innodb_commit_concurrency         0
innodb_thread_sleep_delay         10000
interactive_timeout               28800
join_buffer_size                  131072
key_buffer_size                   8388600
key_cache_age_threshold           300
key_cache_block_size              1024
key_cache_division_limit          100
long_query_time                   10
lower_case_table_names            0
max_allowed_packet                1048576
max_binlog_cache_size             4294967295
max_binlog_size                   1073741824
max_connect_errors                10
max_connections                   100
max_delayed_threads               20
max_error_count                   64
max_heap_table_size               16777216
max_join_size                     4294967295
max_length_for_sort_data          1024
max_relay_log_size                0
max_seeks_for_key                 4294967295
max_sort_length                   1024
max_tmp_tables                    32
max_user_connections              0
max_write_lock_count              4294967295
multi_range_count                 256
myisam_block_size                 1024
myisam_data_pointer_size          6
myisam_max_extra_sort_file_size   2147483648
myisam_max_sort_file_size         2147483647
myisam_repair_threads             1
myisam_sort_buffer_size           8388608
myisam_stats_method               nulls_unequal
net_buffer_length                 16384
net_read_timeout                  30
net_retry_count                   10
net_write_timeout                 60
open_files_limit                  0
optimizer_prune_level             1
optimizer_search_depth            62
preload_buffer_size               32768
query_alloc_block_size            8192
query_cache_limit                 1048576
query_cache_min_res_unit          4096
query_cache_size                  0
query_cache_type                  1
query_cache_wlock_invalidate      FALSE
query_prealloc_size               8192
range_alloc_block_size            2048
read_buffer_size                  131072
read_only                         FALSE
read_rnd_buffer_size              262144
div_precision_increment           4
record_buffer                     131072
relay_log_purge                   TRUE
relay_log_space_limit             0
slave_compressed_protocol         FALSE
slave_net_timeout                 3600
slave_transaction_retries         10
slow_launch_time                  2
sort_buffer_size                  2097144
sync-binlog                       0
sync-frm                          TRUE
sync-replication                  0
sync-replication-slave-id         0
sync-replication-timeout          10
table_cache                       64
table_lock_wait_timeout           50
thread_cache_size                 0
thread_concurrency                10
thread_stack                      196608
time_format                       (No default value)
tmp_table_size                    33554432
transaction_alloc_block_size      8192
transaction_prealloc_size         4096
updatable_views_with_limit        1
wait_timeout                      28800
如果有一个mysqld服务器正在运行，通过连接它并执行这个命令，可以看到实际上使用的变量的值：
mysql> SHOW VARIABLES;
还可以通过下面的语句看到运行服务器的统计和状态指标：
mysql>SHOW STATUS；
使用mysqladmin还可以获得系统变量和状态信息：
shell> mysqladmin variables
shell> mysqladmin extended-status
关于所有系统和状态变量的完全描述参见5.3.3节，“服务器系统变量”和5.3.4节，“服务器状态变量”。
MySQL使用完全可以升级的算法，因此通常运行时可以用很少的内存。然而，通常情况若给MySQL更多的内存性能会更好。
当调节MySQL服务器时，要配置的两个最重要的变量是key_buffer_size和table_cache。在试图更改其它变量前你应先确信已经适当地配置了这些变量。
下面的例子显示了部分典型的不同的运行时配置的变量值。
·         如果至少有256MB内存和许多表，想要在中等数量的客户时获得最大性能，应使用：
·                shell> mysqld_safe --key_buffer_size=64M --table_cache=256 \
·                           --sort_buffer_size=4M --read_buffer_size=1M &
·         如果只有128MB内存和少量表，但仍然要进行大量的排序，可以使用：
·                shell> mysqld_safe --key_buffer_size=16M --sort_buffer_size=1M
如果有许多并行连接，交换问题会发生，除非mysqld已经配置成为每个连接分配很少的内存。如果有足够的内存用于所有连接，mysqld会执行得更好。
·         对于少量内存和大量连接，应使用：
·                shell> mysqld_safe --key_buffer_size=512K --sort_buffer_size=100K \
·                           --read_buffer_size=100K &
或甚至为：
shell> mysqld_safe --key_buffer_size=512K --sort_buffer_size=16K \
           --table_cache=32 --read_buffer_size=8K \
           --net_buffer_length=1K &
如果正对远远大于可用内存的表执行GROUP BY或ORDER BY操作，应增加read_rnd_buffer_size的值以加速排序操作后面的行读取。
如果已经安装了MySQL，support-files目录包含一些不同的my.cnf示例文件：my-huge.cnf、my-大.cnf、my-medium.cnf和my-small.cnf。可以使用这些文件来优化系统。
请注意如果在命令行中为mysqld或mysqld_safe指定一个选项，它只在该次服务器调用中保持有效。要想每次服务器运行时使用该选项，将它放在选项文件中。
要想看参数更改的效果，应执行：
shell> mysqld --key_buffer_size=32M --verbose ---help
变量值列于输出的最后。确保--verbose和---help选项在最后。否则，在命令行中列于它们后面的选项的效果不会反映到输出中。
关于调节InnoDB存储引擎的信息，参见15.2.11节，“InnoDB性能调节提示”。
7.5.3. 控制查询优化器的性能
查询优化器的任务是发现执行SQL查询的最佳方案。因为“好”方案和“坏”方案之间的性能差别会巨大(也就是说，秒相对于小时或甚至天)，大多数查询优化器，包括MySQL的查询优化器，总或多或少地在所有可能的查询评估方案中搜索最佳方案。对于联接查询，MySQL优化器所调查的可能的方案数随查询中所引用的表的数目呈指数增长。对于小数量的表(典型小于7-10)，这不是一个问题。然而，当提交的查询更大时，查询优化所花的时间会很容易地成为服务器性能的主要瓶颈。
查询优化的一个更加灵活的方法是允许用户控制优化器详尽地搜索最佳查询评估方案。一般思想是优化器调查的方案越少，它编译一个查询所花费的时间越少。另一方面，因为优化器跳过了一些方案，它可能错过一个最佳方案。
优化器关于方案数量评估的行为可以通过两个系统变量来控制：
·         optimizer_prune_level变量告诉优化器根据对每个表访问的行数的估计跳过某些方案。我们的试验显示该类“有根据的猜测”很少错过最佳方案，并且可以大大降低查询编辑次数。这就是为什么默认情况该选项为on(optimizer_prune_level=1)。然而，如果你认为优化器错过了一个更好的查询方案，则该选项可以关闭(optimizer_prune_level=0)，风险是查询编辑花费的时间更长。请注意即使使用该启发，优化器仍然可以探测呈指数数目的方案。
·         optimizer_search_depth变量告诉优化器对于每个未完成的“未来的”方案，应查看多深，以评估是否应对它进一步扩大。optimizer_search_depth值较小会使查询编辑次数大大减小。例如，如果optimizer_search_depth接近于查询中表的数量，对12、13或更多表的查询很可能需要几小时甚至几天的时间来编译。同时，如果用optimizer_search_depth等于3或4编辑，对于同一个查询，编译器编译时间可以少于1分钟。如果不能确定合理的optimizer_search_depth值，该变量可以设置为0，告诉优化器自动确定该值。
7.5.4. 编译和链接怎样影响MySQL的速度
下列大多数测试是在Linux上并用MySQL基准进行的，但是它们能对其它操作系统和工作负载给出一些指示。
当你用-static链接时，可以得到最快的可执行文件。
在Linux上，最好用pgcc和-O3编译服务器。为了用这些选项编译“sql_yacc.cc”，需要大约200M内存，因为gcc或pgcc需要大量的内存使所有函数嵌入（inline）。在配置MySQL时，也应该设定CXX=gcc以避免包括libstdc++库(它不需要)。请注意对于某些版本的pgcc，生成的二进制只能运行在真Pentium处理器上，即使你使用编译器选项说明你想让最终的代码在所有x586-类处理器上工作(例如AMD)。
只通过使用一个较好的编译器或较好的编译器选项，在应用中能得到10-30%的加速。如果你自己编译SQL服务器，这特别重要！
当我们测试Cygnus CodeFusion或Fujitsu编译器时，二者均还没足够不出错来让MySQL启用优化进行编译。
标准MySQL二进制分发编译为支持所有字符集。当你自己编译MySQL时，应只包括将使用的字符集的支持。通过configure的--with-charset选项来控制。
这里是我们做过的一些测量表：
·         如果你使用pgcc并用-O6编译，mysqld服务器比用gcc 2.95.2快11%。
·         如果你动态地链接(没有-static)，在Linux中结果慢了13%。注意你仍能在客户应用程序中使用动态链接MySQL库。只有服务器对性能是关键的。
·         如果你用strip mysqld剥离mysqld二进制，生成的二进制可以快4%。
·         对于在同一主机上运行的客户与服务器之间的连接，如果你使用TCP/IP而非Unix套接字文件进行连接，结果慢7.5%。(在Unix中，如果你连接localhost主机，MySQL默认使用一个套接字文件）。
·         对于从客户到服务器的TCP/IP连接，从另一台主机连接一台远程服务器要比连接同一主机上的服务器慢8-11%，即使通过100Mb/s以太网进行连接。
·         当使用安全连接运行我们的基准测试时(所有数据用内部SSL支持进行加密)，性能比未加密连接慢55%。
·         如果你用--with-debug=full编译，大多数查询慢20%。部分查询时间会很长；例如，MySQL基准的运行要慢35%。如果你使用--with-debug(没有=full)，速度只下降15%。对于用--with-debug=full编译的mysqld版本，可以用--skip-safemalloc选项启动以便在运行时禁用内存检查。执行速度则接近用--with-debug配置的时候。
·         在Sun UltraSPARC-Iie上，用Forte 5.0编译的服务器比用gcc 3.2编译的要快4%。
·         在Sun UltraSPARC-Iie上，用Forte 5.0编译的32位模式服务器比64位模式服务器要快4%。
·         用gcc 2.95.2编译带-mcpu=v8 -Wa的UltraSPARC，使用-xarch=v8plusa选项性能会提高4%。
·         在Solaris 2.5.1上，在单个处理器上MIT-pthreads比带原生线程的Solaris慢8-12%。如果有更大的负载/cpus，差别应该更大。
·         在Linux-x86上使用gcc编译而不用帧指针(-fomit-frame-pointer or -fomit-frame-pointer -ffixed-ebp)，可以使mysqld快1-4%。
MySQL AB提供的Linux上的二进制MySQL分发一般用pgcc编译。我们必须返回到常规gcc，因为pgcc中有一个bug，使生成的二进制不能在AMD上运行。我们将继续使用gcc直到该bug被解决。同时，如果你有一个非AMD机，你可以用pgcc编译构建一个更快的二进制。标准MySQL Linux二进制是通过静态链接，以使它更快并且更加易于移植。
7.5.5. MySQL如何使用内存
下面的列表中列出了mysqld服务器使用内存的一些方法。在适用的地方，给出了内存相关的系统变量名：
·         键缓存(变量key_buffer_size)被所有线程共享；服务器使用的其它缓存则根据需要分配。参见7.5.2节，“调节服务器参数”。
·         每个连接使用具体线程的空间：
o        堆栈(默认64KB，变量thread_stack)
o        连接缓存区(变量net_buffer_length)
o        结果缓存区(变量net_buffer_length)
连接缓存区和结果缓存区可以根据需要动态扩充到max_allowed_packet。当某个查询运行时，也为当前查询字符串分配内存。
·         所有线程共享相同的基本内存。
·         只有压缩MyISAM表映射到内存。这是因为4GB的32位内存空间不足以容纳大多数大表。当64位地址空间的系统变得越来越普遍后，我们可以增加常规的内存映射支持。
·         对表进行顺序扫描的请求将分配一个缓存区(变量read_buffer_size)。
·         当按任意顺序读取行时(例如，按照排序顺序)，将分配一个随机读 缓存区(变量read_rnd_buffer_size)以避免硬盘搜索。
·         所有联合在一个令牌内完成，并且大多数联合甚至可以不用临时表即可以完成。大多数临时表是基于内存的(HEAP)表。具有大的记录长度的临时表 (所有列的长度的和)或包含BLOB列的表存储在硬盘上。
如果某个内部heap（堆积）表大小超过tmp_table_size，MySQL可以根据需要自动将内存中的heap表改为基于硬盘的MyISAM表。还可以通过设置mysqld的tmp_table_size选项来增加临时表的大小，或设置客户程序中的SQL选项SQL_BIG_TABLE。参见13.5.3节，“SET语法”。
·         进行排序的大多数请求将分配一个排序缓存区，并根据结果集的大小为两个临时文件分配零。参见A.4.4节，“MySQL将临时文件储存在哪里”。
·         几乎所有解析和计算在局部内存中完成。小项目不需要内存，因此避免了普通的慢内存分配和释放。只为不期望的大字符串分配内存；使用函数malloc()和free()来完成。
·         对于每个打开的MyISAM表，索引文件打开一次；数据文件为每个并行运行的线程打开一次。对于每个并行线程，将分配一个表结构、一个每个列的列结构和大小为3 * N的缓存区(其中N是最大行的长度，而不是计算BLOB列)。一个BLOB列需要5至8个字节加上BLOB数据的长度。MyISAM 存储引擎维护一个额外的行缓存区供内部应用。
·         对于每个具有BLOB列的表，将对缓存区进行动态扩大以读入大的BLOB 值。如果你扫描一个表，则分配一个与最大的BLOB值一样大的缓存区。
·         所有使用的表的句柄结构保存在高速缓存中并以FIFO管理。默认情况，高速缓存有64个入口。如果某个表同时被两个运行的线程使用，高速缓存则为该提供两个入口。参见7.4.9节，“MySQL如何打开和关闭表”。
·         当并行执行的线程结束时，FLUSH TABLE语句或mysqladmin flush-table命令可以立即关闭所有不使用的表并将所有使用中的表标记为已经关闭。这样可以有效释放大多数使用中的内存。FLUSH TABLE在关闭所有表之前不返回结果。
ps和其它系统状态程序可以报导mysqld使用很多内存。这可以是在不同的内存地址上的线程栈造成的。例如，Solaris版本的ps将栈间未用的内存算作已用的内存。你可以通过用swap -s检查可用交换区来验证它。我们用商业内存漏洞探查器测试了mysqld，因此应该有没有内存漏洞。
7.5.6. MySQL如何使用DNS
当新的客户连接mysqld时，mysqld创建一个新的线程来处理请求。该线程先检查是否主机名在主机名缓存中。如果不在，线程试图解析主机名：
·         如果操作系统支持线程安全gethostbyaddr_r ()和gethostbyname_r()调用，线程使用它们来执行主机名解析。
·         如果操作系统不支持线程安全调用，线程锁定一个互斥体并调用gethostbyaddr()和gethostbyname()。在这种情况下，在第1个线程解锁互斥体前，没有其它线程可以解析不在主机名缓存中的主机名。
你可以用--skip-name-resolve选项启动mysqld来禁用DNS主机名查找。然而，在这种情况下，你只可以使用MySQL中的授权表中的IP号。
如果你有一个很慢的DNS和许多主机，你可以通过用--skip-name-resolve禁用DNS查找或增加HOST_CACHE_SIZE定义(默认值：128)并重新编译mysqld来提高性能。
你可以用--skip-host-cache选项启动服务器来禁用主机名缓存。要想清除主机名缓存，执行FLUSH HOSTS语句或执行mysqladmin flush-hosts命令。
如果你想要完全禁止TCP/IP连接，用--skip-networking选项启动mysqld。
7.6. 磁盘事宜
7.6.1. 使用符号链接 
·         磁盘搜索是巨大的性能瓶颈。当数据量变得非常大以致于缓存性能变得不可能有效时，该问题变得更加明显。对于大数据库，其中你或多或少地随机访问数据，你可以确信对读取操作需要至少一次硬盘搜索，写操作需要多次硬盘搜索。要想使该问题最小化，应使用搜索次数较少的磁盘。
·         通过链接文件到不同的磁盘或对硬盘分段来增加可用磁盘锭数量（因此降低搜索成本）：
o        使用符号链接
这说明，对于MyISAM表，你符号链接索引文件和/或数据文件，从它们数据目录内的通常位置到另一个硬盘（也可以被条纹化）。这将使搜索和读次数达到最好，假定硬盘不再为其它目的使用。参见7.6.1节，“使用符号链接”。
o        分条
分条意味着你有许多磁盘，将第1个块放到第1个硬盘，第2个块放到第2个磁盘，并且第N块在（N mod number_of_disks）磁盘上等等。这意味着如果正常数据大小小于分条大小（或完全匹配），能够得到最佳性能。分条完全取决于操作系统和分条大小，因此用不同的条纹大小对应用程序进行基准测试。参见7.1.5节，“使用自己的基准”。
分条的不同速度完全依赖于参数。依赖于怎样设置条纹参数和硬盘数量，可以根据不同数量级别得到不同的标准。你必须进行选择以便优化随机或顺序存取。
·         为了高可靠性你可能想使用RAID 0+1（条纹加镜像），但在这种情况下，需要2*N块磁盘来保持N个磁盘的数据。如果你肯为它花钱，这可能是最好的选项。然而，你可能还必须投资一部分资金到卷管理软件中以便有效地管理它。
·         一个较好的选择是根据数据类型的重要性程度改变RAID级别。例如，保存可以在RAID 0硬盘上重新生成的不太重要的数据，但保存 真正重要数据（例如主机信息和日志）到RAID 0+1或RAID N硬盘。如果你有许多写操作，RAID N可能会存在问题，因为需要时间来更新校验位。
·         在Linux上，通过配置磁盘接口时使用hdparm，你可以获得更多的性能。（在一般负载下达到100%并不困难。）下面的hdparm选项 应该非常适用于MySQL，并且可能适用于许多其它应用程序：
     hdparm -m 16 -d 1
请注意，当使用该命令时，性能和可靠性依赖于硬件，因此我们强烈建议，使用hdparm后，完全测试你的系统。为获取更多详细信息，请查阅hdparm手册帮助页。如果hdparm使用的不好，会导致文件系统破坏，因此试验之前请做好每个备份! 
·         也可以设置数据库使用的文件系统参数：
如果不需要知道文件最后一次访问的时间（这对数据库服务器并没有实际的用途），可以用-o noatime选项安装文件系统。这将跳过对文件系统中的节点的最后一次访问时间的更新，从而能够避免一些硬盘搜索。
在许多操作系统中，用-o async选项安装，可以将文件系统设置为异步更新。如果电脑相当稳定，这应该给予你更高的性能而不需要牺牲太多的可靠性。（该标志是Linux中默认开启。） 
7.6.1. 使用符号链接
7.6.1.1. 在Unix上使用针对数据库的符号链接 
7.6.1.2. 在Unix平台上使用表的符号链接
7.6.1.3. 在Windows平台上使用关于数据库的符号链接
你可以将表和数据库从数据库目录移动到其它的位置并且用指向新位置的符号链接进行替换。你可能需要这样作，例如，移动数据库到一个有更多空闲空间的文件系统中或通过将表分散到不同的磁盘上以增加系统的访问速度。
推荐的方法值需要将数据库通过符号链接指到不同的磁盘。符号链接表仅作为是最后的办法。
7.6.1.1. 在Unix上使用针对数据库的符号链接
在Unix中，符号链接一个数据库的方法是，首先在一些有空闲空间的硬盘上创建一个目录，然后从MySQL数据目录中创建它的一个符号链接。
shell> mkdir /dr1/databases/test
shell> ln -s /dr1/databases/test /path/to/datadir
MySQL不支持链接一个目录到多个数据库。用一个符号链接替换一个数据库目录，只要你不在数据库之间制作符号链接。假定你有一个数据库db1在MySQL数据目录下，然后生成一个符号链接db2指向 db1：
shell> cd /path/to/datadir
shell> ln -s db1 db2
对于db1中的任何表tbl_a，在db2也出现并且还是表tbl_a。如果一个客户更新db1.tbl_a并且另一个客户更新db2.tbl_a，可能会出现问题。
然而，如果你真的需要这样做，可以通过改变源文件mysys/my_symlink.c来实现，在该文件中你应查找下面的语句：
if (!(MyFlags & MY_RESOLVE_LINK) ||
    (!lstat(filename,&stat_buff) && S_ISLNK(stat_buff.st_mode)))
将该语句修改为：
if (1)
请注意，对于所有的Windows服务器，默认启用符号链接支持。
7.6.1.2. 在Unix平台上使用表的符号链接
 
你不应在没有完全可操作的realpath()调用的系统中对表进行符号链接。（Linux和Solaris支持realpath())。可以通过发出一个SHOW VARIABLES LIKE 'have_symlink'语句，检查系统是否支持符号链接。
只有MyISAM表完全支持符号链接。对于其它表类型，如果试图在操作系统中的文件上用前面的任何语句使用符号链接，可能会出现奇怪的问题。
对于MyISAM表的符号链接的处理如下：
·         在数据目录指，一定会有表定义文件、数据文件和索引文件。数据文件和索引文件可以移到别处和在数据目录中符号链接替代。表定义文件不能进行符号链接替换。
·         可以分别通过符号链接将数据文件和索引文件指到不同的目录。
·         如果mysqld没有运行，符号链接可以从服务器命令行使用ln -s手动完成。同样，通过使用DATA DIRECTORY和INDEX DIRECTORY选项创建表，你可以指示运行的MySQL服务器执行符号链接。参见13.1.5节，“CREATE TABLE语法”。
·         myisamchk不用数据文件或索引文件替换符号链接。它直接工作在符号链接指向的文件。任何临时文件创建在数据文件或索引文件所处的目录中。
·         注释：当你删掉一个表时，如果该表使用了符号链接，符号链接和该符号链接指向的文件都被删除掉。这就是你不应以系统root用户运行mysqld或允许系统用户对MySQL数据库目录有写访问权限的原因。
·         如果你用ALTER TABLE ... RENAME重命名一个表并且不将表移到另一个数据库，数据库目录中的符号链接被重新命名为一个新名字并且数据文件和索引文件也相应地重新命名。
·         如果你用ALTER TABLE ... RENAME移动一个表到另一个数据库，表移动到另一个数据库目录。旧的符号链接和其所指向的文件被删除。换句话说，新表不再被链接。
·         如果不使用符号链接，你应对mysqld使用--skip-symbolic-links选项以确保没有人能够使用mysqld来删除或重新命名数据目录之外的文件。
表符号链接还不支持以下操作：
·         ALTER TABLE忽略DATA DIRECTORY 和INDEX DIRECTORY表选项。
·         BACKUP TABLE 和RESTORE TABLE不考虑符号链接。
·         .frm文件必须绝不能是一个符号链接（如前面所述，只有数据和索引文件可以是符号链接）。如果试图这样做（例如，生成符号链接）会产生不正确的结果。假定你在MySQL数据目录下有一个数据库db1，该数据库有一个表tbl1，并且在db1目录中你制作了一个符号链接tbl2指向tbl1：
·                shell> cd /path/to/datadir/db1
·                shell> ln -s tbl1.frm tbl2.frm
·                shell> ln -s tbl1.MYD tbl2.MYD
·                shell> ln -s tbl1.MYI tbl2.MYI
如果一个线程读取db1.tbl1同时另一个线程更新 db1.tbl2会发生问题：
o        查询缓存将变为“傻瓜” (它没有办法知道tbl1是否被更新，因此它返回过时的结果)。
o        tbl2上的ALTER语句也会失败。
7.6.1.3. 在Windows平台上使用关于数据库的符号链接
Windows的mysqld-max和mysql-max-nt服务器使用-DUSE_SYMDIR选项编译成。允许你放置数据库目录到一个不同的硬盘，通过设置一个符号链接指向它。这类似于Unix中的符号链接，尽管设置链接的过程不同。
符号链接默认为启用。如果你不需要，使用skip-symbolic-links选项来禁用它：
[mysqld]
skip-symbolic-links
在Windows中，通过在数据目录中创建一个文件，该文件包含目标目录的路径，你可以为MySQL数据库创建一个符号链接。该文件应该被命名为db_name.sym，其中db_name是数据库名。
假定MySQ数据目录是C:\mysql\data并且你想要数据库foo放置在D:\data\foo。设置一个符号链接如下所示：
1.    确保D:\data\foo目录存在，如果必要创建它。如果你在数据目录内有一个命名为foo的数据库目录，你应移动它到D:\data目录。否则，符号链接无效。为避免出现问题，当你移动数据库目录时服务器不应该运行。
2.    创建一个文本文件C:\mysql\data\foo.sym，该本文文件包含路径名D:\data\foo\。
此后，数据库foo创建的所有表将创建在D:\data\foo文件中。请注意，如果在MySQL数据目录中存在同名的数据库目录，不能使用符号链接。
第8章：客户端和实用工具程序
目录
8.1. 客户端脚本和实用工具概述 
8.2. myisampack：生成压缩、只读MyISAM表 
8.3. mysql：MySQL命令行工具 
8.3.1. 选项 
8.3.2. mysql命令 
8.3.3. 怎样从文本文件执行SQL语句 
8.3.4. mysql技巧
8.4. mysqlaccess：用于检查访问权限的客户端 
8.5. mysqladmin：用于管理MySQL服务器的客户端 
8.6. mysqlbinlog：用于处理二进制日志文件的实用工具 
8.7. mysqlcheck：表维护和维修程序 
8.8. mysqldump：数据库备份程序 
8.9. mysqlhotcopy：数据库备份程序 
8.10. mysqlimport：数据导入程序 
8.11. mysqlshow－显示数据库、表和列信息 
8.12. myisamlog：显示MyISAM日志文件内容 
8.13. perror：解释错误代码 
8.14. replace：字符串替换实用工具 
8.15. mysql_zap：杀死符合某一模式的进程
有许多不同的MySQL客户端程序可以连接服务器以访问数据库或执行管理任务。也可以使用其它工具。这些程序不与服务器进行通讯但可以执行MySQL相关的操作。
本章简述了这些程序然后详细描述了每个程序。描述了如何调用这些程序和它们理解的选项。调用程序和指定程序选项的总信息参见第4章：MySQL程序概述。
8.1. 客户端脚本和实用工具概述
下面简单列出了MySQL客户端程序和实用工具：
·         myisampack
压缩MyISAM表以产生更小的只读表的一个工具。参见8.2节，“myisampack：生成压缩、只读MyISAM表”。
·         mysql
交互式输入SQL语句或从文件以批处理模式执行它们的命令行工具。参见8.3节，“mysql：MySQL命令行工具”。
·         mysqlaccess
检查访问主机名、用户名和数据库组合的权限的脚本。
·         mysqladmin
执行管理操作的客户程序，例如创建或删除数据库，重载授权表，将表刷新到硬盘上，以及重新打开日志文件。mysqladmin还可以用来检索版本、进程，以及服务器的状态信息。参见8.5节，“mysqladmin：用于管理MySQL服务器的客户端”。
·         mysqlbinlog
从二进制日志读取语句的工具。在二进制日志文件中包含的执行过的语句的日志可用来帮助从崩溃中恢复。参见8.6节，“mysqlbinlog：用于处理二进制日志文件的实用工具”。
·         mysqlcheck
检查、修复、分析以及优化表的表维护客户程序。参见8.7节，“mysqlcheck：表维护和维修程序”。
·         mysqldump
将MySQL数据库转储到一个文件（例如SQL语句或tab分隔符文本文件）的客户程序。增强版免费软件首先由Igor Romanenko提供。参见8.8节，“mysqldump：数据库备份程序”。
·         mysqlhotcopy
当服务器在运行时，快速备份MyISAM或ISAM表的工具。参见8.9节，“mysqlhotcopy：数据库备份程序”。
·         mysql import
使用LOAD DATA INFILE将文本文件导入相关表的客户程序。参见8.10节，“mysqlimport：数据导入程序”。
·         mysqlshow
显示数据库、表、列以及索引相关信息的客户程序。参见8.11节，“mysqlshow：显示数据库、表和列信息”。
·         perror
显示系统或MySQL错误代码含义的工具。参见8.13节，“perror：解释错误代码”。
·         replace
更改文件中或标准输入中的字符串的实用工具。参见8.14节，“replace：字符串替换实用工具”。
MySQL AB还提供了大量GUI工具用于管理和MySQL服务器的其它工作。相关基本信息参见第4章：MySQL程序概述。
每个MySQL程序有许多不同的选项。但每个MySQL程序均提供一个---help选项，可以用来全面描述程序不同的选项。例如，可以试试mysql---help。
使用mysqlclient库同服务器进行通讯的MySQL客户使用下面的环境变量：
MYSQL_UNIX_PORT
默认Unix套接字文件；用于连接localhost
MYSQL_TCP_PORT
默认端口号；用于TCP/IP连接
MYSQL_PWD
默认密码
MYSQL_DEBUG
调试过程中的调试跟踪选项
TMPDIR
创建临时表和文件的目录
使用MYSQL_PWD不安全。参见5.8.6节，“使你的密码安全”。
可以在选项文件中或在命令行中指定选项来替换所有标准程序的默认选项值或指定的环境变量的值。参见4.3节，“指定程序选项”。
8.2. myisampack：生成压缩、只读MyISAM表
myisampack工具可以压缩MyISAM表.MYIsampack分别压缩表中的每一列。通常，myisampack可以将数据文件压缩到40%-70%。
当以后使用表时，解压缩列需要的信息被读入内存。当访问具体的记录时性能会更好，因为你只需要解压缩一个记录。
MySQL使用mmap()对压缩的表进行内存映射。如果mmap()不工作，MySQL返回到普通读/写文件操作。
请注意：
·         如果用--skip-external-locking选项调用mysqld服务器，如果在压缩过程中表可能被更新，调用myisampack不是一个好注意。
·         表压缩后，它变为只读。这是故意的(例如当访问CD上的压缩的表时)。允许写入到压缩的表位于我们的TODO列表中，但优先级较低。
·         myisampack可以压缩BLOB或TEXT列。旧版本ISAM表的pack_isam程序不可以。
调用myisampack的方法：
shell> myisampack [options] filename ...
文件名应为索引(.MYI)文件的文件名。如果不在数据库目录，应指定文件的路径名。允许忽略.MYI扩展名。
myisampack支持下面的选项：
·         --help，-？
显示帮助消息并退出。
·         --backup，-b
使用tbl_name.OLD名备份表数据文件。
·         ---debug[=debug_options]，-# [debug_options]
写调试日志。debug_options字符串通常为'd:t:o,file_name'。
·         --force，-f
产生一个压缩的表，即使它比原始表大，或如果以前调用myisampack的中间文件存在。(myisampack压缩表时在数据库目录中创建一个名为tbl_name.TMD的中间文件。如果杀掉myisampack，.TMD文件会被删除）。通常情况，如果myisampack发现tbl_name.TMD存在则退出并提示错误。用--force，myisampack则一定压缩表。
·         -join=big_tbl_name，-j big_tbl_name
将命令行中的所有表联接为一个表big_tbl_name。将要连接的所有表必须有相等的结构(相同的列名和类型，相同的索引等等)。
·         --pack length=len，-p len
指定记录长度存储大小，以字节计。值应为1、2或者3。myisampack保存所有长度指针为1、2或者3字节的行。在大多数正常情况下，myisampack在开始压缩文件前可以确定准确的长度值，但在压缩过程中它可以提示它可能已经使用了一个短的长度。在这种情况下，myisampack输出一条提示，下次你压缩同一文件时，你可以使用更短的记录长度。
·         --silent，-s
沉默模式。只有发生错误时才写输出。
·         --test，-t
没有实际地压缩表，只是测试压缩。
·         --tmpdir=path，-T path
使用myisamchk创建临时文件的目录。
·         --verbose，-v
冗长模式。写压缩操作过程相关信息和其结果。
·         --version，-V
显示版本信息并退出。
·         --wait，-w
如果表正使用则等待并重试。如果用--skip-external-locking选项调用了mysqld服务器，如果在压缩过程中表可能被更新，调用myisampack不是一个好注意。
下面的顺序命令说明了典型的表压缩会话：
shell> ls -l station.*
-rw-rw-r--   1 monty    my         994128 Apr 17 19:00 station.MYD
-rw-rw-r--   1 monty    my          53248 Apr 17 19:00 station.MYI
-rw-rw-r--   1 monty    my           5767 Apr 17 19:00 station.frm
 
shell> myisamchk -dvv station
 
MyISAM file:     station
Isam-version:  2
Creation time: 1996-03-13 10:08:58
Recover time:  1997-02-02  3:06:43
Data records:              1192  Deleted blocks:              0
Datafile parts:            1192  Deleted data:                0
Datafile pointer (bytes):     2  Keyfile pointer (bytes):     2
Max datafile length:   54657023  Max keyfile length:   33554431
Recordlength:               834
Record format: Fixed length
 
table description:
Key Start Len Index   Type                 Root  Blocksize    Rec/key
1   2     4   unique  unsigned long        1024       1024          1
2   32    30  multip. text                10240       1024          1
 
Field Start Length Type
1     1     1
2     2     4
3     6     4
4     10    1
5     11    20
6     31    1
7     32    30
8     62    35
9     97    35
10    132   35
11    167   4
12    171   16
13    187   35
14    222   4
15    226   16
16    242   20
17    262   20
18    282   20
19    302   30
20    332   4
21    336   4
22    340   1
23    341   8
24    349   8
25    357   8
26    365   2
27    367   2
28    369   4
29    373   4
30    377   1
31    378   2
32    380   8
33    388   4
34    392   4
35    396   4
36    400   4
37    404   1
38    405   4
39    409   4
40    413   4
41    417   4
42    421   4
43    425   4
44    429   20
45    449   30
46    479   1
47    480   1
48    481   79
49    560   79
50    639   79
51    718   79
52    797   8
53    805   1
54    806   1
55    807   20
56    827   4
57    831   4
 
shell> myisampack station.MYI
Compressing station.MYI: (1192 records)
- Calculating statistics
 
normal:     20  empty-space:   16  empty-zero:     12  empty-fill:  11
pre-space:   0  end-space:     12  table-lookups:   5  zero:         7
Original trees:  57  After join: 17
- Compressing file
87.14%
Remember to run myisamchk -rq on compressed tables
 
shell> ls -l station.*
-rw-rw-r--   1 monty    my         127874 Apr 17 19:00 station.MYD
-rw-rw-r--   1 monty    my          55296 Apr 17 19:04 station.MYI
-rw-rw-r--   1 monty    my           5767 Apr 17 19:00 station.frm
 
shell> myisamchk -dvv station
 
MyISAM file:     station
Isam-version:  2
Creation time: 1996-03-13 10:08:58
Recover time:  1997-04-17 19:04:26
Data records:               1192  Deleted blocks:              0
Datafile parts:             1192  Deleted data:                0
Datafile pointer (bytes):      3  Keyfile pointer (bytes):     1
Max datafile length:    16777215  Max keyfile length:     131071
Recordlength:                834
Record format: Compressed
 
table description:
Key Start Len Index   Type                 Root  Blocksize    Rec/key
1   2     4   unique  unsigned long       10240       1024          1
2   32    30  multip. text                54272       1024          1
 
Field Start Length Type                         Huff tree  Bits
1     1     1      constant                             1     0
2     2     4      zerofill(1)                          2     9
3     6     4      no zeros, zerofill(1)                2     9
4     10    1                                           3     9
5     11    20     table-lookup                         4     0
6     31    1                                           3     9
7     32    30     no endspace, not_always              5     9
8     62    35     no endspace, not_always, no empty    6     9
9     97    35     no empty                             7     9
10    132   35     no endspace, not_always, no empty    6     9
11    167   4      zerofill(1)                          2     9
12    171   16     no endspace, not_always, no empty    5     9
13    187   35     no endspace, not_always, no empty    6     9
14    222   4      zerofill(1)                          2     9
15    226   16     no endspace, not_always, no empty    5     9
16    242   20     no endspace, not_always              8     9
17    262   20     no endspace, no empty                8     9
18    282   20     no endspace, no empty                5     9
19    302   30     no endspace, no empty                6     9
20    332   4      always zero                          2     9
21    336   4      always zero                          2     9
22    340   1                                           3     9
23    341   8      table-lookup                         9     0
24    349   8      table-lookup                        10     0
25    357   8      always zero                          2     9
26    365   2                                           2     9
27    367   2      no zeros, zerofill(1)                2     9
28    369   4      no zeros, zerofill(1)                2     9
29    373   4      table-lookup                        11     0
30    377   1                                           3     9
31    378   2      no zeros, zerofill(1)                2     9
32    380   8      no zeros                             2     9
33    388   4      always zero                          2     9
34    392   4      table-lookup                        12     0
35    396   4      no zeros, zerofill(1)               13     9
36    400   4      no zeros, zerofill(1)                2     9
37    404   1                                           2     9
38    405   4      no zeros                             2     9
39    409   4      always zero                          2     9
40    413   4      no zeros                             2     9
41    417   4      always zero                          2     9
42    421   4      no zeros                             2     9
43    425   4      always zero                          2     9
44    429   20     no empty                             3     9
45    449   30     no empty                             3     9
46    479   1                                          14     4
47    480   1                                          14     4
48    481   79     no endspace, no empty               15     9
49    560   79     no empty                             2     9
50    639   79     no empty                             2     9
51    718   79     no endspace                         16     9
52    797   8      no empty                             2     9
53    805   1                                          17     1
54    806   1                                           3     9
55    807   20     no empty                             3     9
56    827   4      no zeros, zerofill(2)                2     9
57    831   4      no zeros, zerofill(1)                2     9
myisampack显示下面的各种信息：
·         normal
不需要进行额外压缩的列的数量。
·         empty-space
只包含空格的列的数量；占一个比特。
·         empty-zero
只包含二进制零的列的数量；占一个比特。
·         empty-fill
不占该类全字节范围的整数列的数量；这些列被改为较小的类型。例如，如果所有值的范围为从-128到127，BIGINT列(8个字节)可以保存为TINYINT列(1个字节)。
·         pre-space
用引导空格保存的十进制列的数量。在这种情况下，每个值包含一个引导空格的数量计数。
·         end-space
有大量结尾空格的列的数量。在这种情况下，每个值包含一个结尾空格的数量计数。
·         table-lookup
该列只有少量的不同的值，在进行哈夫曼压缩前被转换为一个ENUM。
·         zero
所有值为零的列的数量。
·         Original trees
哈夫曼树的最初数量。
·         After join
联接树以节省一些头空间之后留下的哈夫曼树的数量。
表被压缩后，myisamchk -dvv为每列输出详细信息：
·         Type
列的类型。该值可以包含下面的任何描述符：
o        constant
所有行具有相同的值。
o        no endspace
不保存结尾空格。
o        no endspace，not_always
不保存结尾空格并且对于所有的值不压缩结尾空格。
o        no endspace，no empty
不保存结尾空格。不保存空值。
o        table-lookup
列被转换为一个ENUM。
o        zerofill(n)
值中最有意义的n字节总为0，并且不保存。
o        no zeros
不保存零。
o        always zeros
用一个位保存零值。
·         Huff tree
列相关的哈夫曼树的数量。
·         Bits
哈夫曼树使用的位数。
运行myisampack后，必须运行myisamchk以重新创建索引。此时，你也可以排序索引块并创建MySQL优化器需要的统计信息以更有效地工作：
shell> myisamchk -rq --sort-index --analyze tbl_name.MYI
将压缩的表安装到MySQL数据库目录中后，应执行mysqladmin flush-tables以强制mysqld使用新的表。
要想解压缩一个压缩的表，使用myisamchk或isamchk的--unpack选项。
8.3. mysql：MySQL命令行工具
8.3.1. 选项 
8.3.2. mysql命令 
8.3.3. 怎样从文本文件执行SQL语句 
8.3.4. mysql技巧
mysql是一个简单的SQL外壳(有GNU readline功能)。它支持交互式和非交互式使用。当交互使用时，查询结果采用ASCII表格式。当采用非交互式(例如，用作过滤器)模式时，结果为tab分割符格式。可以使用命令行选项更改输出格式。
如果由于结果较大而内存不足遇到问题，使用--quick选项。这样可以强制mysql从服务器每次一行搜索结果，而不是检索整个结果集并在显示之前不得不将它保存到内存中。使用mysql_use_result()而不是mysql_store_result()来搜索结果集。
使用mysql很简单。从命令解释符提示来调用它：
shell> mysql db_name
或：
shell> mysql --user=user_name --password=your_password db_name
这样输入一个SQL语句，用‘；’、\g或者\G结尾并按回车键。
你可以这样运行一个脚本：
shell> mysql db_name < script.sql > output.tab
8.3.1. 选项
mysql支持下面的选项：
·         ---help，-？
显示帮助消息并退出。
·         --batch，-B
打印结果，使用tab作为列间隔符，每个行占用新的一行。使用该选项，则mysql不使用历史文件。
·         --character-sets -dir=path
字符集的安装目录。参见5.10.1节，“数据和排序用字符集”。
·         --compress，-C
压缩在客户端和服务器之间发送的所有信息（如果二者均支持压缩）。
·         ---database=db_name，-D db_name
要使用的数据库。主要在选项文件中有用。
·         ---debug[=debug_options]，-# [debug_options]
写调试日志。debug_options字符串通常为'd:t:o,file_name'。 默认为'd:t:o,/tmp/mysql.trace'。
·         ---debug-info，-T
当程序退出时输出部分调试信息。
·         --default-character-set=charset
使用charsetas作为默认字符集。参见5.10.1节，“数据和排序用字符集”。
·         --execute=statement, -e statement
执行语句并退出。默认输出格式与用--batch产生的相同。4.3.1节，“在命令行上使用选项”中提供了一些例子。
·         --force，-f
即使出现一个SQL错误仍继续。
·         --host=host_name，-h host_name
连接给定主机上的MySQL服务器。
·         --html，-H
产生HTML输出。
·         --ignore-space，-i
忽视函数名后面的空格。其结果描述参见5.3.2节，“SQL服务器模式”中的IGNORE_SPACE的讨论。
·         --local-infile[={0|1}]
为LOAD DATA INFILE启用或禁用LOCAL功能。没有值，该选项启用LOCAL。还可以采用--local-infile=0或--local-infile=1以显式禁用或启用LOCAL。如果服务器不支持，启用LOCAL不会生效。
·         --named-commands，-G
命名的命令被启用。允许长格式命令和短格式\*命令。例如，quit和\q均被识别。
·         --no-auto-rehash，-A
不自动重新进行哈希运算。该选项使mysql启动得更快，但果你想要完成表和列名，你必须发出rehash命令。
·         --no-beep，-b
当发生错误时不要保持。
·         --no-named-commands，-g
命名的命令被禁用。只使用\*形式，或者只使用行开头的命名用分号(‘；’)结束的的命令。对于MySQL 3.23.22，默认情况mysql启动时启用该选项。然而，即使使用该选项，长格式命令仍然从第1行工作。
·         --no-pager
不使用分页器来显示查询输出。在8.3.2节，“mysql命令”中详细讨论了输出分页。
·         --no-tee
不将输出复制到文件中。在8.3.2节，“mysql命令”中详细讨论了Tee文件。
·         --one--database，-O
忽视除了为命令行中命名的默认数据库的语句。可以帮助跳过对二进制日志中的其它数据库的更新。
·         --pager[=command]
使用给出的命令来分页查询输出。如果该命令被删除，默认分页器为PAGER环境变量的值。合法pagers是less、more、cat [>filename]等等。该选项只在Unix中工作。不能以批处理模式工作。在8.3.2节，“mysql命令”中详细讨论了输出分页。
·         --password[=password]，-p[password]
当连接服务器时使用的密码。如果使用短选项形式(-p)，选项和 密码之间不能有空格。如果在命令行中--password或-p选项后面没有 密码值，则提示输入一个密码。在SysV-based UNIX系统中应省略密码，因为密码可以显示在ps的输出中。
·         --port=port_num，-P port_num
用于连接的TCP/IP端口号。
·         --prompt=format_str
将提示设置为指定的格式。默认为mysql>。在8.3.2节，“mysql命令”中描述了提示中可以包含的具体顺序。
·         --protocol={TCP | SOCKET | PIPE | MEMORY}
使用的连接协议。
·         --quick，-q
不缓存每个查询的结果，按照接收顺序打印每一行。如果输出被挂起，服务器会慢下来。使用该选项，mysql不使用历史文件。
·         --raw，-r
写列的值而不转义转换。通常结合--batch选项使用。
·         --reconnect
如果与服务器之间的连接断开，自动尝试重新连接。每次连接断开后则尝试一次重新连接。要想禁止重新连接，使用--skip-reconnect。
·         --safe-updates，--i-am-a-dummy，-U
只允许那些使用键值指定行生效的UPDATE和DELETE语句。如果已经在选项文件中设置了该选项，可以用命令行中的--safe-updates覆盖它。关于该选项的详细信息参见8.3.4节，“mysql技巧”。
·         --secure-auth
不向旧(pre-4.1.1)格式的服务器发送密码。这样可以防止不使用新密码格式的服务器的连接。
·         --show-warnings
如果每个语句后有警告则显示。该选项适用于交互式和批处理模式。
·         --sigint-ignore
忽视SIGINT符号(一般为Control-C的结果)。
·         --silent，-s
沉默模式。产生少的输出。可以多次使用该选项以产生更少的输出。
·         --skip-column-names，-N
在结果中不写列名。
·         --skip-line-numbers，-L
在错误信息中不写行号。当你想要比较包括错误消息的结果文件时有用。
·         --socket=path，-S path
用于连接的套接字文件。
·         --tables，-t
用表格式显示输出。这是交互式应用的默认设置，但可用来以批处理模式产生表输出。
·         --tee=file_name
将输出拷贝添加到给定的文件中。该选项在批处理模式不工作。在8.3.2节，“mysql命令”中详细讨论了Tee文件。
·         --unbuffered，-n
每次查询后刷新缓存区。
·         --user=user_name，-u user_name
当连接服务器时MySQL使用的用户名。
·         --verbose，-v
冗长模式。产生更多的输出。可以多次使用该选项以产生更多的输出。(例如，-v -v -v甚至可以在批处理模式产生表输出格式）。
·         --version，-V
显示版本信息并退出。
·         --vertical，-E
垂直输出查询输出的行。没有该选项，可以用\G结尾来指定单个语句的垂直输出。
·         --wait，-w
如果不能建立连接，等待并重试而不是放弃。
·         --xml，-X
产生XML输出。
你还可以使用--var_name=value选项设置下面的变量：
·         connect_timeout
连接超时前的秒数。(默认值是0）。
·         max_allowed_packet
从服务器发送或接收的最大包长度。(默认值是16MB）。
·         max_join_size
当使用--safe-updates时联接中的行的自动限制。(默认值是1,000,000）。
·         net_buffer_length
TCP/IP和套接字通信缓冲区大小。(默认值是16KB）。
·         select_limit
当使用--safe-updates时SELECT语句的自动限制。(默认值是1,000）。
也可以使用--set-variable=var_name=value or -O var_name=value语法来设置变量。不赞成使用该语法。
在Unix中，mysql客户程序向历史文件中写入已执行语句的一条记录。默认情况，历史文件名为.mysql_history并在根目录中重建。要想指定不同的文件，应设置MYSQL_HISTFILE环境变量的值。
如果不想要历史文件，首先删除.mysql_history（如果有），然后使用下面的任何一种方法：
·         将MYSQL_HISTFILE变量设到/dev/null。要想在每次登录时让该设置生效，将该设置放入外壳的一个启动文件中。
·         创建.mysql_history，作为一个符号链接指向/dev/null：
·                shell> ln -s /dev/null $HOME/.mysql_history
只需要执行一次。
8.3.2. mysql命令
mysql将发出的SQL语句发送到待执行的服务器。还有一系列命令mysql可以自己解释。要查看这些命令，在mysql>提示下输入help或\h：
mysql> help

List of all MySQL commands:
Note that all text commands must be first on line and end with ';'
?         (\?) Synonym for `help'.
clear     (\c) Clear command.
connect   (\r) Reconnect to the server. Optional arguments are db and host.
delimiter (\d) Set statement delimiter. NOTE: Takes the rest of the line as new delimiter.
edit      (\e) Edit command with $EDITOR.
ego       (\G) Send command to mysql server, display result vertically.
exit      (\q) Exit mysql. Same as quit.
go        (\g) Send command to mysql server.
help      (\h) Display this help.
nopager   (\n) Disable pager, print to stdout.
notee     (\t) Don't write into outfile.
pager     (\P) Set PAGER [to_pager]. Print the query results via PAGER.
print     (\p) Print current command.
prompt    (\R) Change your mysql prompt.
quit      (\q) Quit mysql.
rehash    (\#) Rebuild completion hash.
source    (\.) Execute a SQL script file. Takes a file name as an argument.
status    (\s) Get status information from the server.
system    (\!) Execute a system shell command.
tee       (\T) Set outfile [to_outfile]. Append everything into given outfile.
use       (\u) Use another database. Takes database name as argument.
warnings  (\W) Show warnings after every statement.
nowarning (\w) Don't show warnings after every statement.
每个命令有长形式和短形式。长形式对大小写不敏感；短形式敏感。长形式后面可以加一个分号结束符，但短形式不可以。
在delimiter命令中，应避免使用反斜线(‘\’)，因为这是MySQL的转义符。
Edit、nopager、pager和system命令只在Unix中工作。
status命令提供连接和使用的服务器相关的部分信息。如果用--safe-updates模式运行，status也打印影响查询的MySQL变量的值。
要想记录查询及其输出，应使用tee命令。屏幕上显示的所有数据被追加到给定的文件后面。这对于调试也很有用。可以用--tee选项在命令行中启用该特性，或者用tee命令交互式启用。可以用notee命令交互式禁用tee文件。再次执行tee可以重新启用日志。前面的文件使用时不带任何参数。请注意执行完每个语句后tee可以将查询结果刷新到一个文件中，并且在mysql打印下一个提示前刷新。
用--pager选项，可以用交互式模式使用Unix程序，例如less、more或者其它类似的程序，来浏览或搜索查询结果。如果未指定该选项的值，mysql检查PAGER环境变量的值并将PAGER设为该值。可以用pager命令交互式启用输出分页，并用nopager禁用。该命令采用可选参量；如果给出，分页程序设置为该值。如果没有给出参量，分页器被设置为在命令行中设置的分页器的值，如果未指定分页器，则设置为stdout。
输出分页只适合Unix，因为它使用popen()函数，该函数在Windows中不存在。在Windows中，可以使用tee选项来保存查询输出，尽管在某些情况下浏览输出时不如pager方便。
关于pager命令的一些技巧：
·         可以使用它写入一个文件，将结果只输出到该文件中：
·                mysql> pager cat > /tmp/log.txt
也可以为将用作分页器的程序传递选项：
mysql> pager less -n -i -S
·         注意前面例子中的-S选项。它可以帮助浏览广范围的查询结果。有时太广的结果很难在屏幕上读出来。less的-S选项可以使结果更易于读，因为可以用左、右箭头水平滚动它。还可以在less中交互式使用-S，以关闭或打开水平浏览模式。详细信息请阅读手册中的less页：
·                shell> man less
·         可以指定很复杂的pager命令来处理查询输出：
·                mysql> PAGER cat | tee /dr1/tmp/res.txt \
·                          | tee /dr2/tmp/res2.txt | less -n -i -S
在该例子中，该命令将查询结果发送到位于/dr1和/dr2上安装的两个不同的文件系统中的两个不同目录中的两个文件中，但仍然可以通过less将结果显示在屏幕上。
还可以结合使用tee和pager函数。启用一个tee文件并将pager设置为less，能够使用less 程序浏览结果，并且仍然可以同时将内容添加到一个文件中。结合pager命令使用的Unix tee和 mysql嵌入式tee命令的差别是即使没有可用的Unix tee，嵌入式tee仍然可以工作。嵌入式tee还可以记录在屏幕上输出的内容，而结合pager命令使用的Unix tee不能记录那么多的内容。并且，可以从MySQL中交互式打开或关闭tee文件日志。当你想要将部分查询记录到一个文件中时很有用，但其它不适合。
默认mysql>提示符可以重新配置。定义提示符的字符串可以包含下面的特殊序列：
选项
描述
\v
服务器版本
\d
当前的数据库
\h
服务器主机
\p
当前的TCP/IP端口或套接字文件
\u
你的用户名
\U
你的全user_name@host_name账户名
\\
‘\’反斜线字符
\n
新行字符
\t
Tab字符
\ 
空格(反斜线后面的空格)
\_
空格
\R
当前的时间，24-小时军用时间(0-23)
\r
当前的时间，标准12-小时(1-12)
\m
当前时间的分钟
\y
当前的年，两位
\Y
当前的年，四位
\D
当前的日期
\s
当前时间的秒
\w
当前周的天，3字符格式(Mon，Tue，...)
\P
am/pm
\o
当前的月，数字格式
\O
当前的月，3字符格式(Jan，Feb，...)
\c
随发出的每个语句递增的计数
\S
分号
\'
单引号
\"
双引号
‘\’后面跟随的其它字母则变为该字母。
如果不用任何参量指定提示命令，mysql将提示重新设置位默认mysql>。
可以用几种方式设置提示：
·         使用环境变量 
可以用MYSQL_PS1环境变量来设置提示字符串。例如：
shell> export MYSQL_PS1="(\u@\h) [\d]> "
·         使用选项文件
可以在MySQL选项文件中的[mysql]组设置提示，例如根目录中的/etc/my.cnf或.my.cnf文件。例如：
[mysql]
prompt=(\\u@\\h) [\\d]>\\_
在该例子中，请注意反斜线是双线。如果使用选项文件中的prompt选项来设置提示，当使用特殊提示选项时，建议使用双反斜线。在允许的提示选项和选项文件中可识别的特殊转义序列中有部分重叠。(这些序列列于4.3.2节，“使用选项文件”）。如果使用单反斜线，会遇到问题。例如，\s被解释为空格而不是当前的秒值。下面的例子显示了如何在选项文件中定义提示以包括当前的时间，格式为HH:MM:SS>：
[mysql]
prompt="\\r:\\m:\\s> "
·         使用命令行选项
可以在mysql的命令行中设置--prompt选项。例如：
shell> mysql --prompt="(\u@\h) [\d]> "
(user@host) [database]>
·         交互式
你可以使用prompt(或\R)命令交互地更改提示。例如：
mysql> prompt (\u@\h) [\d]>\_
PROMPT set to '(\u@\h) [\d]>\_'
(user@host) [database]>
(user@host) [database]> prompt
Returning to default PROMPT of mysql>
mysql>
8.3.3. 怎样从文本文件执行SQL语句
mysql客户程序一般交互使用：
shell> mysql db_name
还可以将SQL语句放到一个文件中然后告诉mysql从该文件读取输入。要想实现，创建一个文本文件text_file，并包含你想要执行的语句。然后按如下所示调用mysql：
shell> mysql db_name < text_file
还可以用一个USE db_name语句启动文本文件。在这种情况下，不需要在命令行中指定数据库名：
shell> mysql < text_file
如果正运行mysql，可以使用source或\.命令执行SQL脚本文件：
mysql> source filename
mysql> \. filename
有时想要使用脚本来向用户显示进度信息；为此可以插入下述行：
SELECT '<info_to_display>' AS ' '；
将输出<info_to_display>。
关于批处理模式的详细信息，参见3.5节，“在批处理模式下使用mysql”。
8.3.4. mysql技巧
8.3.4.1. 垂直显示查询结果 
8.3.4.2. 使用--safe-updates选项 
8.3.4.3. 禁用mysql自动连接
该节描述了可以帮助你更有效使用mysql的一些技术。
8.3.4.1. 垂直显示查询结果
一些查询结果如果垂直显示而不用通常的水平表格式显示，则更容易读取。用\G而不用分号结束查询可以垂直显示查询。例如，包括新行的更长的文本值垂直输出时通常更容易读取：
mysql> SELECT * FROM mails WHERE LENGTH(txt) < 300 LIMIT 300,1\G
*************************** 1. row ***************************
  msg_nro: 3068
     date: 2000-03-01 23:29:50
time_zone: +0200
mail_from: Monty
    reply: monty@no.spam.com
  mail_to: "Thimble Smith" <tim@no.spam.com>
      sbj: UTF-8
      txt: >>>>> "Thimble" == Thimble Smith writes:

Thimble> Hi.  I think this is a good idea.  Is anyone familiar
Thimble> with UTF-8 or Unicode? Otherwise, I'll put this on my
Thimble> TODO list and see what happens.

Yes, please do that.

Regards,
Monty
     file: inbox-jani-1
     hash: 190402944
1 row in set (0.09 sec)
8.3.4.2. 使用--safe-updates选项
对于新手，有一个有用的启动选项--safe-updates(或--i-am-a-dummy，具有相同的效果)。当你已经发出一个DELETE FROM tbl_name语句但忘记了WHERE子句时很有用。通常情况，这样的语句从表中删除所有行。用--safe-updates，可以通过指定可以识别它们的键值只删除某些行。这样可以帮助防止事故。
若使用--safe-updates选项，mysql连接MySQL服务器时发出下面的语句：
SET SQL_SAFE_UPDATES=1,SQL_SELECT_LIMIT=1000, SQL_MAX_JOIN_SIZE=1000000;
参见13.5.3节，“SET语法”。
SET语句有下面的效果：
·         不允许你执行UPDATE或DELETE语句，除非在WHERE子句中指定一个键值约束或提供一个LIMIT子句(或二者皆使用)。例如：
·                UPDATE tbl_name SET not_key_column=val WHERE key_column=val;
·                 
·                UPDATE tbl_name SET not_key_column=val LIMIT 1;
·         所有大的SELECT结果自动限制到1,000行，除非语句包括一个LIMIT子句。
·         放弃可能需要检查1,000,000多行组合的多表SELECT语句。
要将限制指定为1,000和1,000,000之外的值，可以使用--select_limit和--max_join_size选项覆盖默认值：
shell> mysql --safe-updates --select_limit=500 --max_join_size=10000
8.3.4.3. 禁用mysql自动连接
如果mysql客户程序发送查询时断开与服务器的连接，它立即并自动尝试重新连接服务器并再次发送查询。然而，即使mysql重新连接成功，你的第1个连接也已经结束，并且以前的会话对象和设定值被丢失：包括临时表、自动提交模式，以及用户和会话变量。该行为很危险，如下面的例子所示，服务器将在你不知道的情况下关闭并重启：
mysql> SET @a=1;
Query OK, 0 rows affected (0.05 sec)
 
mysql> INSERT INTO t VALUES(@a);
ERROR 2006: MySQL server has gone away
No connection. Trying to reconnect...
Connection id:    1
Current database: test
 
Query OK, 1 row affected (1.30 sec)
 
mysql> SELECT * FROM t;
+------+
| a    |
+------+
| NULL |
+------+
1 row in set (0.05 sec)
@a用户变量已经随连接丢失，并且重新连接后它也没有定义。如果有必要在连接断开时终止mysql并提示错误，你可以用--skip-reconnect选项启动mysql客户程序。
8.4. mysqlaccess：用于检查访问权限的客户端
mysqlaccess是Yves Carlier为MySQL分发提供的一个诊断工具。它检查访问权限的主机名、用户名和数据库组合。请注意 mysqlaccess检查只使用user、db和host表的访问。它不检查在tables_priv、columns_priv或procs_priv表中指定的表、列或者程序的权限。
调用mysqlaccess的方法：
shell> mysqlaccess [host_name [user_name [db_name]]] [options]
mysqlaccess理解下面的选项：
·         ---help，-？
显示帮助消息并退出。
·         --brief，-b 
生成单行表格式的报告。
·         --commit 
从临时表将新访问权限复制到原授权表。必须为新的权限刷新授权表以使其生效。(例如，执行mysqladmin RELOAD命令）。
·         --copy
从原授权表重载临时授权表。
·         --db=db_name，-d db_name
指定数据库名。
·         ---debug=N
指定调试级别。N可以为从0到3的一个整数。
·         --host=host_name，-h host_name
在访问权限中使用的主机名。
·         --howto
显示一些例子显示如何使用mysqlaccess。
·         --old_server
假定服务器是一个旧版本的MySQL服务器(MySQL 3.21之前)，还不知道如何处理全WHERE子句。
·         --password[=password]，-p[password]
当连接服务器时使用的密码。如果你在命令行中在--password或-p选项后面省略 密码值，将提示你输入密码。
·         --plan
显示将来发布的建议和思想。
·         --preview
更改临时授权表后显示权限的不同。
·         --relnotes
显示发布注解。
·         --rhost=host_name，-H host_name
连接给定主机的MySQL服务器。
·         --rollback
取消对临时授权表的最新的更改。
·         --spassword[=password]，-P[password]
以super用户连接服务器时使用的密码。如果在命令行中在--password或-p选项后面省略了 密码值，将提示你输入密码。
·         --superuser=user_name，-U user_name
指定以super用户连接时的用户名。
·         --tables，-t
生成表格式的报告。
·         --user=user_name，-u user_name
在访问权限中使用的主机名。
·         --version，-v
显示版本信息并退出。
如果你的MySQL分发安装在某个非标准位置，必须进入mysqlaccess期望找到mysql客户的目录。编辑大约在18行处的mysqlaccess脚本。搜索类似下面的一行：
$MYSQL     = '/usr/local/bin/mysql';    # path to mysql executable
将路径更改为mysql实际在系统中保存的位置。如果不这样做，当运行mysqlaccess时会发生Broken pipe错误。
8.5. mysqladmin：用于管理MySQL服务器的客户端
mysqladmin是一个执行管理操作的客户程序。可以用它来检查服务器的配置和当前的状态，创建并删除数据库等等。
这样调用mysqladmin：
shell> mysqladmin [options] command [command-options] [command [command-options]] ...
mysqladmin支持下面的命令：
·         create db_name
创建一个名为db_name的新数据库。
·         debug
告诉服务器向错误日志写入调试信息。
·         drop db_name
删除名为db_nam的数据库和所有表。
·         extended-status
显示服务器状态变量及其值。
·         flush-hosts
刷新主机缓存中的所有信息。
·         flush-logs
刷新所有日志。
·         flush-privileges
重载授权表(类似reload)。
·         flush-status
清除状态变量。
·         flush-tables
刷新所有表。
·         flush-threads
刷新线程缓存。
·         kill id,id,...
杀掉服务器线程。
·         old-password new-password
类似password但使用旧的(pre-4.1)密码哈希格式保存 密码。(参见5.7.9节，“MySQL 4.1中的密码哈希处理”）。
·         password new-password
设置一个新密码。将用mysqladmin连接服务器使用的 账户的密码更改为new-password。
如果new-password包含空格或其它命令解释符的特殊字符，需要用引号将它引起来。在Windows中，一定要使用双引号而不要用单引号；单引号不会从 密码中剥离出来，而是解释为密码的一部分。例如：
shell> mysqladmin password "my new password"
·         ping
检查服务器是否仍活动。如果服务器在运行mysqladmin返回状态0，如果不运行返回1。即使出现错误例如Access denied也为0，因为这说明服务器在运行但拒绝了连接，与服务器不在运行不同。
·         processlist
显示活动服务器线程的列表。类似SHOW PROCESSLIST语句的输出。如果给出了--verbose选项，输出类似SHOW FULL PROCESSLIST。(参见13.5.4.16节，“SHOW PROCESSLIST语法”）。
·         reload
重载授权表。
·         refresh
刷新所有表并关闭和打开日志文件。
·         shutdown
停止服务器。
·         start-slave
开始从服务器上的复制。
·         status
显示短服务器状态消息。
·         stop-slave
停止从服务器上的复制。
·         variables
显示服务器系统变量及其值。
·         version
显示服务器的版本信息。
所有命令可以简化为任何唯一的前缀。例如：
shell> mysqladmin proc stat
+----+-------+-----------+----+---------+------+-------+------------------+
| Id | User  | Host      | db | Command | Time | State | Info             |
+----+-------+-----------+----+---------+------+-------+------------------+
| 51 | monty | localhost |    | Query   | 0    |       | show processlist |
+----+-------+-----------+----+---------+------+-------+------------------+
Uptime: 1473624  Threads: 1  Questions: 39487  
Slow queries: 0  Opens: 541  Flush tables: 1  
Open tables: 19  Queries per second avg: 0.0268
 
mysqladmin status命令的结果显示下面的值：
·         Uptime
MySQL服务器已经运行的秒数。
·         Threads
活动线程(客户)的数目。
·         Questions
服务器启动以来客户的问题(查询)数目。
·         Slow queries
执行时间超过long_query_time秒的查询的数量。参见5.11.4节，“慢速查询日志”。
·         Opens
服务器已经打开的数据库表的数量。
·         Flush tables
服务器已经执行的flush ...、refresh和reload命令的数量。
·         Open tables
目前打开的表的数量。
·         Memory in use
mysqld代码直接分配的内存数量。只有用--with--debug=full编译了MySQL该值才显示。
·         Maximum memory used
mysqld代码直接分配的最大内存数量。只有用--with--debug=full编译了MySQL该值才显示。
如果当使用Unix套接字文件连接本地服务器时执行mysqladmin shutdown，mysqladmin将等待直到服务器的进程ID文件被删除，以确保服务器正确停止。
mysqladmin支持下面的选项：
·         ---help，-？
显示帮助消息并退出。
·         --character-sets-dir=path
字符集的安装目录。参见5.10.1节，“数据和排序用字符集”。
·         --compress，-C
压缩客户和服务器之间发送的所有信息（如果二者均支持压缩）。
·         --count=num，-c num
迭代数目。该选项只有结合--sleep (-i)才能工作。
·         ---debug[=debug_options]，-# [debug_options]
写调试日志。debug_options字符串通常为'd:t:o,file_name'。 默认为'd:t:o,/tmp/mysqladmin.trace'。
·         --default-character-set=charset
使用charsetas作为默认字符集。参见5.10.1节，“数据和排序用字符集”。
·         --force，-f
不再为drop database命令进行确认。对于多个命令，即使出现错误也继续。
·         --host=host_name，-h host_name
连接给定主机上的MySQL服务器。
·         --password[=password]，-p[password]
连接服务器使用的密码。如果使用短选项形式(-p)，该选项和 密码之间不能有空格。如果你在命令行中在--password或-p选项后面省略 密码值，将提示你输入密码。
·         --port=port_num，-P port_num
用于连接的TCP/IP端口号。
·         --protocol={TCP | SOCKET | PIPE | MEMORY}
使用的连接协议。
·         --relative，-r
当带-I使用时显示当前和前面值的差别。目前，该选项只用于extended-status命令。
·         --silent，-s
如果不能建立与服务器的连接则以沉默方式退出。
·         --sleep=delay，-i delay
每睡眠delay秒后执行一次命令。
·         --socket=path，-S path
用于连接的套接字文件。
·         --user=user_name，-u user_name
当连接服务器时使用的MySQL用户名。
·         --verbose，-v
冗长模式。打印出程序操作的详细信息。
·         --version，-V
显示版本信息并退出。
·         --vertical，-E
垂直打印输出。类似于--relative，但垂直打印输出。
·         --wait[=count]，-w[count]
如果连接不能建立，等待并重试而不是放弃。如果给出一个选项值，则指示重试的次数。默认是一次。
也可以使用--var_name=value选项设置下面的变量：
·         connect_timeout
连接超时之前的最大秒数。默认值为43200(12小时)。
·         shutdown_timeout
等候关闭的最大秒数。默认值为3600(1小时)。
也可以使用--set-variable=var_name=value或-O var_name=value语法来设置变量。然而，现在不赞成该语法，并且不再使用。
8.6. mysqlbinlog：用于处理二进制日志文件的实用工具
服务器生成的二进制日志文件写成二进制格式。要想检查这些文本格式的文件，应使用mysqlbinlog实用工具。
应这样调用mysqlbinlog：
shell> mysqlbinlog [options] log-files...
例如，要想显示二进制日志binlog.000003的内容，使用下面的命令：
shell> mysqlbinlog binlog.0000003
输出包括在binlog.000003中包含的所有语句，以及其它信息例如每个语句花费的时间、客户发出的线程ID、发出线程时的时间戳等等。
通常情况，可以使用mysqlbinlog直接读取二进制日志文件并将它们用于本地MySQL服务器。也可以使用--read-from-remote-server选项从远程服务器读取二进制日志。
当读取远程二进制日志时，可以通过连接参数选项来指示如何连接服务器，但它们经常被忽略掉，除非你还指定了--read-from-remote-server选项。这些选项是--host、--password、--port、--protocol、--socket和--user。
还可以使用mysqlbinlog来读取在复制过程中从服务器所写的中继日志文件。中继日志格式与二进制日志文件相同。
在5.11.3节，“二进制日志”中详细讨论了二进制日志。
mysqlbinlog支持下面的选项：
·         ---help，-？
显示帮助消息并退出。
·         ---database=db_name，-d db_name
只列出该数据库的条目(只用本地日志)。
·         --force-read，-f
使用该选项，如果mysqlbinlog读它不能识别的二进制日志事件，它会打印警告，忽略该事件并继续。没有该选项，如果mysqlbinlog读到此类事件则停止。
·         --hexdump，-H
在注释中显示日志的十六进制转储。该输出可以帮助复制过程中的调试。在MySQL 5.1.2中添加了该选项。
·         --host=host_name，-h host_name
获取给定主机上的MySQL服务器的二进制日志。
·         --local-load=path，-l pat
为指定目录中的LOAD DATA INFILE预处理本地临时文件。
·         --offset=N，-o N
跳过前N个条目。
·         --password[=password]，-p[password]
当连接服务器时使用的密码。如果使用短选项形式(-p)，选项和 密码之间不能有空格。如果在命令行中--password或-p选项后面没有 密码值，则提示输入一个密码。
·         --port=port_num，-P port_num
用于连接远程服务器的TCP/IP端口号。
·         --position=N，-j N
不赞成使用，应使用--start-position。
·         --protocol={TCP | SOCKET | PIPE | -position 
使用的连接协议。
·         --read-from-remote-server，-R
从MySQL服务器读二进制日志。如果未给出该选项，任何连接参数选项将被忽略。这些选项是--host、--password、--port、--protocol、--socket和--user。
·         --result-file=name, -r name
将输出指向给定的文件。
·         --short-form，-s
只显示日志中包含的语句，不显示其它信息。
·         --socket=path，-S path
用于连接的套接字文件。
·         --start-datetime=datetime
从二进制日志中第1个日期时间等于或晚于datetime参量的事件开始读取。datetime值相对于运行mysqlbinlog的机器上的本地时区。该值格式应符合DATETIME或TIMESTAMP数据类型。例如：
shell> mysqlbinlog --start-datetime="2004-12-25 11:25:56" binlog.000003
该选项可以帮助点对点恢复。
·         --stop-datetime=datetime
从二进制日志中第1个日期时间等于或晚于datetime参量的事件起停止读。关于datetime值的描述参见--start-datetime选项。该选项可以帮助及时恢复。
·         --start-position=N
从二进制日志中第1个位置等于N参量时的事件开始读。
·         --stop-position=N
从二进制日志中第1个位置等于和大于N参量时的事件起停止读。
·         --to-last-logs，-t
在MySQL服务器中请求的二进制日志的结尾处不停止，而是继续打印直到最后一个二进制日志的结尾。如果将输出发送给同一台MySQL服务器，会导致无限循环。该选项要求--read-from-remote-server。
·         --disable-logs-bin，-D
禁用二进制日志。如果使用--to-last-logs选项将输出发送给同一台MySQL服务器，可以避免无限循环。该选项在崩溃恢复时也很有用，可以避免复制已经记录的语句。注释：该选项要求有SUPER权限。
·         --user=user_name，-u user_name
连接远程服务器时使用的MySQL用户名。
·         --version，-V
显示版本信息并退出。
还可以使用--var_name=value选项设置下面的变量：
·         open_files_limit
指定要保留的打开的文件描述符的数量。
可以将mysqlbinlog的输出传到mysql客户端以执行包含在二进制日志中的语句。如果你有一个旧的备份，该选项在崩溃恢复时也很有用(参见5.9.1节，“数据库备份”)：
shell> mysqlbinlog hostname-bin.000001 | mysql
或：
shell> mysqlbinlog hostname-bin.[0-9]* | mysql
如果你需要先修改含语句的日志，还可以将mysqlbinlog的输出重新指向一个文本文件。(例如，想删除由于某种原因而不想执行的语句)。编辑好文件后，将它输入到mysql程序并执行它包含的语句。
mysqlbinlog有一个--position选项，只打印那些在二进制日志中的偏移量大于或等于某个给定位置的语句(给出的位置必须匹配一个事件的开始)。它还有在看见给定日期和时间的事件后停止或启动的选项。这样可以使用--stop-datetime选项进行点对点恢复(例如，能够说“将数据库前滚动到今天10:30 AM的位置”)。
如果MySQL服务器上有多个要执行的二进制日志，安全的方法是在一个连接中处理它们。下面是一个说明什么是不安全的例子：
shell> mysqlbinlog hostname-bin.000001 | mysql # DANGER!!
shell> mysqlbinlog hostname-bin.000002 | mysql # DANGER!!
使用与服务器的不同连接来处理二进制日志时，如果第1个日志文件包含一个CREATE TEMPORARY TABLE语句，第2个日志包含一个使用该临时表的语句，则会造成问题。当第1个mysql进程结束时，服务器撤销临时表。当第2个mysql进程想使用该表时，服务器报告 “不知道该表”。
要想避免此类问题，使用一个连接来执行想要处理的所有二进制日志中的内容。下面提供了一种方法：
shell> mysqlbinlog hostname-bin.000001 hostname-bin.000002 | mysql
另一个方法是：
shell> mysqlbinlog hostname-bin.000001 >  /tmp/statements.sql
shell> mysqlbinlog hostname-bin.000002 >> /tmp/statements.sql
shell> mysql -e "source /tmp/statements.sql"
mysqlbinlog产生的输出可以不需要原数据文件即可重新生成一个LOAD DATA INFILE操作。mysqlbinlog将数据复制到一个临时文件并写一个引用该文件的LOAD DATA LOCAL INFILE语句。由系统确定写入这些文件的目录的默认位置。要想显式指定一个目录，使用--local-load选项。
因为mysqlbinlog可以将LOAD DATA INFILE语句转换为LOAD DATA LOCAL INFILE语句(也就是说，它添加了LOCAL)，用于处理语句的客户端和服务器必须配置为允许LOCAL操作。参见5.6.4节，“LOAD DATA LOCAL安全问题”。
警告：为LOAD DATA LOCAL语句创建的临时文件不会自动删除，因为在实际执行完那些语句前需要它们。不再需要语句日志后应自己删除临时文件。文件位于临时文件目录中，文件名类似original_file_name-#-#。
--hexdump选项可以在注释中产生日志内容的十六进制转储：
shell> mysqlbinlog --hexdump master-bin.000001
上述命令的输出应类似：
/*!40019 SET @@session.max_insert_delayed_threads=0*/;
/*!50003 SET @OLD_COMPLETION_TYPE=@@COMPLETION_TYPE,COMPLETION_TYPE=0*/;
# at 4
#051024 17:24:13 server id 1  end_log_pos 98
# Position  Timestamp   Type   Master ID        Size      Master Pos    Flags
# 00000004 9d fc 5c 43   0f   01 00 00 00   5e 00 00 00   62 00 00 00   00 00
# 00000017 04 00 35 2e 30 2e 31 35  2d 64 65 62 75 67 2d 6c |..5.0.15.debug.l|
# 00000027 6f 67 00 00 00 00 00 00  00 00 00 00 00 00 00 00 |og..............|
# 00000037 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00 |................|
# 00000047 00 00 00 00 9d fc 5c 43  13 38 0d 00 08 00 12 00 |.......C.8......|
# 00000057 04 04 04 04 12 00 00 4b  00 04 1a                |.......K...|
#       Start: binlog v 4, server v 5.0.15-debug-log created 051024 17:24:13
#       at startup
ROLLBACK;
十六进制转储的输出包含下面的元素：
·         Position: The byte position within the log file. 
·         Timestamp: The event timestamp. In the example just shown, '9d fc 5c 43' is the representation of '051024 17:24:13' in hexadecimal. 
·         Type: The type of the log event. '0f' means that the example event is a FORMAT_DESCRIPTION_EVENT. The types are: 
·                00  UNKNOWN_EVENT
·                    This event should never be present in the log.
·                01  START_EVENT_V3
·                    This indicates the start of a log file written by MySQL 4 or earlier.
·                02  QUERY_EVENT
·                    The most common type of events.  These contain queries executed
·                    on the master.
·                03  STOP_EVENT
·                    Indicates that master has stopped.
·                04  ROTATE_EVENT
·                    Written when the master switches to a new log file.
·                05  INTVAR_EVENT
·                    Used mainly for AUTO_INCREMENT values and if the LAST_INSERT_ID()
·                    function is used in the statement.
·                06  LOAD_EVENT
·                    Used for LOAD DATA INFILE in MySQL 3.23.
·                07  SLAVE_EVENT
·                    Reserved for future use.
·                08  CREATE_FILE_EVENT
·                    Used for LOAD DATA INFILE statements.  This indicates the start
·                    of execution of such a statement.  A temporary file is created
·                    on the slave.  Used in MySQL 4 only.
·                09  APPEND_BLOCK_EVENT
·                    Contains data for use in a LOAD DATA INFILE statement.  The
·                    data is stored in the temporary file on the slave.
·                0a  EXEC_LOAD_EVENT
·                    Used for LOAD DATA INFILE statements.  The contents of the
·                    temporary file is stored in the table on the slave.
·                    Used in MySQL 4 only.
·                0b  DELETE_FILE_EVENT
·                    Rollback of LOAD DATA INFILE statement.  The temporary file
·                    should be deleted on slave.
·                0c  NEW_LOAD_EVENT
·                    Used for LOAD DATA INFILE in MySQL 4 and earlier.
·                0d  RAND_EVENT
·                    Used to send information about random values if the RAND()
·                    function is used in the query.
·                0e  USER_VAR_EVENT
·                    Used to replicate user variables.
·                0f  FORMAT_DESCRIPTION_EVENT
·                    This indicates the start of a log file written by MySQL 5 or later.
·                10  XID_EVENT
·                    Event indicating commit of XA transaction
·                11  BEGIN_LOAD_QUERY_EVENT
·                    Used for LOAD DATA statements in MySQL 5 and later.
·                12  EXECUTE_LOAD_QUERY_EVENT
·                    Used for LOAD DATA statements in MySQL 5 and later.
·                13  TABLE_MAP_EVENT
·                    Reserved for future use
·                14  WRITE_ROWS_EVENT
·                    Reserved for future use
·                15  UPDATE_ROWS_EVENT
·                    Reserved for future use
·                16  DELETE_ROWS_EVENT
·                    Reserved for future use
·         Master ID: The server id of the master that created the event. 
·         Size: The size in bytes of the event. 
·         Master Pos: The position of the event in the original master log file. 
·         Flags: 16 flags. 
·                01  LOG_EVENT_BINLOG_IN_USE_F
·                    Log file correctly closed (Used only in FORMAT_DESCRIPTION_EVENT)
·                    If this flag is set (if the flags are e.g. '01 00') in an
·                    FORMAT_DESCRIPTION_EVENT, then the log file has not been
·                    properly closed.  Most probably because of a master crash (for
·                    example, due to power failure).
·                02  Reserved for future use.
·                04  LOG_EVENT_THREAD_SPECIFIC_F
·                    Set if the event is dependent on the connection it was
·                    executed in (example '04 00'), e.g. if the event uses
·                    temporary tables.
·                08  LOG_EVENT_SUPPRESS_USE_F
·                    Set in some circumstances when the event is not dependent on
·                    the current database
其它标志保留用于将来使用。
在以后的版本中十六进制转储输出的格式可能会改变。
8.7. mysqlcheck：表维护和维修程序
mysqlcheck客户端可以检查和修复MyISAM表。它还可以优化和分析表。
mysqlcheck的功能类似myisamchk，但其工作不同。主要差别是当mysqld服务器在运行时必须使用mysqlcheck，而myisamchk应用于服务器没有运行时。使用mysqlcheck的好处是不需要停止服务器来检查或修复表。
Mysqlcheck为用户提供了一种方便的使用SQL语句CHECK TABLE、REPAIR TABLE、ANALYZE TABLE和OPTIMIZE TABLE的方式。它确定在要执行的操作中使用使用哪个语句，然后将语句发送到要执行的服务器上。
有3种方式来调用mysqlcheck：
shell> mysqlcheck[options] db_name [tables]
shell> mysqlcheck[options] ---database DB1 [DB2 DB3...]
shell> mysqlcheck[options] --all--database
如果没有指定任何表或使用---database或--all--database选项，则检查整个数据库。
同其它客户端比较，mysqlcheck有一个特殊特性。重新命名二进制可以更改检查表的默认行为(--check)。如果你想要一个工具默认可以修复表的工具，只需要将mysqlcheck重新复制为mysqlrepair，或者使用一个符号链接mysqlrepair链接mysqlcheck。如果调用mysqlrepair，可按照命令修复表。
下面的名可用来更改mysqlcheck的默认行为：
mysqlrepair
默认选项为--repair
mysqlanalyze
默认选项为--analyze
mysqloptimize
默认选项为--optimize
mysqlcheck支持下面的选项：
·         ---help，-？
显示帮助消息并退出。
·         --all--database，-A
检查所有数据库中的所有表。与使用---database选项相同，在命令行中命名所有数据库。
·         --all-in-1，-1
不是为每个表发出一个语句，而是为命名数据库中待处理的所有表的每个数据库执行一个语句。
·         --analyze，-a
分析表。
·         --auto-repair
如果某个被检查的表破坏了，自动修复它。检查完所有表后自动进行所有需要的修复。
·         --character-sets-dir=path
字符集的安装目录。参见5.10.1节，“数据和排序用字符集”。
·         --check，-c
检查表的错误。
·         --check-only-changed，-C
只检查上次检查以来已经更改的或没有正确关闭的表。
·         --compress
压缩在客户端和服务器之间发送的所有信息（如果二者均支持压缩）。
·         ---database，-B
处理数据库中命名的所有表。使用该选项，所有字名参量被看作数据库名，而不是表名。
·         ---debug[=debug_options]，-# [debug_options]
写调试日志。debug_options字符串通常为'd:t:o,file_name'。
·         --default-character-set=charset
使用charsetas默认字符集。参见5.10.1节，“数据和排序用字符集”。
·         --extended，-e
如果你正使用该选项来检查表，可以确保它们100%地一致，但需要很长的时间。
如果你正使用该选项来修复表，则运行扩展修复，不但执行的时间很长，而且还会产生大量的垃圾行! 
·         --fast，-F
只检查没有正确关闭的表。
·         --force，-f
即使出现SQL错误也继续。
·         --host=host_name，-h host_name
连接给定主机上的MySQL服务器。
·         --medium-check，-m
执行比--extended操作更快的检查。只能发现99.99%的错误，在大多数情况下这已经足够了。
·         --optimize，-o
优化表。
·         --password[=password]，-p[password]
当连接服务器时使用的密码。如果使用短选项形式(-p)，选项和 密码之间不能有空格。如果在命令行中--password或-p选项后面没有 密码值，则提示输入一个密码。
·         --port=port_num，-P port_num
用于连接的TCP/IP端口号。
·         --protocol={TCP | SOCKET | PIPE | MEMORY} 
使用的连接协议。
·         --quick，-q
如果你正使用该选项在检查表，它防止扫描行以检查错误链接的检查。这是最快的检查方法。
如果你正使用该选项在修复表，它尝试只修复索引树。这是最快的修复方法。
·         --repair，-r
执行可以修复大部分问题的修复，只是唯一值不唯一时不能修复。
·         --silent，-s
沉默模式。只打印错误消息。
·         --socket=path，-S path
用于连接的套接字文件。
·         --tables
覆盖---database或-B选项。选项后面的所有参量被视为表名。
·         --user=user_name，-u user_name
当连接服务器时使用的MySQL用户名。
·         --verbose，-v
冗长模式。打印关于各阶段程序操作的信息。
·         --version，-V
显示版本信息并退出。
8.8. mysqldump：数据库备份程序
mysqldump客户端可用来转储数据库或搜集数据库进行备份或将数据转移到另一个SQL服务器(不一定是一个MySQL服务器)。转储包含创建表和/或装载表的SQL语句。
如果你在服务器上进行备份，并且表均为MyISAM表，应考虑使用mysqlhotcopy，因为可以更快地进行备份和恢复。参见8.9节，“mysqlhotcopy：数据库备份程序”。
有3种方式来调用mysqldump：
shell> mysqldump [options] db_name [tables]
shell> mysqldump [options] ---database DB1 [DB2 DB3...]
shell> mysqldump [options] --all--database
如果没有指定任何表或使用了---database或--all--database选项，则转储整个数据库。
要想获得你的版本的mysqldump支持的选项，执行mysqldump ---help。
如果运行mysqldump没有--quick或--opt选项，mysqldump在转储结果前将整个结果集装入内存。如果转储大数据库可能会出现问题。该选项默认启用，但可以用--skip-opt禁用。
如果使用最新版本的mysqldump程序生成一个转储重装到很旧版本的MySQL服务器中，不应使用--opt或-e选项。
mysqldump支持下面的选项：
·         ---help，-？
显示帮助消息并退出。
·         --add-drop--database
在每个CREATE DATABASE语句前添加DROP DATABASE语句。
·         --add-drop-tables
在每个CREATE TABLE语句前添加DROP TABLE语句。
·         --add-locking
用LOCK TABLES和UNLOCK TABLES语句引用每个表转储。重载转储文件时插入得更快。参见7.2.16节，“INSERT语句的速度”。
·         --all--database，-A
转储所有数据库中的所有表。与使用---database选项相同，在命令行中命名所有数据库。
·         --allow-keywords
允许创建关键字列名。应在每个列名前面加上表名前缀。
·         ---comments[={0|1}]
如果设置为 0，禁止转储文件中的其它信息，例如程序版本、服务器版本和主机。--skip—comments与---comments=0的结果相同。 默认值为1，即包括额外信息。
·         --compact
产生少量输出。该选项禁用注释并启用--skip-add-drop-tables、--no-set-names、--skip-disable-keys和--skip-add-locking选项。
·         --compatible=name
产生与其它数据库系统或旧的MySQL服务器更兼容的输出。值可以为ansi、mysql323、mysql40、postgresql、oracle、mssql、db2、maxdb、no_key_options、no_tables_options或者no_field_options。要使用几个值，用逗号将它们隔开。这些值与设置服务器SQL模式的相应选项有相同的含义。参见5.3.2节，“SQL服务器模式”。
该选项不能保证同其它服务器之间的兼容性。它只启用那些目前能够使转储输出更兼容的SQL模式值。例如，--compatible=oracle 不映射Oracle类型或使用Oracle注释语法的数据类型。
·         --complete-insert，-c
使用包括列名的完整的INSERT语句。
·         --compress，-C
压缩在客户端和服务器之间发送的所有信息（如果二者均支持压缩）。
·         --create-option
在CREATE TABLE语句中包括所有MySQL表选项。
·         ---database，-B
转储几个数据库。通常情况，mysqldump将命令行中的第1个名字参量看作数据库名，后面的名看作表名。使用该选项，它将所有名字参量看作数据库名。CREATE DATABASE IF NOT EXISTS db_name和USE db_name语句包含在每个新数据库前的输出中。
·         ---debug[=debug_options]，-# [debug_options]
写调试日志。debug_options字符串通常为'd:t:o,file_name'。
·         --default-character-set=charset
使用charsetas默认字符集。参见5.10.1节，“数据和排序用字符集”。如果没有指定，mysqldump使用utf8。
·         --delayed-insert 
使用INSERT DELAYED语句插入行。
·         --delete-master-logs
在主复制服务器上，完成转储操作后删除二进制日志。该选项自动启用--master-data。
·         --disable-keys，-K
对于每个表，用/*!40000 ALTER TABLE tbl_name DISABLE KEYS */;和/*!40000 ALTER TABLE tbl_name ENABLE KEYS */;语句引用INSERT语句。这样可以更快地装载转储文件，因为在插入所有行后创建索引。该选项只适合MyISAM表。
·         --extended-insert，-e
使用包括几个VALUES列表的多行INSERT语法。这样使转储文件更小，重载文件时可以加速插入。
·         --fields-terminated-by=...，--fields-enclosed-by=...，--fields-optionally-enclosed-by=...，--fields-escaped-by=...，--行-terminated-by=...
这些选项结合-T选项使用，与LOAD DATA INFILE的相应子句有相同的含义。参见13.2.5节，“LOAD DATA INFILE语法”。
·         --first-slave，-x
不赞成使用，现在重新命名为--lock-all-tables。
·         --flush-logs，-F
开始转储前刷新MySQL服务器日志文件。该选项要求RELOAD权限。请注意如果结合--all--database(或-A)选项使用该选项，根据每个转储的数据库刷新日志。例外情况是当使用--lock-all-tables或--master-data的时候：在这种情况下，日志只刷新一次，在所有 表被锁定后刷新。如果你想要同时转储和刷新日志，应使用--flush-logs连同--lock-all-tables或--master-data。
·         --force，-f
在表转储过程中，即使出现SQL错误也继续。
·         --host=host_name，-h host_name
从给定主机的MySQL服务器转储数据。默认主机是localhost。
·         --hex-blob
使用十六进制符号转储二进制字符串列(例如，'abc' 变为0x616263)。影响到的列有BINARY、VARBINARY、BLOB。
·         --lock-all-tables，-x
所有数据库中的所有表加锁。在整体转储过程中通过全局读锁定来实现。该选项自动关闭--single-transaction和--lock-tables。
·         --lock-tables，-l
开始转储前锁定所有表。用READ LOCAL锁定表以允许并行插入MyISAM表。对于事务表例如InnoDB和BDB，--single-transaction是一个更好的选项，因为它不根本需要锁定表。
请注意当转储多个数据库时，--lock-tables分别为每个数据库锁定表。因此，该选项不能保证转储文件中的表在数据库之间的逻辑一致性。不同数据库表的转储状态可以完全不同。
·         --master-data[=value]
该选项将二进制日志的位置和文件名写入到输出中。该选项要求有RELOAD权限，并且必须启用二进制日志。如果该选项值等于1，位置和文件名被写入CHANGE MASTER语句形式的转储输出，如果你使用该SQL转储主服务器以设置从服务器，从服务器从主服务器二进制日志的正确位置开始。如果选项值等于2，CHANGE MASTER语句被写成SQL注释。如果value被省略，这是默认动作。
--master-data选项启用--lock-all-tables，除非还指定--single-transaction(在这种情况下，只在刚开始转储时短时间获得全局读锁定。又见--single-transaction。在任何一种情况下，日志相关动作发生在转储时。该选项自动关闭--lock-tables。
·         --no-create-db，-n
该选项禁用CREATE DATABASE /*!32312 IF NOT EXISTS*/ db_name语句，如果给出---database或--all--database选项，则包含到输出中。
·         --no-create-info，-t
不写重新创建每个转储表的CREATE TABLE语句。
·         --no-data，-d
不写表的任何行信息。如果你只想转储表的结构这很有用。
·         --opt
该选项是速记；等同于指定 --add-drop-tables--add-locking --create-option --disable-keys--extended-insert --lock-tables --quick --set-charset。它可以给出很快的转储操作并产生一个可以很快装入MySQL服务器的转储文件。该选项默认开启，但可以用--skip-opt禁用。要想只禁用确信用-opt启用的选项，使用--skip形式；例如，--skip-add-drop-tables或--skip-quick。
·         --password[=password]，-p[password]
连接服务器时使用的密码。如果你使用短选项形式(-p)，不能在选项和密码之间有一个空格。如果在命令行中，忽略了--password或-p选项后面的 密码值，将提示你输入一个。
·         --port=port_num，-P port_num
用于连接的TCP/IP端口号。
·         --protocol={TCP | SOCKET | PIPE | MEMORY}
使用的连接协议。
·         --quick，-q
该选项用于转储大的表。它强制mysqldump从服务器一次一行地检索表中的行而不是检索所有行并在输出前将它缓存到内存中。
·         --quote-names，-Q
用‘`’字符引用数据库、表和列名。如果服务器SQL模式包括ANSI_QUOTES选项，用‘"’字符引用名。默认启用该选项。可以用--skip-quote-names禁用，但该选项应跟在其它选项后面，例如可以启用--quote-names的--compatible。
·         --result-file=file，-r file
将输出转向给定的文件。该选项应用在Windows中，因为它禁止将新行‘\n’字符转换为‘\r\n’回车、返回/新行序列。
·         --routines，-R
在转储的数据库中转储存储程序(函数和程序)。使用---routines产生的输出包含CREATE PROCEDURE和CREATE FUNCTION语句以重新创建子程序。但是，这些语句不包括属性，例如子程序定义者或创建和修改时间戳。这说明当重载子程序时，对它们进行创建时定义者应设置为重载用户，时间戳等于重载时间。
如果你需要创建的子程序使用原来的定义者和时间戳属性，不使用--routines。相反，使用一个具有mysql数据库相应权限的MySQL账户直接转储和重载mysql.proc表的内容。
该选项在MySQL 5.1.2中添加进来。在此之前，存储程序不转储。
·         --set-charset
将SET NAMES default_character_set加到输出中。该选项默认启用。要想禁用SET NAMES语句，使用--skip-set-charset。
·         --single-transaction
该选项从服务器转储数据之前发出一个BEGIN SQL语句。它只适用于事务表，例如InnoDB和BDB，因为然后它将在发出BEGIN而没有阻塞任何应用程序时转储一致的数据库状态。
当使用该选项时，应记住只有InnoDB表能以一致的状态被转储。例如，使用该选项时任何转储的MyISAM或HEAP表仍然可以更改状态。
--single-transaction选项和--lock-tables选项是互斥的，因为LOCK TABLES会使任何挂起的事务隐含提交。
要想转储大的表，应结合--quick使用该选项。
·         --socket=path，-S path
当连接localhost(为默认主机)时使用的套接字文件。
·         --skip--comments
参见---comments选项的描述。
·         --tab=path，-T path
产生tab分割的数据文件。对于每个转储的表，mysqldump创建一个包含创建表的CREATE TABLE语句的tbl_name.sql文件，和一个包含其数据的tbl_name.txt文件。选项值为写入文件的目录。
默认情况，.txt数据文件的格式是在列值和每行后面的新行之间使用tab字符。可以使用--fields-xxx和--行--xxx选项明显指定格式。
注释：该选项只适用于mysqldump与mysqld服务器在同一台机器上运行时。你必须具有FILE权限，并且服务器必须有在你指定的目录中有写文件的许可。
·         --tables
覆盖---database或-B选项。选项后面的所有参量被看作表名。
·         --triggers
为每个转储的表转储触发器。该选项默认启用；用--skip-triggers禁用它。
·         --tz-utc
在转储文件中加入SET TIME_ZONE='+00:00'以便TIMESTAMP列可以在具有不同时区的服务器之间转储和重载。(不使用该选项，TIMESTAMP列在具有本地时区的源服务器和目的服务器之间转储和重载）。--tz-utc也可以保护由于夏令时带来的更改。--tz-utc默认启用。要想禁用它，使用--skip-tz-utc。该选项在MySQL 5.1.2中加入。
·         --user=user_name，-u user_name
连接服务器时使用的MySQL用户名。
·         --verbose，-v
冗长模式。打印出程序操作的详细信息。
·         --version，-V
显示版本信息并退出。
·         --where='where-condition', -w 'where-condition'
只转储给定的WHERE条件选择的记录。请注意如果条件包含命令解释符专用空格或字符，一定要将条件引用起来。
例如：
"--where=user='jimf'"
"-wuserid>1"
"-wuserid<1"
·         --xml，-X
将转储输出写成XML。
还可以使用--var_name=value选项设置下面的变量：
·         max_allowed_packet
客户端/服务器之间通信的缓存区的最大大小。最大为1GB。
·         net_buffer_length
客户端/服务器之间通信的缓存区的初始大小。当创建多行插入语句时(如同使用选项--extended-insert或--opt)，mysqldump创建长度达net_buffer_length的行。如果增加该变量，还应确保在MySQL服务器中的net_buffer_length变量至少这么大。
还可以使用--set-variable=var_name=value或-O var_name=value语法设置变量。然而，现在不赞成使用该语法。
mysqldump最常用于备份一个整个的数据库：
shell> mysqldump --opt db_name > backup-file.sql
你可以这样将转储文件读回到服务器：
shell> mysql db_name < backup-file.sql
或者为：
shell> mysql -e "source /path-to--backup/backup-file.sql" db_name
mysqldump也可用于从一个MySQL服务器向另一个服务器复制数据时装载数据库：
shell> mysqldump --opt db_name | mysql --host=remote_host -C db_name
可以用一个命令转储几个数据库：
shell> mysqldump ---database db_name1 [db_name2 ...] > my_databases.sql
如果你想要转储所有数据库，使用--all--database选项：
shell> mysqldump --all-databases > all_databases.sql
如果表保存在InnoDB存储引擎中，mysqldump提供了一种联机备份的途径(参见下面的命令)。该备份只需要在开始转储时对所有表进行全局读锁定(使用FLUSH TABLES WITH READ LOCK)。获得锁定后，读取二进制日志的相应内容并将锁释放。因此如果并且只有当发出FLUSH...时正执行一个长的更新语句，MySQL服务器才停止直到长语句结束，然后转储则释放锁。因此如果MySQL服务器只接收到短("短执行时间")的更新语句，即使有大量的语句，也不会注意到锁期间。
shell> mysqldump --all-databases --single-transaction > all_databases.sql
对于点对点恢复(也称为“前滚”，当你需要恢复旧的备份并重放该备份以后的更改时)，循环二进制日志(参见5.11.3节，“二进制日志”)或至少知道转储对应的二进制日志内容很有用：
shell> mysqldump --all-databases --master-data=2 > all_databases.sql
或
shell> mysqldump --all-databases --flush-logs --master-data=2 > all_databases.sql
如果表保存在InnoDB存储引擎中，同时使用--master-data和--single-transaction提供了一个很方便的方式来进行适合点对点恢复的联机备份。
关于备份的详细信息，参见5.9.1节，“数据库备份”。
8.9. mysqlhotcopy：数据库备份程序
mysqlhotcopy是一个Perl脚本，最初由Tim Bunce编写并提供。它使用LOCK TABLES、FLUSH TABLES和cp或scp来快速备份数据库。它是备份数据库或单个表的最快的途径，但它只能运行在数据库目录所在的机器上。mysqlhotcopy只用于备份MyISAM。它运行在Unix和NetWare中。
shell> mysqlhotcopy db_name [/path/to/new_directory]
shell> mysqlhotcopy db_name_1 ... db_name_n /path/to/new_directory
备份给定数据库中的匹配正则表达式的表：
shell> mysqlhotcopy db_name./regex/
加上发音符(‘~’)前缀，表名的正则表达式可以被否定：
shell> mysqlhotcopy db_name./~regex/
mysqlhotcopy支持下面的选项：
·         ---help，-？
显示帮助消息并退出。
·         --allowold
如果目标存在不放弃(加上一个_old后缀重新命名它)。
·         --checkpoint=db_name.tbl_name
在指定的db_name.tbl_name插入检查点条目。
·         ---debug
启用调试输出。
·         --dryrun，-n
报告动作而不执行它们。
·         --flushlog
所有表锁定后刷新日志。
·         --keepold
完成后不删除以前(重新命名的)的目标。
·         -- method=command
复制方法(cp或scp)。
·         --noindices
备份中不包括全部索引文件。这样使备份更小、更快。可以在以后用myisamchk -rq重新构建索引。
·         --password=password，-p password
当连接服务器时使用的密码。请注意该选项的密码值是不可选的，不象其它MySQL程序。
·         --port=port_num，-P port_num
当连接本地服务器时使用的TCP/IP端口号。
·         --quiet，-q
除了出现错误时保持沉默。
·         --regexp=expr
复制所有数据库名匹配给出的正则表达式的数据库。
·         --socket=path，-S path
用于连接的Unix套接字文件。
·         --suffix=str
所复制的数据库名的后缀。
·         --tmpdir=path 
临时目录(代替/tmp)。
·         --user=user_name，-u user_name
当连接服务器时使用的MySQL用户名。
mysqlhotcopy从选项文件读取[client]和[mysqlhotcopy]选项组。
要想执行mysqlhotcopy，你必须可以访问备份的表文件，具有那些表的SELECT权限和RELOAD权限(以便能够执行FLUSH TABLES)。
使用perldoc调用其它mysqlhotcopy文档：
shell> perldoc mysqlhotcopy
8.10. mysqlimport：数据导入程序
mysqlimport客户端提供了LOAD DATA INFILEQL语句的一个命令行接口。mysqlimport的大多数选项直接对应LOAD DATA INFILE子句。参见13.2.5节，“LOAD DATA INFILE语法”。
这样调用mysqlimport：
shell> mysqlimport [options] db_name textfile1 [textfile2 ...]
对于在命令行中命名的每个文本文件，mysqlimport去掉文件名的扩展名并使用结果来确定将导入文件内容的表名。例如，文件 patient.txt、patient.text和patient均将导入表patient。
mysqlimport支持下面的选项：
·         ---help，-？
显示帮助消息并退出。
·         --columns=column_list, -c column_list
该选项采用用逗号分隔的列名作为其值。列名的顺序指示如何匹配数据文件列和表列。
·         --compress，-C
压缩在客户端和服务器之间发送的所有信息（如果二者均支持压缩）。
·         ---debug[=debug_options]，-# [debug_options]
写调试日志。debug_options字符串通常是'd:t:o,file_name'。
·         --delete，-D
导入文本文件前清空表。
·         --fields-terminated-by=...，--fields-enclosed-by=...，--fields-optionally-enclosed-by=...，--fields-escaped-by=...，--lines-terminated-by=...
这些选项与LOAD DATA INFILE相应子句的含义相同。参见13.2.5节，“LOAD DATA INFILE语法”。
·         --force，-f
忽视错误。例如，如果某个文本文件的表不存在，继续处理其它文件。不使用--force，如果表不存在则mysqlimport退出。
·         --host=host_name，-h host_name
将数据导入给定主机上的MySQL服务器。默认主机是localhost。
·         --ignore，-i
参见--replace选项的描述。
·         --ignore-lines=n
忽视数据文件的前n行。
·         --local，-L
从本地客户端读入输入文件。
·         --lock-tables，-l
处理文本文件前锁定所有表以便写入。这样可以确保所有表在服务器上保持同步。
·         --password[=password]，-p[password]
当连接服务器时使用的密码。如果使用短选项形式(-p)，选项和 密码之间不能有空格。如果在命令行中--password或-p选项后面没有 密码值，则提示输入一个密码。
·         --port=port_num，-P port_num
用于连接的TCP/IP端口号。
·         --protocol={TCP | SOCKET | PIPE | MEMORY}
使用的连接协议。
·         --replace，-r
--replace和--ignore选项控制复制唯一键值已有记录的输入记录的处理。如果指定--replace，新行替换有相同的唯一键值的已有行。如果指定--ignore，复制已有的唯一键值的输入行被跳过。如果不指定这两个选项，当发现一个复制键值时会出现一个错误，并且忽视文本文件的剩余部分。
·         --silent，-s
沉默模式。只有出现错误时才输出。
·         --socket=path，-S path
当连接localhost时使用的套接字文件(为默认主机)。
·         --user=user_name，-u user_name
当连接服务器时MySQL使用的用户名。
·         --verbose，-v
冗长模式。打印出程序操作的详细信息。
·         --version，-V
显示版本信息并退出。
这里是一个示例会话，显示如何使用mysqlimport：
shell> mysql -e 'CREATE TABLE imptest(id INT, n VARCHAR(30))' test
shell> ed
a
100     Max Sydow
101     Count Dracula
.
w imptest.txt
32
q
shell> od -c imptest.txt
0000000   1   0   0  \t   M   a   x       S   y   d   o   w  \n   1   0
0000020   1  \t   C   o   u   n   t       D   r   a   c   u   l   a  \n
0000040
shell> mysqlimport --local test imptest.txt
test.imptest: Records: 2  Deleted: 0  Skipped: 0  Warnings: 0
shell> mysql -e 'SELECT * FROM imptest' test
+------+---------------+
| id   | n             |
+------+---------------+
|  100 | Max Sydow     |
|  101 | Count Dracula |
+------+---------------+
8.11. mysqlshow－显示数据库、表和列信息
mysqlshow客户可用来很快地查找存在哪些数据库，数据库中的表，表中的列或索引。
mysqlshow为一些SQL显示语句提供了一个命令行界面。相同的信息可以通过直接使用那些语句获得。例如，你可以从mysql客户程序发出它们。参见13.5.4节，“SHOW语法”。
象这样调用mysqlshow：
shell> mysqlshow[选项] [db_name [tbl_name [col_name]]]
·         如果没有给出数据库，显示所有匹配的数据库。
·         如果没有给出表，显示数据库中所有匹配的表。
·         如果没有给出列，显示表中所有匹配的列和列类型。
请注意，在MySQL的新版本中，你只能看到有部分权限的那些数据库、表或者列。
如果最后的参数包含shell或SQL通用字符 (‘*’、‘?’、‘%’或者‘_’)，只显示那些名匹配通用字符的名字。如果一个数据库名包含下划线，应该使用一个反斜线（部分Unix shells需要双反斜线）对它们进行转义，以便得到一个正确的表或列的列表。‘*’和‘?’字符被转换为SQL的‘%’和‘_’通用字符。你试图用‘_’显示一个表的列名时，这可能会造成一些混淆，因为在这种情况下 mysqlshow显示与模式相匹配的表名。这很容易通过在命令行添加一个‘%’参量来解决。
mysqlshow支持下面的选项：
·         ---help，-？
显示一个帮助消息并退出。
·         --character-sets-dir=path
字符集安装目录。参见5.10.1节，“数据和排序用字符集”。
·         --compress，-C
压缩所有的客户和服务器之间发送的信息（如果它们都支持压缩）。
·         ---debug[=debug_options]，-# [debug_options]
写调试日志。debug_options字符串通常是'd:t:o,file_name'。
·         --default-character-set=charset
使用charset为默认字符集。参见5.10.1节，“数据和排序用字符集”。
·         --host=host_name，-h host_name 
在给出的主机上连接 MySQL服务器。
·         --keys, -k
显示表索引。
·         --password[=password]，-p[password] 
连接服务器时使用的密码。如果你使用短选项形式(-p)，不能在选项和 密码之间有一个空格。如果在命令行中，你忽略了--password或-p选项后面的 密码值，将提示你输入一个。
·         --port=port_num, -P port_num
连接时使用的TCP/IP端口号。
·         --protocol={TCP | SOCKET | PIPE | MEMORY}
连接时使用的协议。
·         --show-table-type
显示一列来指示表类型，与SHOW FULL TABLES语句显示相同。
·         --socket=path，-S path 
当连接localhost时使用的套接字文件（它时默认主机）。
·         --status, -i
显示关于每个表的额外信息。
·         --user=user_name，-u user_name
连接服务器时使用的MySQL用户名。
·         --verbose，-v
冗长模式。打印出程序操作的详细信息。该选项可以多次使用以便增加信息总量。
·         --version，-V
显示版本信息并退出。
8.12. myisamlog：显示MyISAM日志文件内容
myisamlog处理MyISAM日志文件内容。
象这样调用myisamlog：
shell> myisamlog [options] [logfile-name [tbl_name] ...]
常用操作是更新（-u）。如果恢复完成（-r），所有写和可能的更新以及删除操作完成并且只统计错误。如果没有给出日志文件名，使用myisam.log作为日志文件名。如果在命令行中指定了表名，只更新那些指定的表。
myisamlog理解下面的选项：
·         -?，-I
显示一个帮助消息并退出。
·         -c N
只执行N个命令。
·         -f N
指定打开文件的最大数目。
·         -F filepath/ 
TODO
·         -i
退出之前显示详细信息。
·         -o offset
指定起始偏移量。
·         -p N 
从路径中移除N个组件。
·         -r
恢复。
·         -R record-pos-file record-pos
指定记录位置文件和记录位置。
·         -u
更新。
·         -v
Verbose模式。产生更多输出。该选项可以多次使用以便产生越来越多的输出。
·         -w write-file
指定写文件。
·         -V
显示版本信息。
8.13. perror：解释错误代码
对于大多数系统错误，除内部文本信息之外，MySQL还按下面的风格显示的系统错误代码：
message ... (errno: #)
message ... (Errcode: #)
通过检查系统文档或使用perror工具，可以检查错误代码的意义。
perror为系统错误代码或存储引擎（表处理）错误代码打印其描述信息。
象这样调用perror：
shell> perror [options] errorcode ...
例如：
shell> perror13 64
Error code  13:  Permission denied
Error code  64:  Machine is not on the network
注释：要想显示MySQL簇的错误代码，用--ndb选项调用perror：
shell> perror --ndb errorcode
请注意，系统错误信息的含义可能与操作系统有关。在不同的操作系统中错误代码的含义可能不同。
8.14. replace：字符串替换实用工具
replace实用工具可以及时更改文件或标准输入中的字符串。它首先使用有限状态机来匹配长的字符串。该工具可以用来交换字符串。例如，下面的命令交换给定文件file1和file2中的a和b：
shell> replace a b b a -- file1 file2 ...
使用--选项来指示字符串-替换列表的结束位置和开始的文件名。
在命令行中的任何文件名被及时修改，因此在转换之前，可能要对源文件进行备份。
如果在命令行中没有指定文件名，replace读取标准输入并写到标准输出中。在这种情况下，不需要--选项。
replace程序用于msql2mysql。参见25.9.1节，“msql2mysql：转换mSQL程序以用于MySQL”。
replace支持下面的选项：
·         -?，-I
显示一条帮助消息并退出。
·         -# debug_options 
写调试日志。debug_options字符串通常是'd:t:o,file_name'。
·         -s
沉默模式。打印出程序执行的少量信息。
·         -v
冗长模式。打印出程序执行的大量信息。
·         -V
显示版本信息并退出。
8.15. mysql_zap：杀死符合某一模式的进程
mysql_zap杀死匹配某一模式的进程。象这样调用它：
shell> mysql_zap [-signal] [-?Ift] pattern
如果进程的ps命令的输出行包含该模式，则认为其匹配。默认情况，mysql_zap对每个进程请求确认。响应y则杀死该进程，或者q退出 mysql_zap。对于其它响应，mysql_zap不试图杀死进程。
如果给出-signal选项，它指定发送到每个进程的信号名或信号编号。否则，mysql_zap首先尝试TERM（信号15）然后用KILL（信号9）。
mysql_zap理解下面的额外选项：
·         ---help，-?，-I
显示一条帮助消息并退出。
·         -f
强制模式。mysql_zap 视图杀死每个匹配的进程而不需要确认。
·         -t
测试模式。显示每个进程的信息但不杀死它。


第9章：语言结构
目录
9.1. 文字值 
9.1.1. 字符串 
9.1.2. 数值 
9.1.3. 十六进制值 
9.1.4. 布尔值 
9.1.5. 位字段值 
9.1.6. NULL值
9.2. 数据库、表、索引、列和别名 
9.2.1. 识别符限制条件 
9.2.2. 识别符大小写敏感性
9.3. 用户变量 
9.4. 系统变量 
9.4.1. 结构式系统变量
9.5. 注释语法 
9.6. MySQL中保留字的处理
本章讨论了使用MySQL编写SQL语句的下面元素时所使用的规则：
·         字符串和数字等文字值
·         识别符，例如表和列名
·         用户和系统变量
·         注释
·         保留字
9.1. 文字值
9.1.1. 字符串 
9.1.2. 数值 
9.1.3. 十六进制值 
9.1.4. 布尔值 
9.1.5. 位字段值 
9.1.6. NULL值
该节描述了如何在MySQL中写文字值。包括字符串、数值、十六进制值、布尔值和NULL。本节还包括在MySQL中处理这些基本类型时会遇到的各种细微差别和“影印版”。
9.1.1. 字符串
字符串指用单引号(‘'’)或双引号(‘"’)引起来的字符序列。例如：
'a string'
"another string"
如果SQL服务器模式启用了NSI_QUOTES，可以只用单引号引用字符串。用双引号引用的字符串被解释为一个识别符。
字符串可以有一个可选字符集引介词和COLLATE子句：
[_charset_name]'string' [COLLATE collation_name]
例如：
SELECT _latin1'string';
SELECT _latin1'string' COLLATE latin1_danish_ci;
关于这些字符串语法形式的详细信息，参见10.3.7节，“字符串文字字符集和校对”。
在字符串中，某些序列具有特殊含义。这些序列均用反斜线(‘\’)开始，即所谓的转义字符。MySQL识别下面的转义序列：
\0 
ASCII 0(NUL)字符。
\' 
单引号(‘'’)。
\" 
双引号(‘"’)。
\b 
退格符。
\n 
换行符。
\r 
回车符。
\t 
tab字符。
\Z 
ASCII 26(控制（Ctrl）-Z)。该字符可以编码为‘\Z’，以允许你解决在Windows中ASCII 26代表文件结尾这一问题。(如果你试图使用mysql db_name < file_name，ASCII 26会带来问题）。
\\ 
反斜线(‘\’)字符。
\% 
‘%’字符。参见表后面的注解。
\_ 
‘_’字符。参见表后面的注解。
这些序列对大小写敏感。例如，‘\b’解释为退格，但‘\B’解释为‘B’。
‘\%’和‘\_’序列用于搜索可能会解释为通配符的模式匹配环境中的‘%’和‘_’文字实例。参见12.3.1节，“字符串比较函数”。请注意如果你在其它环境中使用‘\%’或‘\_’，它们返回字符串‘\%’和‘\_’，而不是‘%’和‘_’。
在其它转义序列中，反斜线被忽略。也就是说，转义字符解释为仿佛没有转义。
有几种方式可以在字符串中包括引号：
·         在字符串内用‘'’引用的‘'’可以写成‘''’。
·         在字符串内用‘"’引用的‘"’可以写成‘""’。
·         可以在引号前加转义字符(‘\’)。
·         在字符串内用‘"’引用的‘'’不需要特殊处理，不需要用双字符或转义。同样，在字符串内用‘'’引用的‘"’也不需要特殊处理。
下面的SELECT语句显示了引用和转义如何工作：
mysql> SELECT 'hello', '"hello"', '""hello""', 'hel''lo', '\'hello';
+-------+---------+-----------+--------+--------+
| hello | "hello" | ""hello"" | hel'lo | 'hello |
+-------+---------+-----------+--------+--------+
 
mysql> SELECT "hello", "'hello'", "''hello''", "hel""lo", "\"hello";
+-------+---------+-----------+--------+--------+
| hello | 'hello' | ''hello'' | hel"lo | "hello |
+-------+---------+-----------+--------+--------+
 
mysql> SELECT 'This\nIs\nFour\nLines';
+--------------------+
| This
Is
Four
Lines |
+--------------------+
 
mysql> SELECT 'disappearing\ backslash';
+------------------------+
| disappearing backslash |
+------------------------+
如果你想要在字符串列内插入二进制数据(例如BLOB)，必须通过转义序列表示下面的字符：
NUL
NUL字节(ASCII 0)。用‘\0’表示该字符(反斜线后面跟一个ASCII‘0’字符)。
\
反斜线(ASCII 92)。用‘\\’表示该字符。
'
单引号(ASCII 39)。用‘\'’表示该字符。
"
双引号(ASCII 34)。用‘\"’表示该字符。
当编写应用程序时，在包含这些特殊字符的字符串用于发送到MySQL服务器的SQL语句中的数据值之前，必须对它们正确进行转义。可以用两种方法来完成：
·         用转义特殊字符的函数处理字符串。例如，在C程序中，可以使用mysql_real_escape_string() C API函数来转义字符。参见25.2.3.52节，“mysql_real_escape_string()”。Perl DBI接口提供一个quote方法来将特殊字符转换为正确的转义序列。参见25.4节，“MySQL Perl API”。
·         显式转义特殊字符，许多MySQL API提供了占位符功能，允许你在查询字符串中插入特殊标记，然后当你发出查询时将数据值同它们绑定起来。在这种情况下，API关注转义值中的特殊字符。
9.1.2. 数值
整数用一系列阿拉伯数字表示。浮点数使用‘.’作为十进制间隔符。两种类型的数值均可以在前面加一个‘-’来表示负值。
合法整数的例子：
1221
0
-32
合法浮点数的例子：
294.42
-32032.6809e+10
148.00
整数可以用在浮点环境中；它被解释为与浮点数等效。
9.1.3. 十六进制值
MySQL支持十六进制值。在数字上下文中，十六进制数如同整数(64位精度)。在字符串上下文，如同二进制字符串，每对十六进制数字被转换为一个字符：
mysql> SELECT x'4D7953514C'；
        -> 'MySQL'
mysql> SELECT 0xa+0；
        -> 10
mysql> SELECT 0x5061756c；
        -> 'Paul'
十六进制值的默认类型是字符串。如果想要确保该值作为数字处理，可以使用CAST(...AS UNSIGNED)：
mysql> SELECT 0x41，CAST(0x41 AS UNSIGNED)；
        -> 'A'，65
0x语法基于ODBC。十六进制字符串通常用于ODBC以便为BLOB列提供值。x’hexstring’语法基于标准SQL。
可以用HEX()函数将一个字符串或数字转换为十六进制格式的字符串：
mysql> SELECT HEX('cat')；
        -> '636174'
mysql> SELECT 0x636174；
        -> 'cat'
9.1.4. 布尔值
常量TRUE等于1，常量FALSE等于0。常量名可以写成大写或小写。
mysql> SELECT TRUE，true，FALSE，false；
        -> 1，1，0，0
9.1.5. 位字段值
可以使用b'value'符号写位字段值。value是一个用0和1写成的二进制值。
位字段符号可以方便指定分配给BIT列的值：
mysql> CREATE TABLE t (b BIT(8));
mysql> INSERT INTO t SET b = b'11111111';
mysql> INSERT INTO t SET b = b'1010';
+------+----------+----------+----------+
| b+0  | BIN(b+0) | OCT(b+0) | HEX(b+0) |
+------+----------+----------+----------+
|  255 | 11111111 | 377      | FF       |
|   10 | 1010     | 12       | A        |
+------+----------+----------+----------+
9.1.6. NULL值
NULL值表示“没有数据”。NULL可以写成大写或小写。
请注意NULL值不同于数字类型的0或字符串类型的空字符串。参见A.5.3节，“与NULL值有关的问题”。
对于用LOAD DATA INFILE或SELECT ...INTO OUTFILE执行的文本文件导入或导出操作，NULL用序列\N表示。参见13.2.5节，“LOAD DATA INFILE语法”。
9.2. 数据库、表、索引、列和别名
9.2.1. 识别符限制条件 
9.2.2. 识别符大小写敏感性
数据库、表、索引、列和别名是识别符。该节描述了在MySQL中识别符的允许的语法。
下面的表描述了每类识别符的最大长度和允许的字符。
识别符
最大长度(字节)
允许的字符
数据库
64
目录名允许的任何字符，不包括‘/’、‘\’或者‘。’
表
64
文件名允许的任何字符，不包括‘/’、‘\’或者‘。’
列
64
所有字符
索引
64
所有字符
别名
255
所有字符
除了表内注明的限制，识别符不可以包含ASCII 0或值为255的字节。数据库、表和列名不应以空格结尾。在识别符中可以使用引号识别符，尽管应尽可能避免这样使用。
识别符用Unicode(UTF8)保存。在.frm文件中保存的表定义的识别符和在mysql数据库中的授权表保存的识别符也用Unicode(UTF8)保存。在MySQL 5.1中授权表(和其它表)的字符串列的大小等于字符个数；这说明(不象以前版本的MySQL)你可以在这些列保存的值中使用多字节字符而不需要降低字符个数。
识别符可以引起来也可以不引起来。如果识别符是一个保留字或包含特殊字符，无论何时使用，必须将它引起来。关于保留字的列表参见9.6节，“MySQL中保留字的处理”。特殊字符指那些当前字符集、‘_’和‘$’之外的文字数字字符集。
识别符的引用符是反勾号(‘`’)：
mysql> SELECT * FROM `select` WHERE `select`.id > 100;
如果SQL服务器模式包括ANSI_QUOTES模式选项，还可以用双引号将识别符引起来：
mysql> CREATE TABLE "test" (col INT);
ERROR 1064: You have an error in your SQL syntax. (...)
mysql> SET sql_mode='ANSI_QUOTES';
mysql> CREATE TABLE "test" (col INT);
Query OK, 0 rows affected (0.00 sec)
参见5.3.2节，“SQL服务器模式”。
如果你引用识别符，可以在识别符内包括识别符引用符。如果识别符内包括的字符与引用识别符的字符相同，则需要用双字符。下面的语句创建一个名为a`b包含列c"d的表：
mysql> CREATE TABLE `a``b` (`c"d` INT)；
建议不要使用XeX模式的名，例如1e或2e2，因为类似1e+1的表达式比较模糊。根据上下文，它可以解释为表达式1e + 1或数字1e+1。
使用MD5产生表名时应仔细，因为它可能产生不合法的表名，如上所述。
9.2.1. 识别符限制条件
MySQL允许使用由单个识别符或多个识别符组成的名字。多部分名各组件之间应以句点(‘.’)间隔开。多部分名的开头部分作为限定词，后面的识别符被解释。
在MySQL中可以引用下面形式的列：
列参考
含义
col_name
列col_name，查询中使用的表包含有此名字的列。
tbl_name.col_name
默认数据库中的表tbl_name的列col_name。
db_name.tbl_name.col_name
数据库db_name中的表tbl_name的列col_name。
 
如果多部分名的组件需要引用，应分别将它们引起来而不要将整个名引起来。例如，`my-tables`.`my-column` 有效，而`my-tables.my-column`无效。
不需要在语句中为列指定tbl_name或db_name.tbl_name前缀，除非列会很模糊。假定表t1和t2各包含一个列c，你使用SELECT语句在t1和t2中搜索c。在这种情况下，c很模糊，因为它在语句中使用的表内不唯一。你必须用表名t1.c或t2.c限定它，表示指哪个表。同样，要想用同一语句搜索数据库db1中的表t和数据库db2中的表t，你必须将那些表中的列指为db1.t.col_name和db2.t.col_name。
限定名中句点后面的字必须为一个识别符，因此不需要将它引起来，即使是一个保留字。
语法.tbl_name表示当前数据库中的tbl_name。该语法与ODBC兼容，因为某些ODBC程序在表名前面加前缀‘.’字符。
9.2.2. 识别符大小写敏感性
在MySQL中，数据库对应数据目录中的目录。数据库中的每个表至少对应数据库目录中的一个文件(也可能是多个，取决于存储引擎)。因此，所使用操作系统的大小写敏感性决定了数据库名和表名的大小写敏感性。这说明在大多数Unix中数据库名和表名对大小写敏感，而在Windows中对大小写不敏感。一个显著的例外情况是Mac OS X，它基于Unix但使用默认文件系统类型(HFS+)，对大小写不敏感。然而，Mac OS X也支持UFS卷，该卷对大小写敏感，就像Unix一样。参见1.8.4节，“MySQL对标准SQL的扩展”。
注释：尽管在某些平台中数据库名和表名对大小写不敏感，不应在同一查询中使用不同的大小写来引用给定的数据库或表。下面的查询不会工作，因为它同时引用了表my_tables和as MY_tables：
mysql> SELECT * FROM my_table WHERE MY_TABLE.col=1;
列、索引、存储子程序和触发器名在任何平台上对大小写不敏感，列的别名也不敏感。
默认情况，表别名在Unix中对大小写敏感，但在Windows或Mac OS X中对大小写不敏感。下面的查询在Unix中不会工作，因为它同时引用了别名a和A：
mysql> SELECT col_name FROM tbl_name AS a
    -> WHERE a.col_name = 1 OR A.col_name = 2;
然而，该查询在Windows中是可以的。要想避免出现差别，最好采用一致的转换，例如总是用小写创建并引用数据库名和表名。在大多数移植和使用中建议使用该转换。
在MySQL中如何在硬盘上保存和使用表名和数据库名由lower_case_tables_name系统变量确定，可以在启动mysqld时设置。lower_case_tables_name可以采用下面的任一值：
值
含义
0
使用CREATE TABLE或CREATE DATABASE语句指定的大写和小写在硬盘上保存表名和数据库名。名称比较对大小写敏感。在Unix系统中的默认设置即如此。请注意如果在大小写不敏感的文件系统上用--lower-case-table-names=0强制设为0，并且使用不同的大小写访问MyISAM表名，会导致索引破坏。
1
表名在硬盘上以小写保存，名称比较对大小写敏感。MySQL将所有表名转换为小写以便存储和查找。该行为也适合数据库名和表的别名。该值为Windows和Mac OS X系统中的默认值。
2
表名和数据库名在硬盘上使用CREATE TABLE或CREATE DATABASE语句指定的大小写进行保存，但MySQL将它们转换为小写以便查找。名称比较对大小写敏感。注释：只在对大小写不敏感的文件系统上适用! InnoDB表名以小写保存，例如lower_case_tables_name=1。
在Windows和Mac OS X中，lower_case_tables_name的 默认值是1。
如果只在一个平台上使用MySQL，通常不需要更改lower_case_tables_name变量。然而，如果你想要在对大小写敏感不同的文件系统的平台之间转移表，会遇到困难。例如，在Unix中，my_tables和MY_tables是两个不同的表，但在Windows中，这两个表名相同。要想避免由于数据库或表名的大小写造成的数据转移问题，可使用两个选项：
·         在任何系统中可以使用lower_case_tables_name=1。使用该选项的不利之处是当使用SHOW TABLES或SHOW DATABASES时，看不出名字原来是用大写还是小写。
·         在Unix中使用lower_case_tables_name=0，在Windows中使用lower_case_tables_name=2。这样了可以保留数据库名和表名的大小写。不利之处是必须确保在Windows中查询总是用正确大小写引用数据库名和表名。如果将查询转移到Unix中，由于在Unix中大小写很重要，如果大小写不正确，它们不工作。
例外：如果你正使用InnoDB表，在任何平台上均应将lower_case_tables_name设置为1，以强制将名转换为小写。
请注意在Unix中将lower_case_tables_name设置为1之前，重启mysqld之前，必须先将旧的数据库名和表名转换为小写。
9.3. 用户变量
可以先在用户变量中保存值然后在以后引用它；这样可以将值从一个语句传递到另一个语句。用户变量与连接有关。也就是说，一个客户端定义的变量不能被其它客户端看到或使用。当客户端退出时，该客户端连接的所有变量将自动释放。
用户变量的形式为@var_name，其中变量名var_name可以由当前字符集的文字数字字符、‘.’、‘_’和‘$’组成。 默认字符集是cp1252 (Latin1)。可以用mysqld的--default-character-set选项更改字符集。参见5.10.1节，“数据和排序用字符集”。用户变量名对大小写不敏感。
设置用户变量的一个途径是执行SET语句：
SET @var_name = expr [, @var_name = expr] ...
对于SET，可以使用=或:=作为分配符。分配给每个变量的expr可以为整数、实数、字符串或者NULL值。
也可以用语句代替SET来为用户变量分配一个值。在这种情况下，分配符必须为:=而不能用=，因为在非SET语句中=被视为一个比较 操作符：
mysql> SET @t1=0, @t2=0, @t3=0;
mysql> SELECT @t1:=(@t2:=1)+@t3:=4,@t1,@t2,@t3;
+----------------------+------+------+------+
| @t1:=(@t2:=1)+@t3:=4 | @t1  | @t2  | @t3  |
+----------------------+------+------+------+
|                    5 |    5 |    1 |    4 |
+----------------------+------+------+------+
用户变量可以用于表达式中。目前不包括明显需要文字值的上下文中，例如SELECT语句的LIMIT子句，或者LOAD DATA语句的IGNORE number LINES子句。
如果使用没有初始化的变量，其值是NULL。
如果用户变量分配了一个字符串值，其字符集和校对规则与该字符串的相同。用户变量的可压缩性（coercibility）是隐含的。(即为表列值的相同的可压缩性（coercibility）。
注释：在SELECT语句中，表达式发送到客户端后才进行计算。这说明在HAVING、GROUP BY或者ORDER BY子句中，不能使用包含SELECT列表中所设的变量的表达式。例如，下面的语句不能按期望工作：
mysql> SELECT (@aa:=id) AS a，(@aa+3) AS b 从tbl_name HAVING b=5；
HAVING子句中引用了SELECT列表中的表达式的别名，使用@aa。不能按期望工作：@aa不包含当前行的值，而是前面所选的行的id值。
一般原则是不要在语句的一个部分为用户变量分配一个值而在同一语句的其它部分使用该变量。可能会得到期望的结果，但不能保证。
设置变量并在同一语句中使用它的另一个问题是变量的默认结果的类型取决于语句前面的变量类型。下面的例子说明了该点：
mysql> SET @a='test';
mysql> SELECT @a,(@a:=20) FROM tbl_name;
对于该 SELECT语句，MySQL向客户端报告第1列是一个字符串，并且将@a的所有访问转换为字符串，即使@a在第2行中设置为一个数字。执行完SELECT语句后，@a被视为下一语句的一个数字。
要想避免这种问题，要么不在同一个语句中设置并使用相同的变量，要么在使用前将变量设置为0、0.0或者''以定义其类型。
未分配的变量有一个值NULL，类型为字符串。
9.4. 系统变量
9.4.1. 结构式系统变量
MySQL可以访问许多系统和连接变量。当服务器运行时许多变量可以动态更改。这样通常允许你修改服务器操作而不需要停止并重启服务器。
mysqld服务器维护两种变量。全局变量影响服务器整体操作。会话变量影响具体客户端连接的操作。
当服务器启动时，它将所有全局变量初始化为默认值。这些默认值可以在选项文件中或在命令行中指定的选项进行更改。服务器启动后，通过连接服务器并执行SET GLOBAL var_name语句，可以动态更改这些全局变量。要想更改全局变量，必须具有SUPER权限。
服务器还为每个连接的客户端维护一系列会话变量。在连接时使用相应全局变量的当前值对客户端的会话变量进行初始化。对于动态会话变量，客户端可以通过SET SESSION var_name语句更改它们。设置会话变量不需要特殊权限，但客户端只能更改自己的会话变量，而不能更改其它客户端的会话变量。
对于全局变量的更改可以被访问该全局变量的任何客户端看见。然而，它只影响更改后连接的客户的从该全局变量初始化的相应会话变量。不影响目前已经连接的客户端的会话变量(即使客户端执行SET GLOBAL语句也不影响)。
可以使用几种语法形式来设置或检索全局或会话变量。下面的例子使用了sort_buffer_sizeas作为示例变量名。
要想设置一个GLOBAL变量的值，使用下面的语法：
mysql> SET GLOBAL sort_buffer_size=value;
mysql> SET @@global.sort_buffer_size=value;
要想设置一个SESSION变量的值，使用下面的语法：
mysql> SET SESSION sort_buffer_size=value;
mysql> SET @@session.sort_buffer_size=value;
mysql> SET sort_buffer_size=value;
LOCAL是SESSION的同义词。
如果设置变量时不指定GLOBAL、SESSION或者LOCAL，默认使用SESSION。参见13.5.3节，“SET语法”。
要想检索一个GLOBAL变量的值，使用下面的语法：
mysql> SELECT @@global.sort_buffer_size;
mysql> SHOW GLOBAL VARIABLES like 'sort_buffer_size';
要想检索一个SESSION变量的值，使用下面的语法：
mysql> SELECT @@sort_buffer_size;
mysql> SELECT @@session.sort_buffer_size;
mysql> SHOW SESSION VARIABLES like 'sort_buffer_size';
这里，LOCAL也是SESSION的同义词。
当你用SELECT @@var_name搜索一个变量时(也就是说，不指定global.、session.或者local.)，MySQL返回SESSION值（如果存在），否则返回GLOBAL值。
对于SHOW VARIABLES，如果不指定GLOBAL、SESSION或者LOCAL，MySQL返回SESSION值。
当设置GLOBAL变量需要GLOBAL关键字但检索时不需要它们的原因是防止将来出现问题。如果我们移除一个与某个GLOBAL变量具有相同名字的SESSION变量，具有SUPER权限的客户可能会意外地更改GLOBAL变量而不是它自己的连接的SESSION变量。如果我们添加一个与某个GLOBAL变量具有相同名字的SESSION变量，想更改GLOBAL变量的客户可能会发现只有自己的SESSION变量被更改了。
关于系统启动选项和系统变量的详细信息参见5.3.1节，“mysqld命令行选项”和5.3.3节，“服务器系统变量”。在5.3.3.1节，“动态系统变量”中列出了可以在运行时设置的变量。
9.4.1. 结构式系统变量
结构式变量在两个方面不同于常规系统变量：
·         其值是一个含组件的结构，可以指定服务器参数，一般紧密相关。
·         可能是给定类型的结构式变量的几个实例。每个实例有一个不同的名，指向服务器维护的不同的资源。
MySQL 5.1支持结构式变量类型，可以指定监控键值缓存操作的参数。键值缓存结构式变量有以下组件：
·         key_buffer_size
·         key_cache_block_size
·         key_cache_division_limit
·         key_cache_age_threshold
该节描述了引用结构式变量的语法。在语法的例子中使用了键值缓存变量，但关于键值缓存如何操作的具体详情在其它章节中，如 7.4.6节，“MyISAM键高速缓冲”。
要引用结构式变量实例的组件，可以使用instance_name.component_name格式的复合名。例如：
hot_cache.key_buffer_size
hot_cache.key_cache_block_size
cold_cache.key_cache_block_size
对于每个结构式系统变量，总是预定义名为default的一个实例。如果不使用任何实例名引用结构式变量的一个组件，default实例被使用。这样，default.key_buffer_size和key_buffer_sizeboth均指向同一系统变量。
结构式变量实例和组件的命名规则为：
·         对于给定类型的结构式变量，每个实例必须有一个在该类变量中唯一的一个名。但是，在不同类型的结构式变量中实例名不需要唯一。例如，每个结构式变量有一个实例default，因此在不同的变量类型中default不是唯一的。
·         每个结构式变量类型的组件名在所有系统变量名中必须是唯一的。如果不是这样(也就是说，如果两个不同类型的结构式变量能够共享组件成员名)，将不清楚使用哪个默认结构式变量来用作没有使用实例名限定的成员名。
·         如果结构式变量实例名作为未引起来的识别符不合法，将它用反勾号引起来作为识别符。例如，hot-cache不合法，但`hot-cache` 合法。
·         global、session和local不是合法实例名。这样可以避免与引用非结构式系统变量的符号的冲突，例如@@global.var_name。
目前，这前两个规则不可能违背，因为唯一的结构式变量类型是键值缓存。在将来创建其它类型的结构式变量，这些规则将有重要的意义。
一个例外是，可以在可能出现简单变量名的上下文中使用复合名引用结构式变量组件。例如，可以使用一个命令行选项未某个结构式变量分配一个值：
shell> mysqld --hot_cache.key_buffer_size=64K
在选项文件中，使用：
[mysqld]
hot_cache.key_buffer_size=64K
如果用该选项启动服务器，除了默认大小为8MB的默认键值缓存，还创建一个名为hot_cache的键值缓存，大小为64KB。
假定你这样启动服务器：
shell> mysqld --key_buffer_size=256K \
         --extra_cache.key_buffer_size=128K \
         --extra_cache.key_cache_block_size=2048
在这种情况下，服务器将默认键值缓存的大小设定为256KB。(也可以写成--default.key_buffer_size=256K）。 并且，服务器创建一个名为extra_cache的第2个键值缓存，大小为128KB，缓存表索引块的块缓存区的大小设置为2048字节。
在下面的例子中，用3个不同的键值缓存（大小比例为3:1:1）启动服务器：
shell> mysqld --key_buffer_size=6M \
         --hot_cache.key_buffer_size=2M \
         --cold_cache.key_buffer_size=2M
也可以在运行时设置和检索结构式变量值。例如，要想将名为hot_cache的一个键值缓存的大小设置为10MB，使用下面任何一个语句：
mysql> SET GLOBAL hot_cache.key_buffer_size = 10*1024*1024;
mysql> SET @@global.hot_cache.key_buffer_size = 10*1024*1024;
要想检索缓存大小，执行：
mysql> SELECT @@global.hot_cache.key_buffer_size;
但是，下面的语句不工作。变量不解释为一个复合名，而是解释为LIKE模式匹配操作的简单字符串：
mysql> SHOW GLOBAL VARIABLES LIKE 'hot_cache.key_buffer_size';
这是一个在可能出现简单的变量名时使用结构式变量名的例子。
9.5. 注释语法
MySQL服务器支持3种注释风格：
·         从‘#’字符从行尾。
·         从‘-- ’序列到行尾。请注意‘-- ’(双破折号)注释风格要求第2个破折号后面至少跟一个空格符(例如空格、tab、换行符等等)。该语法与标准SQL注释语法稍有不同，后者将在1.8.5.7, “‘--’作为注释起始标记”中讨论。
·         从/*序列到后面的*/序列。结束序列不一定在同一行中，因此该语法允许注释跨越多行。
下面的例子显示了3种风格的注释：
mysql> SELECT 1+1;     # This comment continues to the end of line
mysql> SELECT 1+1;     -- This comment continues to the end of line
mysql> SELECT 1 /* this is an in-line comment */ + 1;
mysql> SELECT 1+
/*
this is a
multiple-line comment
*/
1;
上述的注释语法适用于mysqld服务器如何分析SQL语句。发送到服务器之前，mysql客户程序也执行部分语句解析。(例如，它通过解析来确定在多语句行中的语句边界）。
在MySQL 5.1中，mysql解析/* ...*/注释的唯一局限性是结合该风格的注释定界符使用的叹号标记了有条件执行的SQL语句部分。适用于交互式运行mysql和将命令放入一个文件中，并以批处理模式使用mysql来处理mysql < file_name的文件。详细信息和例子参见1.8.4节，“MySQL对标准SQL的扩展”。
9.6. MySQL中保留字的处理
尝试使用一个识别符，例如使用嵌入式MySQL数据类型或函数名作为表名或列名，例如TIMESTAMP或GROUP，会造成一个常见问题。允许你这样操作(例如，ABS可以作为一个列名)。但是，默认情况下，在数调用中在函数名和后面的‘(’字符之间不允许有空格。该要求使函数调用与列名引用不同。
该行为的不利结果是在某些上下文中省略一个空格会使识别符解释为函数名。例如，该语句合法：
mysql> CREATE TABLE abs (val INT)；
但省略abs后面的空格会造成语法错误，因为省略后该语句好像要调用ABS()函数：
mysql> CREATE TABLE abs(val INT);
如果SQL服务器模式包括IGNORE_SPACE模式值，服务器允许函数调用时在函数名和后面的‘(’字符之间有空格。这样使函数名被视为保留字。结果是，与函数名相同的识别符必须按照9.2节，“数据库、表、索引、列和别名”中所描述的引起来。SQL服务器模式按照5.3.2节，“SQL服务器模式”中所描述的进行控制。
限定名中句点后面的字必须为一个识别符，因此不需要将它引起来，即使它是一个保留字。
在MySQL中，下表中的字显式被保留。其中大多数字进制被标准SQL用作列名和/或表名(例如，GROUP)。少数被保留了，因为MySQL需要它们，(目前)使用yacc解析程序。保留字被引起来后可以用作识别符。
ADD
ALL
ALTER
ANALYZE
AND
AS
ASC
ASENSITIVE
BEFORE
BETWEEN
BIGINT
BINARY
BLOB
BOTH
BY
CALL
CASCADE
CASE
CHANGE
CHAR
CHARACTER
CHECK
COLLATE
COLUMN
CONDITION
CONNECTION
CONSTRAINT
CONTINUE
CONVERT
CREATE
CROSS
CURRENT_DATE
CURRENT_TIME
CURRENT_TIMESTAMP
CURRENT_USER
CURSOR
DATABASE
DATABASES
DAY_HOUR
DAY_MICROSECOND
DAY_MINUTE
DAY_SECOND
DEC
DECIMAL
DECLARE
DEFAULT
DELAYED
DELETE
DESC
DESCRIBE
DETERMINISTIC
DISTINCT
DISTINCTROW
DIV
DOUBLE
DROP
DUAL
EACH
ELSE
ELSEIF
ENCLOSED
ESCAPED
EXISTS
EXIT
EXPLAIN
FALSE
FETCH
FLOAT
FLOAT4
FLOAT8
FOR
FORCE
FOREIGN
FROM
FULLTEXT
GOTO
GRANT
GROUP
HAVING
HIGH_PRIORITY
HOUR_MICROSECOND
HOUR_MINUTE
HOUR_SECOND
IF
IGNORE
IN
INDEX
INFILE
INNER
INOUT
INSENSITIVE
INSERT
INT
INT1
INT2
INT3
INT4
INT8
INTEGER
INTERVAL
INTO
IS
ITERATE
JOIN
KEY
KEYS
KILL
LABEL
LEADING
LEAVE
LEFT
LIKE
LIMIT
LINEAR
LINES
LOAD
LOCALTIME
LOCALTIMESTAMP
LOCK
LONG
LONGBLOB
LONGTEXT
LOOP
LOW_PRIORITY
MATCH
MEDIUMBLOB
MEDIUMINT
MEDIUMTEXT
MIDDLEINT
MINUTE_MICROSECOND
MINUTE_SECOND
MOD
MODIFIES
NATURAL
NOT
NO_WRITE_TO_BINLOG
NULL
NUMERIC
ON
OPTIMIZE
OPTION
OPTIONALLY
OR
ORDER
OUT
OUTER
OUTFILE
PRECISION
PRIMARY
PROCEDURE
PURGE
RAID0
RANGE
READ
READS
REAL
REFERENCES
REGEXP
RELEASE
RENAME
REPEAT
REPLACE
REQUIRE
RESTRICT
RETURN
REVOKE
RIGHT
RLIKE
SCHEMA
SCHEMAS
SECOND_MICROSECOND
SELECT
SENSITIVE
SEPARATOR
SET
SHOW
SMALLINT
SPATIAL
SPECIFIC
SQL
SQLEXCEPTION
SQLSTATE
SQLWARNING
SQL_BIG_RESULT
SQL_CALC_FOUND_ROWS
SQL_SMALL_RESULT
SSL
STARTING
STRAIGHT_JOIN
TABLE
TERMINATED
THEN
TINYBLOB
TINYINT
TINYTEXT
TO
TRAILING
TRIGGER
TRUE
UNDO
UNION
UNIQUE
UNLOCK
UNSIGNED
UPDATE
USAGE
USE
USING
UTC_DATE
UTC_TIME
UTC_TIMESTAMP
VALUES
VARBINARY
VARCHAR
VARCHARACTER
VARYING
WHEN
WHERE
WHILE
WITH
WRITE
X509
XOR
YEAR_MONTH
ZEROFILL
MySQL允许部分关键字用做未引起来的识别符，因为许多人以前曾使用过它们。下面列出了一些例子：
ACTION 
BIT 
DATE 
ENUM 
NO 
TEXT 
TIME 
TIMESTAMP 
