#
# glob.glob() and os.walk() use fnmatch and os.listdir()
#
1) both glob.glob() and os.walk() use fnmatch and os.listdir()

2) glob.glob() could be used to find matched files / paths

      >>> print(glob.glob.__doc__)
      Return a list of paths matching a pathname pattern.
      
          The pattern may contain simple shell-style wildcards a la
          fnmatch. However, unlike fnmatch, filenames starting with a
          dot are special cases that are not matched by '*' and '?'
          patterns.
      
       
      >>> for i in glob.glob('*'):
      ...     print(i)
      ... 
      bigext_tree.py
      bigpy_path.py
      
3) os.walk() could be used to find a whole tree of a path.

      Directory tree generator.
      
          For each directory in the directory tree rooted at top (including top
          itself, but excluding '.' and '..'), yields a 3-tuple
      
              dirpath, dirnames, filenames
      
          dirpath is a string, the path to the directory.  dirnames is a list of
          the names of the subdirectories in dirpath (excluding '.' and '..').
          filenames is a list of the names of the non-directory files in dirpath.
          Note that the names in the lists are just names, with no path components.
          To get a full path (which begins with top) to a file or directory in
          dirpath, do os.path.join(dirpath, name).
      
          If optional arg 'topdown' is true or not specified, the triple for a
          directory is generated before the triples for any of its subdirectories
          (directories are generated top down).  If topdown is false, the triple
          for a directory is generated after the triples for all of its
          subdirectories (directories are generated bottom up).
      
          When topdown is true, the caller can modify the dirnames list in-place
          (e.g., via del or slice assignment), and walk will only recurse into the
          subdirectories whose names remain in dirnames; this can be used to prune the
          search, or to impose a specific order of visiting.  Modifying dirnames when
          topdown is false is ineffective, since the directories in dirnames have
          already been generated by the time dirnames itself is generated. No matter
          the value of topdown, the list of subdirectories is retrieved before the
          tuples for the directory and its subdirectories are generated.
      
          By default errors from the os.listdir() call are ignored.  If
          optional arg 'onerror' is specified, it should be a function; it
          will be called with one argument, an os.error instance.  It can
          report the error to continue with the walk, or raise the exception
          to abort the walk.  Note that the filename is available as the
          filename attribute of the exception object.
      
          By default, os.walk does not follow symbolic links to subdirectories on
          systems that support them.  In order to get this functionality, set the
          optional argument 'followlinks' to true.
      
          Caution:  if you pass a relative pathname for top, don't change the
          current working directory between resumptions of walk.  walk never
          changes the current directory, and assumes that the client doesn't
          either.
      
          Example:
      
          import os
          from os.path import join, getsize
          for root, dirs, files in os.walk('python/Lib/email'):
              print root, "consumes",
              print sum([getsize(join(root, name)) for name in files]),
              print "bytes in", len(files), "non-directory files"
              if 'CVS' in dirs:
                  dirs.remove('CVS')  # don't visit CVS directories
      


      >>> for (theDir, subsHere, filesHere) in os.walk('..'):
      ...     print('theDir = {0}'.format(theDir))
      ...     for f in filesHere:
      ...             fullpath = os.path.join(theDir, f)
      ...             print('\tfullpath = {0}'.format(fullpath))
      ... 
      theDir = ..
      	fullpath = ../add_pyheader.py
      
      theDir = ../20130318HoneywellHackathon
      	fullpath = ../20130318HoneywellHackathon/.DS_Store
      
      theDir = ../20170228PythonAlgorithms_WWCodeSH
      	fullpath = ../20170228PythonAlgorithms_WWCodeSH/KthMax.py
      theDir = ../gui
      	fullpath = ../gui/tkinter_hello_to_input.py
      	fullpath = ../gui/tkinter_hello_world.py
      theDir = ../orm
      	fullpath = ../orm/orm_created_with_metaclass.py
      theDir = ../parallel
      	fullpath = ../parallel/child.py
      
4) fnmatch.fnmatch() checks if a filename matches a pattern.

      >>> print(fnmatch.fnmatch.__doc__)
      Test whether FILENAME matches PATTERN.
      
          Patterns are Unix shell style:
      
          *       matches everything
          ?       matches any single character
          [seq]   matches any character in seq
          [!seq]  matches any char not in seq
      
          An initial period in FILENAME is not special.
          Both FILENAME and PATTERN are first case-normalized
          if the operating system requires it.
          If you don't want this, use fnmatchcase(FILENAME, PATTERN).
    

      >>> for f in os.popen('ls .'):
      ...     f = f.strip()
      ...     if fnmatch.fnmatch(f, '*.py'):
      ...             print(f)
      ... 
      bigext_tree.py
      bigpy_path.py


5) os.listdir() lists entries directly under a directory, except '.' and '..'.

      >>> print(os.listdir.__doc__)
      listdir(path) -> list_of_strings
      
      Return a list containing the names of the entries in the directory.
      
          path: path of directory to list
      
      The list is in arbitrary order.  It does not include the special
      entries '.' and '..' even if they are present in the directory.
      
      >>> for d in os.listdir('.'):
      ...     print(d)
      ... 
      bigext_tree.py
      bigpy_path.py

6) How to get the latest file in a folder using python
	
		import glob, os.path
		
		list_of_files = glob.glob('/path/to/find/*')
		latest_file = max(list_of_files, key=os.path.getmtime)
		print(latest_file)
	
	# or
	
		import glob
		import os
		
		files_path = os.path.join(folder, '*')
		files = sorted(
			glob.iglob(files_path), key=os.path.getctime, reverse=True) 
		print files[0]
	
	# or
	
		# to get modification date/times of a file: return timestamp
		os.stat(file_with_full_path).st_mtime

		# return a datetime instance
		t = os.path.getmtime(filename)	
		# or
		t = os.stat(filename).st_mtime
		print(datetime.datetime.fromtimestamp(t))
	
7) How to get the creation and modification time of a file
	
	in 2016:
	"Getting some sort of modification date in a cross-platform way is easy - just call os.path.getmtime(path) 
		and you'll get the Unix timestamp of when the file at path was last modified.

	Getting file creation dates, on the other hand, is fiddly and platform-dependent, differing even between the three big OSes:
		On Windows, a file's ctime (documented at https://msdn.microsoft.com/en-us/library/14h5k7ff.aspx) stores its creation date. 
		You can access this in Python through os.path.getctime() or the .st_ctime attribute of the result of a call to os.stat(). 
		This won't work on Unix, where the ctime is the last time that the file's attributes or content were changed.
		
		On Mac, as well as some other Unix-based OSes, you can use the .st_birthtime attribute of the result of a call to os.stat().
		
		On Linux, this is currently impossible, at least without writing a C extension for Python. Although some file systems commonly used with Linux
			do store creation dates (for example, ext4 stores them in st_crtime) , the Linux kernel offers no way of accessing them; 
			in particular, the structs it returns from stat() calls in C, as of the latest kernel version, don't contain any creation date fields. 
			You can also see that the identifier st_crtime doesn't currently feature anywhere in the Python source. 
			At least if you're on ext4, the data is attached to the inodes in the file system, but there's no convenient way of accessing it.

		The next-best thing on Linux is to access the file's mtime, through either os.path.getmtime() or the .st_mtime attribute of an os.stat() result. 
		This will give you the last time the file's content was modified, which may be adequate for some use cases."


		import os
		import platform
		
		def creation_date(path_to_file):
			"""
			Try to get the date that a file was created, falling back to when it was
			last modified if that isn't possible.
			See http://stackoverflow.com/a/39501288/1709587 for explanation.
			"""
			if platform.system() == 'Windows':
				return os.path.getctime(path_to_file)
			else:
				stat = os.stat(path_to_file)
				try:
					return stat.st_birthtime
				except AttributeError:
					# We're probably on Linux. No easy way to get creation dates here,
					# so we'll settle for when its content was last modified.
					return stat.st_mtime
				
			
	
# ref:	https://stackoverflow.com/questions/39327032/how-to-get-the-latest-file-in-a-folder-using-python
# ref:	https://stackoverflow.com/questions/237079/how-to-get-file-creation-modification-date-times-in-python




