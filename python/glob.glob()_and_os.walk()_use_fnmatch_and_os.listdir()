#
# glob.glob() and os.walk() use fnmatch and os.listdir()
#
1) both glob.glob() and os.walk() use fnmatch and os.listdir()

2) glob.glob() could be used to find matched files / paths

      >>> print(glob.glob.__doc__)
      Return a list of paths matching a pathname pattern.
      
          The pattern may contain simple shell-style wildcards a la
          fnmatch. However, unlike fnmatch, filenames starting with a
          dot are special cases that are not matched by '*' and '?'
          patterns.
      
       
      >>> for i in glob.glob('*'):
      ...     print(i)
      ... 
      bigext_tree.py
      bigpy_path.py
      
3) os.walk() could be used to find a whole tree of a path.

      Directory tree generator.
      
          For each directory in the directory tree rooted at top (including top
          itself, but excluding '.' and '..'), yields a 3-tuple
      
              dirpath, dirnames, filenames
      
          dirpath is a string, the path to the directory.  dirnames is a list of
          the names of the subdirectories in dirpath (excluding '.' and '..').
          filenames is a list of the names of the non-directory files in dirpath.
          Note that the names in the lists are just names, with no path components.
          To get a full path (which begins with top) to a file or directory in
          dirpath, do os.path.join(dirpath, name).
      
          If optional arg 'topdown' is true or not specified, the triple for a
          directory is generated before the triples for any of its subdirectories
          (directories are generated top down).  If topdown is false, the triple
          for a directory is generated after the triples for all of its
          subdirectories (directories are generated bottom up).
      
          When topdown is true, the caller can modify the dirnames list in-place
          (e.g., via del or slice assignment), and walk will only recurse into the
          subdirectories whose names remain in dirnames; this can be used to prune the
          search, or to impose a specific order of visiting.  Modifying dirnames when
          topdown is false is ineffective, since the directories in dirnames have
          already been generated by the time dirnames itself is generated. No matter
          the value of topdown, the list of subdirectories is retrieved before the
          tuples for the directory and its subdirectories are generated.
      
          By default errors from the os.listdir() call are ignored.  If
          optional arg 'onerror' is specified, it should be a function; it
          will be called with one argument, an os.error instance.  It can
          report the error to continue with the walk, or raise the exception
          to abort the walk.  Note that the filename is available as the
          filename attribute of the exception object.
      
          By default, os.walk does not follow symbolic links to subdirectories on
          systems that support them.  In order to get this functionality, set the
          optional argument 'followlinks' to true.
      
          Caution:  if you pass a relative pathname for top, don't change the
          current working directory between resumptions of walk.  walk never
          changes the current directory, and assumes that the client doesn't
          either.
      
          Example:
      
          import os
          from os.path import join, getsize
          for root, dirs, files in os.walk('python/Lib/email'):
              print root, "consumes",
              print sum([getsize(join(root, name)) for name in files]),
              print "bytes in", len(files), "non-directory files"
              if 'CVS' in dirs:
                  dirs.remove('CVS')  # don't visit CVS directories
      


      >>> for (theDir, subsHere, filesHere) in os.walk('..'):
      ...     print('theDir = {0}'.format(theDir))
      ...     for f in filesHere:
      ...             fullpath = os.path.join(theDir, f)
      ...             print('\tfullpath = {0}'.format(fullpath))
      ... 
      theDir = ..
      	fullpath = ../add_pyheader.py
      
      theDir = ../20130318HoneywellHackathon
      	fullpath = ../20130318HoneywellHackathon/.DS_Store
      
      theDir = ../20170228PythonAlgorithms_WWCodeSH
      	fullpath = ../20170228PythonAlgorithms_WWCodeSH/KthMax.py
      theDir = ../gui
      	fullpath = ../gui/tkinter_hello_to_input.py
      	fullpath = ../gui/tkinter_hello_world.py
      theDir = ../orm
      	fullpath = ../orm/orm_created_with_metaclass.py
      theDir = ../parallel
      	fullpath = ../parallel/child.py
      
4) fnmatch.fnmatch() checks if a filename matches a pattern.

      >>> print(fnmatch.fnmatch.__doc__)
      Test whether FILENAME matches PATTERN.
      
          Patterns are Unix shell style:
      
          *       matches everything
          ?       matches any single character
          [seq]   matches any character in seq
          [!seq]  matches any char not in seq
      
          An initial period in FILENAME is not special.
          Both FILENAME and PATTERN are first case-normalized
          if the operating system requires it.
          If you don't want this, use fnmatchcase(FILENAME, PATTERN).
    

      >>> for f in os.popen('ls .'):
      ...     f = f.strip()
      ...     if fnmatch.fnmatch(f, '*.py'):
      ...             print(f)
      ... 
      bigext_tree.py
      bigpy_path.py


5) os.listdir() lists entries directly under a directory, except '.' and '..'.

      >>> print(os.listdir.__doc__)
      listdir(path) -> list_of_strings
      
      Return a list containing the names of the entries in the directory.
      
          path: path of directory to list
      
      The list is in arbitrary order.  It does not include the special
      entries '.' and '..' even if they are present in the directory.
      
      >>> for d in os.listdir('.'):
      ...     print(d)
      ... 
      bigext_tree.py
      bigpy_path.py




